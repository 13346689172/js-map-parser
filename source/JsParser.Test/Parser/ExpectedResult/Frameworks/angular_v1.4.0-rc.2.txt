Alias: All
StartLine: 0
EndLine: 0
NodeType: Function

	Alias: ?(window,document,undefined)
	StartLine: 6
	EndLine: 28043
	NodeType: AnonymousFunction
	Comment: *&#A; * @license AngularJS v1.4.0-rc.2&#A; * (c) 2010-2015 Google, Inc. http://angularjs.org&#A; * License: MIT

		Alias: minErr(module,ErrorConstructor)
		StartLine: 38
		EndLine: 70
		NodeType: Function

			Alias: ?()
			StartLine: 40
			EndLine: 69
			NodeType: AnonymousFunction

				Alias: replace.message&gt;?(match)
				StartLine: 49
				EndLine: 58
				NodeType: AnonymousFunction

		Alias: lowercase(string)
		StartLine: 201
		EndLine: 201
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.lowercase&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description Converts the specified string to lowercase.&#A; * @param {string} string String to be converted to lowercase.&#A; * @returns {string} Lowercased string.

		Alias: uppercase(string)
		StartLine: 214
		EndLine: 214
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.uppercase&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description Converts the specified string to uppercase.&#A; * @param {string} string String to be converted to uppercase.&#A; * @returns {string} Uppercased string.

		Alias: manualLowercase(s)
		StartLine: 217
		EndLine: 222
		NodeType: Function
		Comment: jshint bitwise: false

		Alias: manualUppercase(s)
		StartLine: 223
		EndLine: 228
		NodeType: Function
		Comment: jshint bitwise: false

		Alias: isArrayLike(obj)
		StartLine: 269
		EndLine: 284
		NodeType: Function
		Comment: *&#A; * @private&#A; * @param {*} obj&#A; * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,&#A; *                   String ...)

		Alias: forEach(obj,iterator,context)
		StartLine: 321
		EndLine: 363
		NodeType: Function

		Alias: forEachSorted(obj,iterator,context)
		StartLine: 365
		EndLine: 371
		NodeType: Function

		Alias: reverseParams(iteratorFn)
		StartLine: 379
		EndLine: 381
		NodeType: Function
		Comment: *&#A; * when using forEach the params are value, key, but it is often useful to have key, value.&#A; * @param {function(string, *)} iteratorFn&#A; * @returns {function(*, string)}

			Alias: ?(value,key)
			StartLine: 380
			EndLine: 380
			NodeType: AnonymousFunction

		Alias: nextUid()
		StartLine: 393
		EndLine: 395
		NodeType: Function
		Comment: *&#A; * A consistent way of creating unique IDs in angular.&#A; *&#A; * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before&#A; * we hit number precision issues in JavaScript.&#A; *&#A; * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M&#A; *&#A; * @returns {number} an unique alpha-numeric string

		Alias: setHashKey(obj,h)
		StartLine: 403
		EndLine: 409
		NodeType: Function
		Comment: *&#A; * Set or clear the hashkey for an object.&#A; * @param obj object&#A; * @param h the hashkey (!truthy to delete the hashkey)

		Alias: baseExtend(dst,objs,deep)
		StartLine: 412
		EndLine: 434
		NodeType: Function

		Alias: extend(dst)
		StartLine: 454
		EndLine: 456
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.extend&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)&#A; * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so&#A; * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.&#A; *&#A; * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use&#A; * {@link angular.merge} for this.&#A; *&#A; * @param {Object} dst Destination object.&#A; * @param {...Object} src Source object(s).&#A; * @returns {Object} Reference to `dst`.

		Alias: merge(dst)
		StartLine: 477
		EndLine: 479
		NodeType: Function
		Comment: *&#A;* @ngdoc function&#A;* @name angular.merge&#A;* @module ng&#A;* @kind function&#A;*&#A;* @description&#A;* Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)&#A;* to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so&#A;* by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.&#A;*&#A;* Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source&#A;* objects, performing a deep copy.&#A;*&#A;* @param {Object} dst Destination object.&#A;* @param {...Object} src Source object(s).&#A;* @returns {Object} Reference to `dst`.

		Alias: toInt(str)
		StartLine: 483
		EndLine: 485
		NodeType: Function

		Alias: inherit(parent,extra)
		StartLine: 488
		EndLine: 490
		NodeType: Function

		Alias: noop()
		StartLine: 508
		EndLine: 508
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.noop&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * A function that performs no operations. This function can be useful when writing code in the&#A; * functional style.&#A;   ```js&#A;     function foo(callback) {&#A;       var result = calculateResult();&#A;       (callback || angular.noop)(result);&#A;     }&#A;   ```

		Alias: identity($)
		StartLine: 530
		EndLine: 530
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.identity&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * A function that returns its first argument. This function is useful when writing code in the&#A; * functional style.&#A; *&#A;   ```js&#A;     function transformer(transformationFn, value) {&#A;       return (transformationFn || angular.identity)(value);&#A;     };&#A;   ```&#A;  * @param {*} value to be returned.&#A;  * @returns {*} the value passed in.

		Alias: valueFn(value)
		StartLine: 534
		EndLine: 534
		NodeType: Function

			Alias: ?()
			StartLine: 534
			EndLine: 534
			NodeType: AnonymousFunction

		Alias: isUndefined(value)
		StartLine: 548
		EndLine: 548
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isUndefined&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is undefined.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is undefined.

		Alias: isDefined(value)
		StartLine: 563
		EndLine: 563
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isDefined&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is defined.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is defined.

		Alias: isObject(value)
		StartLine: 579
		EndLine: 582
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isObject&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not&#A; * considered to be objects. Note that JavaScript arrays are objects.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is an `Object` but not `null`.&#A; &#D;&#A; http://jsperf.com/isobject4

		Alias: isBlankObject(value)
		StartLine: 590
		EndLine: 592
		NodeType: Function
		Comment: *&#A; * Determine if a value is an object with a null prototype&#A; *&#A; * @returns {boolean} True if `value` is an `Object` with a null prototype

		Alias: isString(value)
		StartLine: 607
		EndLine: 607
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isString&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is a `String`.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is a `String`.

		Alias: isNumber(value)
		StartLine: 628
		EndLine: 628
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isNumber&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is a `Number`.&#A; *&#A; * This includes the &quot;special&quot; numbers `NaN`, `+Infinity` and `-Infinity`.&#A; *&#A; * If you wish to exclude these then you can use the native&#A; * [`isFinite&#39;](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)&#A; * method.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is a `Number`.

		Alias: isDate(value)
		StartLine: 643
		EndLine: 645
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isDate&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a value is a date.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is a `Date`.

		Alias: isFunction(value)
		StartLine: 674
		EndLine: 674
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isFunction&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is a `Function`.&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is a `Function`.

		Alias: isRegExp(value)
		StartLine: 684
		EndLine: 686
		NodeType: Function
		Comment: *&#A; * Determines if a value is a regular expression object.&#A; *&#A; * @private&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is a `RegExp`.

		Alias: isWindow(obj)
		StartLine: 696
		EndLine: 698
		NodeType: Function
		Comment: *&#A; * Checks if `obj` is a window object.&#A; *&#A; * @private&#A; * @param {*} obj Object to check&#A; * @returns {boolean} True if `obj` is a window obj.

		Alias: isScope(obj)
		StartLine: 701
		EndLine: 703
		NodeType: Function

		Alias: isFile(obj)
		StartLine: 706
		EndLine: 708
		NodeType: Function

		Alias: isFormData(obj)
		StartLine: 711
		EndLine: 713
		NodeType: Function

		Alias: isBlob(obj)
		StartLine: 716
		EndLine: 718
		NodeType: Function

		Alias: isBoolean(value)
		StartLine: 721
		EndLine: 723
		NodeType: Function

		Alias: isPromiseLike(obj)
		StartLine: 726
		EndLine: 728
		NodeType: Function

		Alias: isTypedArray(value)
		StartLine: 732
		EndLine: 734
		NodeType: Function

		Alias: trim(value)
		StartLine: 737
		EndLine: 739
		NodeType: Function

		Alias: escapeForRegexp(s)
		StartLine: 744
		EndLine: 747
		NodeType: Function
		Comment: Copied from:&#D;&#A; http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021&#D;&#A; Prereq: s is a string.

		Alias: isElement(node)
		StartLine: 762
		EndLine: 766
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.isElement&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if a reference is a DOM element (or wrapped jQuery element).&#A; *&#A; * @param {*} value Reference to check.&#A; * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).

		Alias: makeMap(str)
		StartLine: 772
		EndLine: 778
		NodeType: Function
		Comment: *&#A; * @param str &#39;key1,key2,...&#39;&#A; * @returns {object} in the form of {key1:true, key2:true, ...}

		Alias: nodeName_(element)
		StartLine: 781
		EndLine: 783
		NodeType: Function

		Alias: includes(array,obj)
		StartLine: 785
		EndLine: 787
		NodeType: Function

		Alias: arrayRemove(array,value)
		StartLine: 789
		EndLine: 795
		NodeType: Function

		Alias: copy(source,destinati…tackDest)
		StartLine: 855
		EndLine: 951
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.copy&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Creates a deep copy of `source`, which should be an object or an array.&#A; *&#A; * * If no destination is supplied, a copy of the object or array is created.&#A; * * If a destination is provided, all of its elements (for arrays) or properties (for objects)&#A; *   are deleted and then all elements/properties from the source are copied to it.&#A; * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.&#A; * * If `source` is identical to &#39;destination&#39; an exception will be thrown.&#A; *&#A; * @param {*} source The source that will be used to make a copy.&#A; *                   Can be any type, including primitives, `null`, and `undefined`.&#A; * @param {(Object|Array)=} destination Destination into which the source is copied. If&#A; *     provided, must be of the same type as `source`.&#A; * @returns {*} The copy or updated `destination`, if `destination` was specified.&#A; *&#A; * @example&#A; &lt;example module=&quot;copyExample&quot;&gt;&#A; &lt;file name=&quot;index.html&quot;&gt;&#A; &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A; &lt;form novalidate class=&quot;simple-form&quot;&gt;&#A; Name: &lt;input type=&quot;text&quot; ng-model=&quot;user.name&quot; /&gt;&lt;br /&gt;&#A; E-mail: &lt;input type=&quot;email&quot; ng-model=&quot;user.email&quot; /&gt;&lt;br /&gt;&#A; Gender: &lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;male&quot; /&gt;male&#A; &lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;female&quot; /&gt;female&lt;br /&gt;&#A; &lt;button ng-click=&quot;reset()&quot;&gt;RESET&lt;/button&gt;&#A; &lt;button ng-click=&quot;update(user)&quot;&gt;SAVE&lt;/button&gt;&#A; &lt;/form&gt;&#A; &lt;pre&gt;form = {{user | json}}&lt;/pre&gt;&#A; &lt;pre&gt;master = {{master | json}}&lt;/pre&gt;&#A; &lt;/div&gt;&#A;&#A; &lt;script&gt;&#A;  angular.module(&#39;copyExample&#39;, [])&#A;    .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;      $scope.master= {};&#A;&#A;      $scope.update = function(user) {&#A;        // Example with 1 argument&#A;        $scope.master= angular.copy(user);&#A;      };&#A;&#A;      $scope.reset = function() {&#A;        // Example with 2 arguments&#A;        angular.copy($scope.master, $scope.user);&#A;      };&#A;&#A;      $scope.reset();&#A;    }]);&#A; &lt;/script&gt;&#A; &lt;/file&gt;&#A; &lt;/example&gt;

			Alias: forEach&gt;?(value,key)
			StartLine: 913
			EndLine: 915
			NodeType: AnonymousFunction

			Alias: putValue(key,val,destinat…tackDest)
			StartLine: 942
			EndLine: 950
			NodeType: Function
			Comment: No context allocation, trivial outer scope, easily inlined

		Alias: shallowCopy(src,dst)
		StartLine: 958
		EndLine: 976
		NodeType: Function
		Comment: *&#A; * Creates a shallow copy of an object, an array or a primitive.&#A; *&#A; * Assumes that there are no proto properties for objects.

		Alias: equals(o1,o2)
		StartLine: 1008
		EndLine: 1048
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.equals&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Determines if two objects or two values are equivalent. Supports value types, regular&#A; * expressions, arrays and objects.&#A; *&#A; * Two objects or values are considered equivalent if at least one of the following is true:&#A; *&#A; * * Both objects or values pass `===` comparison.&#A; * * Both objects or values are of the same type and all of their properties are equal by&#A; *   comparing them with `angular.equals`.&#A; * * Both values are NaN. (In JavaScript, NaN == NaN =&gt; false. But we consider two NaN as equal)&#A; * * Both values represent the same regular expression (In JavaScript,&#A; *   /abc/ == /abc/ =&gt; false. But we consider two regular expressions as equal when their textual&#A; *   representation matches).&#A; *&#A; * During a property comparison, properties of `function` type and properties with names&#A; * that begin with `$` are ignored.&#A; *&#A; * Scope and DOMWindow objects are being compared only by identify (`===`).&#A; *&#A; * @param {*} o1 Object or value to compare.&#A; * @param {*} o2 Object or value to compare.&#A; * @returns {boolean} True if arguments are equal.

		Alias: csp()
		StartLine: 1050
		EndLine: 1067
		NodeType: Function

		Alias: jq()
		StartLine: 1107
		EndLine: 1120
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @module ng&#A; * @name ngJq&#A; *&#A; * @element ANY&#A; * @param {string=} ngJq the name of the library available under `window`&#A; * to be used for angular.element&#A; * @description&#A; * Use this directive to force the angular.element library.  This should be&#A; * used to force either jqLite by leaving ng-jq blank or setting the name of&#A; * the jquery variable under window (eg. jQuery).&#A; *&#A; * Since angular looks for this directive when it is loaded (doesn&#39;t wait for the&#A; * DOMContentLoaded event), it must be placed on an element that comes before the script&#A; * which loads angular. Also, only the first instance of `ng-jq` will be used and all&#A; * others ignored.&#A; *&#A; * @example&#A; * This example shows how to force jqLite using the `ngJq` directive to the `html` tag.&#A; ```html&#A; &lt;!doctype html&gt;&#A; &lt;html ng-app ng-jq&gt;&#A; ...&#A; ...&#A; &lt;/html&gt;&#A; ```&#A; * @example&#A; * This example shows how to use a jQuery based library of a different name.&#A; * The library name must be available at the top most &#39;window&#39;.&#A; ```html&#A; &lt;!doctype html&gt;&#A; &lt;html ng-app ng-jq=&quot;jQueryLib&quot;&gt;&#A; ...&#A; ...&#A; &lt;/html&gt;&#A; ```

		Alias: concat(array1,array2,index)
		StartLine: 1122
		EndLine: 1124
		NodeType: Function

		Alias: sliceArgs(args,startIndex)
		StartLine: 1126
		EndLine: 1128
		NodeType: Function

		Alias: bind(self,fn)
		StartLine: 1150
		EndLine: 1168
		NodeType: Function
		Comment: jshint -W101 &#D;&#A;*&#A; * @ngdoc function&#A; * @name angular.bind&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for&#A; * `fn`). You can supply optional `args` that are prebound to the function. This feature is also&#A; * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as&#A; * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).&#A; *&#A; * @param {Object} self Context which `fn` should be evaluated in.&#A; * @param {function()} fn Function to be bound.&#A; * @param {...*} args Optional arguments to be prebound to the `fn` function call.&#A; * @returns {function()} Function that wraps the `fn` with all the specified bindings.&#A; &#D;&#A; jshint +W101

		Alias: toJsonReplacer(key,value)
		StartLine: 1171
		EndLine: 1185
		NodeType: Function

		Alias: toJson(obj,pretty)
		StartLine: 1203
		EndLine: 1209
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.toJson&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be&#A; * stripped since angular uses this notation internally.&#A; *&#A; * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.&#A; * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.&#A; *    If set to an integer, the JSON output will contain that many spaces per indentation.&#A; * @returns {string|undefined} JSON-ified string representing `obj`.

		Alias: fromJson(json)
		StartLine: 1224
		EndLine: 1228
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.fromJson&#A; * @module ng&#A; * @kind function&#A; *&#A; * @description&#A; * Deserializes a JSON string.&#A; *&#A; * @param {string} json JSON string to deserialize.&#A; * @returns {Object|Array|string|number} Deserialized JSON string.

		Alias: timezoneToOffset(timezone,fallback)
		StartLine: 1231
		EndLine: 1234
		NodeType: Function

		Alias: addDateMinutes(date,minutes)
		StartLine: 1237
		EndLine: 1241
		NodeType: Function

		Alias: convertTimezoneToLocal(date,timezone,reverse)
		StartLine: 1244
		EndLine: 1248
		NodeType: Function

		Alias: startingTag(element)
		StartLine: 1254
		EndLine: 1271
		NodeType: Function
		Comment: *&#A; * @returns {string} Returns the string representation of the element.

		Alias: tryDecodeURIComponent(value)
		StartLine: 1284
		EndLine: 1290
		NodeType: Function
		Comment: *&#A; * Tries to decode the URI component without throwing an exception.&#A; *&#A; * @private&#A; * @param str value potential URI component to check.&#A; * @returns {boolean} True if `value` can be decoded&#A; * with the decodeURIComponent function.

		Alias: parseKeyValue(keyValue)
		StartLine: 1297
		EndLine: 1316
		NodeType: Function
		Comment: *&#A; * Parses an escaped url query string into key-value pairs.&#A; * @returns {Object.&lt;string,boolean|Array&gt;}&#A; &#D;&#A;*string

			Alias: forEach&gt;?(keyValue)
			StartLine: 1299
			EndLine: 1314
			NodeType: AnonymousFunction

		Alias: toKeyValue(obj)
		StartLine: 1318
		EndLine: 1332
		NodeType: Function

			Alias: forEach&gt;?(value,key)
			StartLine: 1320
			EndLine: 1330
			NodeType: AnonymousFunction

				Alias: forEach&gt;?(arrayValue)
				StartLine: 1322
				EndLine: 1325
				NodeType: AnonymousFunction

		Alias: encodeUriSegment(val)
		StartLine: 1346
		EndLine: 1351
		NodeType: Function
		Comment: *&#A; * We need our custom method because encodeURIComponent is too aggressive and doesn&#39;t follow&#A; * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path&#A; * segments:&#A; *    segment       = *pchar&#A; *    pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;&#A; *    pct-encoded   = &quot;%&quot; HEXDIG HEXDIG&#A; *    unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;&#A; *    sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#39;&quot; / &quot;(&quot; / &quot;)&quot;&#A; *                     / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;

		Alias: encodeUriQuery(val,pctEncodeSpaces)
		StartLine: 1365
		EndLine: 1373
		NodeType: Function
		Comment: *&#A; * This method is intended for encoding *key* or *value* parts of query component. We need a custom&#A; * method because encodeURIComponent is too aggressive and encodes stuff that doesn&#39;t have to be&#A; * encoded per http://tools.ietf.org/html/rfc3986:&#A; *    query       = *( pchar / &quot;/&quot; / &quot;?&quot; )&#A; *    pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;&#A; *    unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;&#A; *    pct-encoded   = &quot;%&quot; HEXDIG HEXDIG&#A; *    sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#39;&quot; / &quot;(&quot; / &quot;)&quot;&#A; *                     / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;

		Alias: getNgAttribute(element,ngAttr)
		StartLine: 1377
		EndLine: 1386
		NodeType: Function

		Alias: angularInit(element,bootstrap)
		StartLine: 1515
		EndLine: 1542
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @name ngApp&#A; * @module ng&#A; *&#A; * @element ANY&#A; * @param {angular.Module} ngApp an optional application&#A; *   {@link angular.module module} name to load.&#A; * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be&#A; *   created in &quot;strict-di&quot; mode. This means that the application will fail to invoke functions which&#A; *   do not use explicit function annotation (and are thus unsuitable for minification), as described&#A; *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in&#A; *   tracking down the root of these bugs.&#A; *&#A; * @description&#A; *&#A; * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive&#A; * designates the **root element** of the application and is typically placed near the root element&#A; * of the page - e.g. on the `&lt;body&gt;` or `&lt;html&gt;` tags.&#A; *&#A; * Only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`&#A; * found in the document will be used to define the root element to auto-bootstrap as an&#A; * application. To run multiple applications in an HTML document you must manually bootstrap them using&#A; * {@link angular.bootstrap} instead. AngularJS applications cannot be nested within each other.&#A; *&#A; * You can specify an **AngularJS module** to be used as the root module for the application.  This&#A; * module will be loaded into the {@link auto.$injector} when the application is bootstrapped. It&#A; * should contain the application code needed or have dependencies on other modules that will&#A; * contain the code. See {@link angular.module} for more information.&#A; *&#A; * In the example below if the `ngApp` directive were not placed on the `html` element then the&#A; * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`&#A; * would not be resolved to `3`.&#A; *&#A; * `ngApp` is the easiest, and most common way to bootstrap an application.&#A; *&#A; &lt;example module=&quot;ngAppDemo&quot;&gt;&#A;   &lt;file name=&quot;index.html&quot;&gt;&#A;   &lt;div ng-controller=&quot;ngAppDemoController&quot;&gt;&#A;     I can add: {{a}} + {{b}} =  {{ a+b }}&#A;   &lt;/div&gt;&#A;   &lt;/file&gt;&#A;   &lt;file name=&quot;script.js&quot;&gt;&#A;   angular.module(&#39;ngAppDemo&#39;, []).controller(&#39;ngAppDemoController&#39;, function($scope) {&#A;     $scope.a = 1;&#A;     $scope.b = 2;&#A;   });&#A;   &lt;/file&gt;&#A; &lt;/example&gt;&#A; *&#A; * Using `ngStrictDi`, you would see something like this:&#A; *&#A; &lt;example ng-app-included=&quot;true&quot;&gt;&#A;   &lt;file name=&quot;index.html&quot;&gt;&#A;   &lt;div ng-app=&quot;ngAppStrictDemo&quot; ng-strict-di&gt;&#A;       &lt;div ng-controller=&quot;GoodController1&quot;&gt;&#A;           I can add: {{a}} + {{b}} =  {{ a+b }}&#A;&#A;           &lt;p&gt;This renders because the controller does not fail to&#A;              instantiate, by using explicit annotation style (see&#A;              script.js for details)&#A;           &lt;/p&gt;&#A;       &lt;/div&gt;&#A;&#A;       &lt;div ng-controller=&quot;GoodController2&quot;&gt;&#A;           Name: &lt;input ng-model=&quot;name&quot;&gt;&lt;br /&gt;&#A;           Hello, {{name}}!&#A;&#A;           &lt;p&gt;This renders because the controller does not fail to&#A;              instantiate, by using explicit annotation style&#A;              (see script.js for details)&#A;           &lt;/p&gt;&#A;       &lt;/div&gt;&#A;&#A;       &lt;div ng-controller=&quot;BadController&quot;&gt;&#A;           I can add: {{a}} + {{b}} =  {{ a+b }}&#A;&#A;           &lt;p&gt;The controller could not be instantiated, due to relying&#A;              on automatic function annotations (which are disabled in&#A;              strict mode). As such, the content of this section is not&#A;              interpolated, and there should be an error in your web console.&#A;           &lt;/p&gt;&#A;       &lt;/div&gt;&#A;   &lt;/div&gt;&#A;   &lt;/file&gt;&#A;   &lt;file name=&quot;script.js&quot;&gt;&#A;   angular.module(&#39;ngAppStrictDemo&#39;, [])&#A;     // BadController will fail to instantiate, due to relying on automatic function annotation,&#A;     // rather than an explicit annotation&#A;     .controller(&#39;BadController&#39;, function($scope) {&#A;       $scope.a = 1;&#A;       $scope.b = 2;&#A;     })&#A;     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,&#A;     // due to using explicit annotations using the array style and $inject property, respectively.&#A;     .controller(&#39;GoodController1&#39;, [&#39;$scope&#39;, function($scope) {&#A;       $scope.a = 1;&#A;       $scope.b = 2;&#A;     }])&#A;     .controller(&#39;GoodController2&#39;, GoodController2);&#A;     function GoodController2($scope) {&#A;       $scope.name = &quot;World&quot;;&#A;     }&#A;     GoodController2.$inject = [&#39;$scope&#39;];&#A;   &lt;/file&gt;&#A;   &lt;file name=&quot;style.css&quot;&gt;&#A;   div[ng-controller] {&#A;       margin-bottom: 1em;&#A;       -webkit-border-radius: 4px;&#A;       border-radius: 4px;&#A;       border: 1px solid;&#A;       padding: .5em;&#A;   }&#A;   div[ng-controller^=Good] {&#A;       border-color: #d6e9c6;&#A;       background-color: #dff0d8;&#A;       color: #3c763d;&#A;   }&#A;   div[ng-controller^=Bad] {&#A;       border-color: #ebccd1;&#A;       background-color: #f2dede;&#A;       color: #a94442;&#A;       margin-bottom: 0;&#A;   }&#A;   &lt;/file&gt;&#A; &lt;/example&gt;

			Alias: forEach&gt;?(prefix)
			StartLine: 1521
			EndLine: 1528
			NodeType: AnonymousFunction
			Comment: The element `element` has priority over any other element

			Alias: forEach&gt;?(prefix)
			StartLine: 1529
			EndLine: 1537
			NodeType: AnonymousFunction

		Alias: bootstrap(element,modules,config)
		StartLine: 1594
		EndLine: 1660
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.bootstrap&#A; * @module ng&#A; * @description&#A; * Use this function to manually start up angular application.&#A; *&#A; * See: {@link guide/bootstrap Bootstrap}&#A; *&#A; * Note that Protractor based end-to-end tests cannot use this function to bootstrap manually.&#A; * They must use {@link ng.directive:ngApp ngApp}.&#A; *&#A; * Angular will detect if it has been loaded into the browser more than once and only allow the&#A; * first loaded script to be bootstrapped and will report a warning to the browser console for&#A; * each of the subsequent scripts. This prevents strange results in applications, where otherwise&#A; * multiple instances of Angular try to work on the DOM.&#A; *&#A; * ```html&#A; * &lt;!doctype html&gt;&#A; * &lt;html&gt;&#A; * &lt;body&gt;&#A; * &lt;div ng-controller=&quot;WelcomeController&quot;&gt;&#A; *   {{greeting}}&#A; * &lt;/div&gt;&#A; *&#A; * &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&#A; * &lt;script&gt;&#A; *   var app = angular.module(&#39;demo&#39;, [])&#A; *   .controller(&#39;WelcomeController&#39;, function($scope) {&#A; *       $scope.greeting = &#39;Welcome!&#39;;&#A; *   });&#A; *   angular.bootstrap(document, [&#39;demo&#39;]);&#A; * &lt;/script&gt;&#A; * &lt;/body&gt;&#A; * &lt;/html&gt;&#A; * ```&#A; *&#A; * @param {DOMElement} element DOM element which is the root of angular application.&#A; * @param {Array&lt;String|Function|Array&gt;=} modules an array of modules to load into the application.&#A; *     Each item in the array should be the name of a predefined module or a (DI annotated)&#A; *     function that will be invoked by the injector as a `config` block.&#A; *     See: {@link angular.module modules}&#A; * @param {Object=} config an object for defining configuration options for the application. The&#A; *     following keys are supported:&#A; *&#A; * * `strictDi` - disable automatic function annotation for the application. This is meant to&#A; *   assist in finding bugs which break minified code. Defaults to `false`.&#A; *&#A; * @returns {auto.$injector} Returns the newly created injector for this app.

			Alias: defaultConfig
			StartLine: 1596
			EndLine: 1598
			NodeType: Object

			Alias: doBootstrap()
			StartLine: 1600
			EndLine: 1635
			NodeType: Function

				Alias: ?($provide)
				StartLine: 1613
				EndLine: 1615
				NodeType: AnonymousFunction

				Alias: ?($compileProvider)
				StartLine: 1619
				EndLine: 1621
				NodeType: AnonymousFunction
				Comment: Pushing so that this overrides `debugInfoEnabled` setting defined in user&#39;s `modules`.

				Alias: bootstrapApply(scope,element,co…injector)
				StartLine: 1627
				EndLine: 1632
				NodeType: Function

					Alias: $apply&gt;?()
					StartLine: 1628
					EndLine: 1631
					NodeType: AnonymousFunction

			Alias: resumeBootstrap(extraModules)
			StartLine: 1650
			EndLine: 1655
			NodeType: Function

				Alias: forEach&gt;?(module)
				StartLine: 1651
				EndLine: 1653
				NodeType: AnonymousFunction

		Alias: reloadWithDebugInfo()
		StartLine: 1672
		EndLine: 1675
		NodeType: Function
		Comment: *&#A; * @ngdoc function&#A; * @name angular.reloadWithDebugInfo&#A; * @module ng&#A; * @description&#A; * Use this function to reload the current application with debug information turned on.&#A; * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.&#A; *&#A; * See {@link ng.$compileProvider#debugInfoEnabled} for more.

		Alias: getTestability(rootElement)
		StartLine: 1685
		EndLine: 1692
		NodeType: Function
		Comment: *&#A; * @name angular.getTestability&#A; * @module ng&#A; * @description&#A; * Get the testability service for the instance of Angular on the given&#A; * element.&#A; * @param {DOMElement} element DOM element which is the root of angular application.

		Alias: snake_case(name,separator)
		StartLine: 1695
		EndLine: 1700
		NodeType: Function

			Alias: replace&gt;?(letter,pos)
			StartLine: 1697
			EndLine: 1699
			NodeType: AnonymousFunction

		Alias: bindJQuery()
		StartLine: 1704
		EndLine: 1758
		NodeType: Function

			Alias: extend&gt;?
			StartLine: 1724
			EndLine: 1730
			NodeType: Object

			Alias: cleanData(elems)
			StartLine: 1736
			EndLine: 1749
			NodeType: Function

		Alias: assertArg(arg,name,reason)
		StartLine: 1763
		EndLine: 1768
		NodeType: Function
		Comment: *&#A; * throw error if the argument is falsy.

		Alias: assertArgFn(arg,name,acceptA…notation)
		StartLine: 1770
		EndLine: 1778
		NodeType: Function

		Alias: assertNotHasOwnProperty(name,context)
		StartLine: 1785
		EndLine: 1789
		NodeType: Function
		Comment: *&#A; * throw error if the name given is hasOwnProperty&#A; * @param  {String} name    the name to test&#A; * @param  {String} context the context in which the name is used, such as module or directive

		Alias: getter(obj,path,bindFnToScope)
		StartLine: 1799
		EndLine: 1816
		NodeType: Function
		Comment: *&#A; * Return the value accessible from the object by path. Any undefined traversals are ignored&#A; * @param {Object} obj starting object&#A; * @param {String} path path to traverse&#A; * @param {boolean} [bindFnToScope=true]&#A; * @returns {Object} value as accessible by path&#A; &#D;&#A;TODO(misko): this function needs to be removed

		Alias: getBlockNodes(nodes)
		StartLine: 1823
		EndLine: 1837
		NodeType: Function
		Comment: *&#A; * Return the DOM siblings between the first and last node in the given array.&#A; * @param {Array} array like object&#A; * @returns {jqLite} jqLite collection containing the nodes&#A; &#D;&#A; TODO(perf): just check if all items in `nodes` are siblings and if they are return the original&#D;&#A;             collection, otherwise update the original collection.

		Alias: createMap()
		StartLine: 1851
		EndLine: 1853
		NodeType: Function
		Comment: *&#A; * Creates a new object without a prototype. This object is useful for lookup without having to&#A; * guard against prototypically inherited properties via hasOwnProperty.&#A; *&#A; * Related micro-benchmarks:&#A; * - http://jsperf.com/object-create2&#A; * - http://jsperf.com/proto-map-lookup/2&#A; * - http://jsperf.com/for-in-vs-object-keys2&#A; *&#A; * @returns {Object}

		Alias: setupModuleLoader(window)
		StartLine: 1871
		EndLine: 2196
		NodeType: Function

			Alias: ensure(obj,name,factory)
			StartLine: 1876
			EndLine: 1878
			NodeType: Function

			Alias: ensure&gt;?()
			StartLine: 1885
			EndLine: 2194
			NodeType: AnonymousFunction
			Comment: * @type {Object.&lt;string, angular.Module&gt;}

				Alias: module(name,requires,configFn)
				StartLine: 1940
				EndLine: 2193
				NodeType: Function
				Comment: *&#A;     * @ngdoc function&#A;     * @name angular.module&#A;     * @module ng&#A;     * @description&#A;     *&#A;     * The `angular.module` is a global place for creating, registering and retrieving Angular&#A;     * modules.&#A;     * All modules (angular core or 3rd party) that should be available to an application must be&#A;     * registered using this mechanism.&#A;     *&#A;     * When passed two or more arguments, a new module is created.  If passed only one argument, an&#A;     * existing module (the name passed as the first argument to `module`) is retrieved.&#A;     *&#A;     *&#A;     * # Module&#A;     *&#A;     * A module is a collection of services, directives, controllers, filters, and configuration information.&#A;     * `angular.module` is used to configure the {@link auto.$injector $injector}.&#A;     *&#A;     * ```js&#A;     * // Create a new module&#A;     * var myModule = angular.module(&#39;myModule&#39;, []);&#A;     *&#A;     * // register a new service&#A;     * myModule.value(&#39;appName&#39;, &#39;MyCoolApp&#39;);&#A;     *&#A;     * // configure existing services inside initialization blocks.&#A;     * myModule.config([&#39;$locationProvider&#39;, function($locationProvider) {&#A;     *   // Configure existing providers&#A;     *   $locationProvider.hashPrefix(&#39;!&#39;);&#A;     * }]);&#A;     * ```&#A;     *&#A;     * Then you can create an injector and load your modules like this:&#A;     *&#A;     * ```js&#A;     * var injector = angular.injector([&#39;ng&#39;, &#39;myModule&#39;])&#A;     * ```&#A;     *&#A;     * However it&#39;s more likely that you&#39;ll just use&#A;     * {@link ng.directive:ngApp ngApp} or&#A;     * {@link angular.bootstrap} to simplify this process for you.&#A;     *&#A;     * @param {!string} name The name of the module to create or retrieve.&#A;     * @param {!Array.&lt;string&gt;=} requires If specified then new module is being created. If&#A;     *        unspecified then the module is being retrieved for further configuration.&#A;     * @param {Function=} configFn Optional configuration function for the module. Same as&#A;     *        {@link angular.Module#config Module#config()}.&#A;     * @returns {module} new module with the {@link angular.Module} api.

					Alias: assertNotHasOwnProperty(name,context)
					StartLine: 1941
					EndLine: 1945
					NodeType: Function

					Alias: ensure&gt;?()
					StartLine: 1951
					EndLine: 2192
					NodeType: AnonymousFunction

						Alias: moduleInstance
						StartLine: 1970
						EndLine: 2171
						NodeType: Object
						Comment: * @type {angular.Module} &#D;&#A; Private state

							Alias: run(block)
							StartLine: 2167
							EndLine: 2170
							NodeType: Function
							Comment: *&#A;           * @ngdoc method&#A;           * @name angular.Module#run&#A;           * @module ng&#A;           * @param {Function} initializationFn Execute this function after injector creation.&#A;           *    Useful for application initialization.&#A;           * @description&#A;           * Use this method to register work which should be performed when the injector is done&#A;           * loading all modules.

						Alias: invokeLater(provider,method,…od,queue)
						StartLine: 2185
						EndLine: 2191
						NodeType: Function
						Comment: *&#A;         * @param {string} provider&#A;         * @param {string} method&#A;         * @param {String=} insertMethod&#A;         * @returns {angular.Module}

							Alias: ?()
							StartLine: 2187
							EndLine: 2190
							NodeType: AnonymousFunction

		Alias: serializeObject(obj)
		StartLine: 2200
		EndLine: 2213
		NodeType: Function

			Alias: stringify&gt;?(key,val)
			StartLine: 2203
			EndLine: 2212
			NodeType: AnonymousFunction

		Alias: toDebugString(obj)
		StartLine: 2215
		EndLine: 2224
		NodeType: Function

		Alias: version
		StartLine: 2334
		EndLine: 2340
		NodeType: Object
		Comment: *&#A; * @ngdoc object&#A; * @name angular.version&#A; * @module ng&#A; * @description&#A; * An object that contains information about the current AngularJS version. This object has the&#A; * following properties:&#A; *&#A; * - `full` – `{string}` – Full version string, such as &quot;0.9.18&quot;.&#A; * - `major` – `{number}` – Major version number, such as &quot;0&quot;.&#A; * - `minor` – `{number}` – Minor version number, such as &quot;9&quot;.&#A; * - `dot` – `{number}` – Dot version number, such as &quot;18&quot;.&#A; * - `codeName` – `{string}` – Code name of the release, such as &quot;jiggling-armfat&quot;.&#A; &#D;&#A; all of these placeholder strings will be replaced by grunt&#39;s&#D;&#A; package task

		Alias: publishExternalAPI(angular)
		StartLine: 2343
		EndLine: 2481
		NodeType: Function

			Alias: extend&gt;?
			StartLine: 2344
			EndLine: 2375
			NodeType: Object

				Alias: &#39;callbacks&#39;
				StartLine: 2370
				EndLine: 2370
				NodeType: Object

			Alias: ngModule($provide)
			StartLine: 2385
			EndLine: 2479
			NodeType: Function
			Comment: $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.

				Alias: provider&gt;?
				StartLine: 2387
				EndLine: 2389
				NodeType: Object

				Alias: directive&gt;?
				StartLine: 2391
				EndLine: 2436
				NodeType: Object

				Alias: directive&gt;?
				StartLine: 2437
				EndLine: 2439
				NodeType: Object

				Alias: provider&gt;?
				StartLine: 2442
				EndLine: 2478
				NodeType: Object

		Alias: addEventListenerFn(element,type,fn)
		StartLine: 2598
		EndLine: 2600
		NodeType: Function

		Alias: removeEventListenerFn(element,type,fn)
		StartLine: 2601
		EndLine: 2603
		NodeType: Function

		Alias: _data(node)
		StartLine: 2608
		EndLine: 2611
		NodeType: Function
		Comment: * !!! This is an undocumented &quot;private&quot; function !!!&#A; &#D;&#A;jQuery always returns an object on cache miss

		Alias: jqNextId()
		StartLine: 2613
		EndLine: 2613
		NodeType: Function

		Alias: MOUSE_EVENT_MAP
		StartLine: 2618
		EndLine: 2618
		NodeType: Object

		Alias: camelCase(name)
		StartLine: 2626
		EndLine: 2632
		NodeType: Function
		Comment: *&#A; * Converts snake_case to camelCase.&#A; * Also there is special case for Moz prefix starting with upper case letter.&#A; * @param name Name to normalize

			Alias: replace&gt;?(_,separator,letter,offset)
			StartLine: 2628
			EndLine: 2630
			NodeType: AnonymousFunction

		Alias: wrapMap
		StartLine: 2639
		EndLine: 2647
		NodeType: Object

		Alias: jqLiteIsTextNode(html)
		StartLine: 2654
		EndLine: 2656
		NodeType: Function

		Alias: jqLiteAcceptsData(node)
		StartLine: 2658
		EndLine: 2663
		NodeType: Function
		Comment: The window object can accept data but has no nodeType&#D;&#A; Otherwise we are only interested in elements (1) and documents (9)

		Alias: jqLiteBuildFragment(html,context)
		StartLine: 2665
		EndLine: 2700
		NodeType: Function

			Alias: forEach&gt;?(node)
			StartLine: 2695
			EndLine: 2697
			NodeType: AnonymousFunction
			Comment: Clear inner HTML

		Alias: jqLiteParseHTML(html,context)
		StartLine: 2702
		EndLine: 2715
		NodeType: Function

		Alias: JQLite(element)
		StartLine: 2718
		EndLine: 2741
		NodeType: Function
		Comment: ///////////////////////////////////////////

		Alias: jqLiteClone(element)
		StartLine: 2743
		EndLine: 2745
		NodeType: Function

		Alias: jqLiteDealoc(element,onlyDescendants)
		StartLine: 2747
		EndLine: 2756
		NodeType: Function

		Alias: jqLiteOff(element,type,fn,…upported)
		StartLine: 2758
		EndLine: 2788
		NodeType: Function

			Alias: forEach&gt;?(type)
			StartLine: 2775
			EndLine: 2786
			NodeType: AnonymousFunction

		Alias: jqLiteRemoveData(element,name)
		StartLine: 2790
		EndLine: 2809
		NodeType: Function

		Alias: jqLiteExpandoStore(element,createIfNecessary)
		StartLine: 2812
		EndLine: 2822
		NodeType: Function

			Alias: expandoId.expandoStore
			StartLine: 2818
			EndLine: 2818
			NodeType: Object

		Alias: jqLiteData(element,key,value)
		StartLine: 2825
		EndLine: 2849
		NodeType: Function

		Alias: jqLiteHasClass(element,selector)
		StartLine: 2851
		EndLine: 2855
		NodeType: Function

		Alias: jqLiteRemoveClass(element,cssClasses)
		StartLine: 2857
		EndLine: 2867
		NodeType: Function

			Alias: forEach&gt;?(cssClass)
			StartLine: 2859
			EndLine: 2865
			NodeType: AnonymousFunction

		Alias: jqLiteAddClass(element,cssClasses)
		StartLine: 2869
		EndLine: 2883
		NodeType: Function

			Alias: forEach&gt;?(cssClass)
			StartLine: 2874
			EndLine: 2879
			NodeType: AnonymousFunction

		Alias: jqLiteAddNodes(root,elements)
		StartLine: 2886
		EndLine: 2909
		NodeType: Function
		Comment: THIS CODE IS VERY HOT. Don&#39;t make changes without benchmarking.

		Alias: jqLiteController(element,name)
		StartLine: 2912
		EndLine: 2914
		NodeType: Function

		Alias: jqLiteInheritedData(element,name,value)
		StartLine: 2916
		EndLine: 2934
		NodeType: Function
		Comment: if element is the document object work with the html element instead&#D;&#A; this makes $(document).scope() possible

		Alias: jqLiteEmpty(element)
		StartLine: 2936
		EndLine: 2941
		NodeType: Function

		Alias: jqLiteRemove(element,keepData)
		StartLine: 2943
		EndLine: 2947
		NodeType: Function

		Alias: jqLiteDocumentLoaded(action,win)
		StartLine: 2950
		EndLine: 2961
		NodeType: Function

		Alias: prototype.JQLitePrototype
		StartLine: 2966
		EndLine: 3001
		NodeType: Object
		Comment: ////////////////////////////////////////&#D;&#A; Functions which are declared directly.&#D;&#A;////////////////////////////////////////

			Alias: ready(fn)
			StartLine: 2967
			EndLine: 2986
			NodeType: Function

				Alias: trigger()
				StartLine: 2970
				EndLine: 2974
				NodeType: Function

			Alias: toString()
			StartLine: 2987
			EndLine: 2991
			NodeType: Function

				Alias: forEach&gt;?(e)
				StartLine: 2989
				EndLine: 2989
				NodeType: AnonymousFunction

			Alias: eq(index)
			StartLine: 2993
			EndLine: 2995
			NodeType: Function

		Alias: forEach&gt;?(value)
		StartLine: 3009
		EndLine: 3011
		NodeType: AnonymousFunction

		Alias: forEach&gt;?(value)
		StartLine: 3013
		EndLine: 3015
		NodeType: AnonymousFunction

		Alias: ALIASED_ATTR
		StartLine: 3016
		EndLine: 3022
		NodeType: Object

		Alias: getBooleanAttrName(element,name)
		StartLine: 3024
		EndLine: 3030
		NodeType: Function
		Comment: check dom last since we will most likely fail on name

		Alias: getAliasedAttrName(element,name)
		StartLine: 3032
		EndLine: 3035
		NodeType: Function

		Alias: forEach&gt;?
		StartLine: 3037
		EndLine: 3040
		NodeType: Object

		Alias: forEach&gt;?(fn,name)
		StartLine: 3040
		EndLine: 3042
		NodeType: AnonymousFunction

		Alias: forEach&gt;?
		StartLine: 3044
		EndLine: 3158
		NodeType: Object

			Alias: scope(element)
			StartLine: 3048
			EndLine: 3051
			NodeType: Function
			Comment: Can&#39;t use jqLiteData here directly so we stay compatible with jQuery!

			Alias: isolateScope(element)
			StartLine: 3053
			EndLine: 3056
			NodeType: Function
			Comment: Can&#39;t use jqLiteData here directly so we stay compatible with jQuery!

			Alias: injector(element)
			StartLine: 3060
			EndLine: 3062
			NodeType: Function

			Alias: removeAttr(element,name)
			StartLine: 3064
			EndLine: 3066
			NodeType: Function

			Alias: css(element,name,value)
			StartLine: 3070
			EndLine: 3078
			NodeType: Function

			Alias: attr(element,name,value)
			StartLine: 3080
			EndLine: 3110
			NodeType: Function

			Alias: prop(element,name,value)
			StartLine: 3112
			EndLine: 3118
			NodeType: Function

			Alias: text()
			StartLine: 3120
			EndLine: 3131
			NodeType: Function

				Alias: getText(element,value)
				StartLine: 3124
				EndLine: 3130
				NodeType: Function

			Alias: val(element,value)
			StartLine: 3133
			EndLine: 3147
			NodeType: Function

				Alias: forEach&gt;?(option)
				StartLine: 3137
				EndLine: 3141
				NodeType: AnonymousFunction

			Alias: html(element,value)
			StartLine: 3149
			EndLine: 3155
			NodeType: Function

		Alias: forEach&gt;?(fn,name)
		StartLine: 3158
		EndLine: 3207
		NodeType: AnonymousFunction
		Comment: *&#A;   * Properties: writes return selection, reads return first value

			Alias: name(arg1,arg2)
			StartLine: 3162
			EndLine: 3206
			NodeType: Function

		Alias: createEventHandler(element,events)
		StartLine: 3209
		EndLine: 3256
		NodeType: Function

			Alias: eventHandler(event,type)
			StartLine: 3210
			EndLine: 3250
			NodeType: Function
			Comment: jQuery specific api

				Alias: isDefaultPrevented()
				StartLine: 3212
				EndLine: 3214
				NodeType: Function

				Alias: stopImmediatePropagation()
				StartLine: 3223
				EndLine: 3233
				NodeType: Function

				Alias: isImmediatePropagationStopped()
				StartLine: 3236
				EndLine: 3238
				NodeType: Function

		Alias: forEach&gt;?
		StartLine: 3263
		EndLine: 3477
		NodeType: Object
		Comment: ////////////////////////////////////////&#D;&#A; Functions iterating traversal.&#D;&#A; These functions chain results into a single&#D;&#A; selector.&#D;&#A;////////////////////////////////////////

			Alias: jqLiteOn(element,type,fn,…upported)
			StartLine: 3266
			EndLine: 3316
			NodeType: Function

			Alias: one(element,type,fn)
			StartLine: 3320
			EndLine: 3331
			NodeType: Function

				Alias: onFn()
				StartLine: 3326
				EndLine: 3329
				NodeType: Function
				Comment: add the listener twice so that when it is called&#D;&#A;you can remove the original function and still be&#D;&#A;able to call element.off(ev, fn) normally

			Alias: replaceWith(element,replaceNode)
			StartLine: 3333
			EndLine: 3344
			NodeType: Function

				Alias: forEach&gt;?(node)
				StartLine: 3336
				EndLine: 3343
				NodeType: AnonymousFunction

			Alias: children(element)
			StartLine: 3346
			EndLine: 3354
			NodeType: Function

				Alias: forEach&gt;?(element)
				StartLine: 3348
				EndLine: 3352
				NodeType: AnonymousFunction

			Alias: contents(element)
			StartLine: 3356
			EndLine: 3358
			NodeType: Function

			Alias: append(element,node)
			StartLine: 3360
			EndLine: 3370
			NodeType: Function

			Alias: prepend(element,node)
			StartLine: 3372
			EndLine: 3379
			NodeType: Function

				Alias: forEach&gt;?(child)
				StartLine: 3375
				EndLine: 3377
				NodeType: AnonymousFunction

			Alias: wrap(element,wrapNode)
			StartLine: 3381
			EndLine: 3388
			NodeType: Function

			Alias: detach(element)
			StartLine: 3392
			EndLine: 3394
			NodeType: Function

			Alias: after(element,newElement)
			StartLine: 3396
			EndLine: 3405
			NodeType: Function

			Alias: toggleClass(element,selector…ondition)
			StartLine: 3410
			EndLine: 3420
			NodeType: Function

				Alias: forEach&gt;?(className)
				StartLine: 3412
				EndLine: 3418
				NodeType: AnonymousFunction

			Alias: parent(element)
			StartLine: 3422
			EndLine: 3425
			NodeType: Function

			Alias: next(element)
			StartLine: 3427
			EndLine: 3429
			NodeType: Function

			Alias: find(element,selector)
			StartLine: 3431
			EndLine: 3437
			NodeType: Function

			Alias: triggerHandler(element,event,ex…rameters)
			StartLine: 3441
			EndLine: 3476
			NodeType: Function

				Alias: dummyEvent
				StartLine: 3451
				EndLine: 3459
				NodeType: Object
				Comment: Create a dummy event to pass to the handlers

					Alias: preventDefault()
					StartLine: 3452
					EndLine: 3452
					NodeType: Function

					Alias: isDefaultPrevented()
					StartLine: 3453
					EndLine: 3453
					NodeType: Function

					Alias: stopImmediatePropagation()
					StartLine: 3454
					EndLine: 3454
					NodeType: Function

					Alias: isImmediatePropagationStopped()
					StartLine: 3455
					EndLine: 3455
					NodeType: Function

				Alias: forEach&gt;?(fn)
				StartLine: 3470
				EndLine: 3474
				NodeType: AnonymousFunction

		Alias: forEach&gt;?(fn,name)
		StartLine: 3477
		EndLine: 3501
		NodeType: AnonymousFunction
		Comment: *&#A;   * chaining functions

			Alias: name(arg1,arg2,arg3)
			StartLine: 3481
			EndLine: 3496
			NodeType: Function

		Alias: $$jqLiteProvider()
		StartLine: 3505
		EndLine: 3522
		NodeType: Function
		Comment: Provider for private $$jqLite service

			Alias: $$jqLite()
			StartLine: 3506
			EndLine: 3521
			NodeType: Function

				Alias: extend&gt;?
				StartLine: 3507
				EndLine: 3520
				NodeType: Object

					Alias: hasClass(node,classes)
					StartLine: 3508
					EndLine: 3511
					NodeType: Function

					Alias: addClass(node,classes)
					StartLine: 3512
					EndLine: 3515
					NodeType: Function

					Alias: removeClass(node,classes)
					StartLine: 3516
					EndLine: 3519
					NodeType: Function

		Alias: hashKey(obj,nextUidFn)
		StartLine: 3536
		EndLine: 3554
		NodeType: Function
		Comment: *&#A; * Computes a hash of an &#39;obj&#39;.&#A; * Hash of a:&#A; *  string is string&#A; *  number is number as string&#A; *  object is either result of calling $$hashKey function on the object or uniquely generated id,&#A; *         that is also assigned to the $$hashKey property of the object.&#A; *&#A; * @param obj&#A; * @returns {string} hash string such that the same input will have the same hash string.&#A; *         The resulting string key is in &#39;type:hashKey&#39; format.

		Alias: HashMap(array,isolatedUid)
		StartLine: 3559
		EndLine: 3567
		NodeType: Function
		Comment: *&#A; * HashMap which can use objects as keys

			Alias: nextUid()
			StartLine: 3562
			EndLine: 3564
			NodeType: Function

		Alias: prototype
		StartLine: 3568
		EndLine: 3595
		NodeType: Object
		Comment: *&#A;   * Store key value pair&#A;   * @param key key to store can be any type&#A;   * @param value value to store can be any type

			Alias: put(key,value)
			StartLine: 3574
			EndLine: 3576
			NodeType: Function

			Alias: get(key)
			StartLine: 3582
			EndLine: 3584
			NodeType: Function
			Comment: *&#A;   * @param key&#A;   * @returns {Object} the value for the key

			Alias: remove(key)
			StartLine: 3590
			EndLine: 3594
			NodeType: Function
			Comment: *&#A;   * Remove the key/value pair&#A;   * @param key

		Alias: ?()
		StartLine: 3597
		EndLine: 3601
		NodeType: AnonymousFunction

			Alias: ?()
			StartLine: 3598
			EndLine: 3600
			NodeType: AnonymousFunction

		Alias: anonFn(fn)
		StartLine: 3671
		EndLine: 3680
		NodeType: Function
		Comment: For anonymous functions, showing at the very least the function signature can help in&#D;&#A; debugging.

		Alias: annotate(fn,strictDi,name)
		StartLine: 3682
		EndLine: 3717
		NodeType: Function

			Alias: forEach&gt;?(arg)
			StartLine: 3701
			EndLine: 3705
			NodeType: AnonymousFunction

				Alias: replace&gt;?(all,underscore,name)
				StartLine: 3702
				EndLine: 3704
				NodeType: AnonymousFunction

		Alias: createInjector(modulesToLoad,strictDi)
		StartLine: 4217
		EndLine: 4449
		NodeType: Function

			Alias: providerCache
			StartLine: 4223
			EndLine: 4232
			NodeType: Object

				Alias: $provide
				StartLine: 4224
				EndLine: 4231
				NodeType: Object

			Alias: createInternalInjector.$injector.providerInjector&gt;?(serviceName,caller)
			StartLine: 4234
			EndLine: 4239
			NodeType: AnonymousFunction

			Alias: createInternalInjector.$injector.instanceInjector&gt;?(serviceName,caller)
			StartLine: 4242
			EndLine: 4245
			NodeType: AnonymousFunction

			Alias: forEach&gt;?(fn)
			StartLine: 4248
			EndLine: 4248
			NodeType: AnonymousFunction

			Alias: supportObject(delegate)
			StartLine: 4256
			EndLine: 4264
			NodeType: Function

				Alias: ?(key,value)
				StartLine: 4257
				EndLine: 4263
				NodeType: AnonymousFunction

			Alias: provider(name,provider_)
			StartLine: 4266
			EndLine: 4275
			NodeType: Function

			Alias: enforceReturnValue(name,factory)
			StartLine: 4277
			EndLine: 4285
			NodeType: Function

				Alias: enforcedReturnValue()
				StartLine: 4278
				EndLine: 4284
				NodeType: Function

			Alias: factory(name,factoryFn,enforce)
			StartLine: 4287
			EndLine: 4291
			NodeType: Function

				Alias: provider&gt;?
				StartLine: 4288
				EndLine: 4290
				NodeType: Object

			Alias: service(name,constructor)
			StartLine: 4293
			EndLine: 4297
			NodeType: Function

				Alias: ?($injector)
				StartLine: 4294
				EndLine: 4296
				NodeType: AnonymousFunction

			Alias: value(name,val)
			StartLine: 4299
			EndLine: 4299
			NodeType: Function

			Alias: constant(name,value)
			StartLine: 4301
			EndLine: 4305
			NodeType: Function

			Alias: decorator(serviceName,decorFn)
			StartLine: 4307
			EndLine: 4315
			NodeType: Function

				Alias: $get()
				StartLine: 4311
				EndLine: 4314
				NodeType: Function

					Alias: invoke&gt;?
					StartLine: 4313
					EndLine: 4313
					NodeType: Object

			Alias: loadModules(modulesToLoad)
			StartLine: 4320
			EndLine: 4366
			NodeType: Function
			Comment: //////////////////////////////////&#D;&#A; Module Loading&#D;&#A;//////////////////////////////////

				Alias: forEach&gt;?(module)
				StartLine: 4322
				EndLine: 4364
				NodeType: AnonymousFunction

					Alias: runInvokeQueue(queue)
					StartLine: 4326
					EndLine: 4334
					NodeType: Function

			Alias: createInternalInjector(cache,factory)
			StartLine: 4372
			EndLine: 4448
			NodeType: Function

				Alias: getService(serviceName,caller)
				StartLine: 4374
				EndLine: 4395
				NodeType: Function

				Alias: invoke(fn,self,locals,s…viceName)
				StartLine: 4397
				EndLine: 4427
				NodeType: Function

				Alias: instantiate(Type,locals,serviceName)
				StartLine: 4429
				EndLine: 4437
				NodeType: Function
				Comment: Check if Type is annotated and use just the given function at n-1 as parameter&#D;&#A; e.g. someModule.factory(&#39;greeter&#39;, [&#39;$window&#39;, function(renamed$window) {}]);&#D;&#A; Object creation: http://jsperf.com/create-constructor/2

				Alias: ?
				StartLine: 4439
				EndLine: 4447
				NodeType: Object

					Alias: has(name)
					StartLine: 4444
					EndLine: 4446
					NodeType: Function

		Alias: $AnchorScrollProvider()
		StartLine: 4461
		EndLine: 4722
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $anchorScrollProvider&#A; *&#A; * @description&#A; * Use `$anchorScrollProvider` to disable automatic scrolling whenever&#A; * {@link ng.$location#hash $location.hash()} changes.

			Alias: disableAutoScrolling()
			StartLine: 4478
			EndLine: 4480
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $anchorScrollProvider#disableAutoScrolling&#A;   *&#A;   * @description&#A;   * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to&#A;   * {@link ng.$location#hash $location.hash()} and scroll to the element matching the new hash.&lt;br /&gt;&#A;   * Use this method to disable automatic scrolling.&#A;   *&#A;   * If automatic scrolling is disabled, one must explicitly call&#A;   * {@link ng.$anchorScroll $anchorScroll()} in order to scroll to the element related to the&#A;   * current hash.

			Alias: ?($window,$locatio…ootScope)
			StartLine: 4623
			EndLine: 4721
			NodeType: AnonymousFunction
			Comment: *&#A;   * @ngdoc service&#A;   * @name $anchorScroll&#A;   * @kind function&#A;   * @requires $window&#A;   * @requires $location&#A;   * @requires $rootScope&#A;   *&#A;   * @description&#A;   * When called, it scrolls to the element related to the specified `hash` or (if omitted) to the&#A;   * current value of {@link ng.$location#hash $location.hash()}, according to the rules specified&#A;   * in the&#A;   * [HTML5 spec](http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document).&#A;   *&#A;   * It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to&#A;   * match any anchor whenever it changes. This can be disabled by calling&#A;   * {@link ng.$anchorScrollProvider#disableAutoScrolling $anchorScrollProvider.disableAutoScrolling()}.&#A;   *&#A;   * Additionally, you can use its {@link ng.$anchorScroll#yOffset yOffset} property to specify a&#A;   * vertical scroll-offset (either fixed or dynamic).&#A;   *&#A;   * @param {string=} hash The hash specifying the element to scroll to. If omitted, the value of&#A;   *                       {@link ng.$location#hash $location.hash()} will be used.&#A;   *&#A;   * @property {(number|function|jqLite)} yOffset&#A;   * If set, specifies a vertical scroll-offset. This is often useful when there are fixed&#A;   * positioned elements at the top of the page, such as navbars, headers etc.&#A;   *&#A;   * `yOffset` can be specified in various ways:&#A;   * - **number**: A fixed number of pixels to be used as offset.&lt;br /&gt;&lt;br /&gt;&#A;   * - **function**: A getter function called everytime `$anchorScroll()` is executed. Must return&#A;   *   a number representing the offset (in pixels).&lt;br /&gt;&lt;br /&gt;&#A;   * - **jqLite**: A jqLite/jQuery element to be used for specifying the offset. The distance from&#A;   *   the top of the page to the element&#39;s bottom will be used as offset.&lt;br /&gt;&#A;   *   **Note**: The element will be taken into account only as long as its `position` is set to&#A;   *   `fixed`. This option is useful, when dealing with responsive navbars/headers that adjust&#A;   *   their height and/or positioning according to the viewport&#39;s size.&#A;   *&#A;   * &lt;br /&gt;&#A;   * &lt;div class=&quot;alert alert-warning&quot;&gt;&#A;   * In order for `yOffset` to work properly, scrolling should take place on the document&#39;s root and&#A;   * not some child element.&#A;   * &lt;/div&gt;&#A;   *&#A;   * @example&#A;     &lt;example module=&quot;anchorScrollExample&quot;&gt;&#A;       &lt;file name=&quot;index.html&quot;&gt;&#A;         &lt;div id=&quot;scrollArea&quot; ng-controller=&quot;ScrollController&quot;&gt;&#A;           &lt;a ng-click=&quot;gotoBottom()&quot;&gt;Go to bottom&lt;/a&gt;&#A;           &lt;a id=&quot;bottom&quot;&gt;&lt;/a&gt; You&#39;re at the bottom!&#A;         &lt;/div&gt;&#A;       &lt;/file&gt;&#A;       &lt;file name=&quot;script.js&quot;&gt;&#A;         angular.module(&#39;anchorScrollExample&#39;, [])&#A;           .controller(&#39;ScrollController&#39;, [&#39;$scope&#39;, &#39;$location&#39;, &#39;$anchorScroll&#39;,&#A;             function ($scope, $location, $anchorScroll) {&#A;               $scope.gotoBottom = function() {&#A;                 // set the location.hash to the id of&#A;                 // the element you wish to scroll to.&#A;                 $location.hash(&#39;bottom&#39;);&#A;&#A;                 // call $anchorScroll()&#A;                 $anchorScroll();&#A;               };&#A;             }]);&#A;       &lt;/file&gt;&#A;       &lt;file name=&quot;style.css&quot;&gt;&#A;         #scrollArea {&#A;           height: 280px;&#A;           overflow: auto;&#A;         }&#A;&#A;         #bottom {&#A;           display: block;&#A;           margin-top: 2000px;&#A;         }&#A;       &lt;/file&gt;&#A;     &lt;/example&gt;&#A;   *&#A;   * &lt;hr /&gt;&#A;   * The example below illustrates the use of a vertical scroll-offset (specified as a fixed value).&#A;   * See {@link ng.$anchorScroll#yOffset $anchorScroll.yOffset} for more details.&#A;   *&#A;   * @example&#A;     &lt;example module=&quot;anchorScrollOffsetExample&quot;&gt;&#A;       &lt;file name=&quot;index.html&quot;&gt;&#A;         &lt;div class=&quot;fixed-header&quot; ng-controller=&quot;headerCtrl&quot;&gt;&#A;           &lt;a href=&quot;&quot; ng-click=&quot;gotoAnchor(x)&quot; ng-repeat=&quot;x in [1,2,3,4,5]&quot;&gt;&#A;             Go to anchor {{x}}&#A;           &lt;/a&gt;&#A;         &lt;/div&gt;&#A;         &lt;div id=&quot;anchor{{x}}&quot; class=&quot;anchor&quot; ng-repeat=&quot;x in [1,2,3,4,5]&quot;&gt;&#A;           Anchor {{x}} of 5&#A;         &lt;/div&gt;&#A;       &lt;/file&gt;&#A;       &lt;file name=&quot;script.js&quot;&gt;&#A;         angular.module(&#39;anchorScrollOffsetExample&#39;, [])&#A;           .run([&#39;$anchorScroll&#39;, function($anchorScroll) {&#A;             $anchorScroll.yOffset = 50;   // always scroll by 50 extra pixels&#A;           }])&#A;           .controller(&#39;headerCtrl&#39;, [&#39;$anchorScroll&#39;, &#39;$location&#39;, &#39;$scope&#39;,&#A;             function ($anchorScroll, $location, $scope) {&#A;               $scope.gotoAnchor = function(x) {&#A;                 var newHash = &#39;anchor&#39; + x;&#A;                 if ($location.hash() !== newHash) {&#A;                   // set the $location.hash to `newHash` and&#A;                   // $anchorScroll will automatically scroll to it&#A;                   $location.hash(&#39;anchor&#39; + x);&#A;                 } else {&#A;                   // call $anchorScroll() explicitly,&#A;                   // since $location.hash hasn&#39;t changed&#A;                   $anchorScroll();&#A;                 }&#A;               };&#A;             }&#A;           ]);&#A;       &lt;/file&gt;&#A;       &lt;file name=&quot;style.css&quot;&gt;&#A;         body {&#A;           padding-top: 50px;&#A;         }&#A;&#A;         .anchor {&#A;           border: 2px dashed DarkOrchid;&#A;           padding: 10px 10px 200px 10px;&#A;         }&#A;&#A;         .fixed-header {&#A;           background-color: rgba(0, 0, 0, 0.2);&#A;           height: 50px;&#A;           position: fixed;&#A;           top: 0; left: 0; right: 0;&#A;         }&#A;&#A;         .fixed-header &gt; a {&#A;           display: inline-block;&#A;           margin: 5px 15px;&#A;         }&#A;       &lt;/file&gt;&#A;     &lt;/example&gt;

				Alias: getFirstAnchor(list)
				StartLine: 4629
				EndLine: 4638
				NodeType: Function
				Comment: Helper function to get first anchor from a NodeList&#D;&#A; (using `Array#some()` instead of `angular#forEach()` since it&#39;s more performant&#D;&#A;  and working in all supported browsers.)

					Alias: call&gt;?(element)
					StartLine: 4631
					EndLine: 4636
					NodeType: AnonymousFunction

				Alias: getYOffset()
				StartLine: 4640
				EndLine: 4659
				NodeType: Function

				Alias: scrollTo(elem)
				StartLine: 4661
				EndLine: 4687
				NodeType: Function

				Alias: scroll(hash)
				StartLine: 4689
				EndLine: 4704
				NodeType: Function

				Alias: autoScrollWatch()
				StartLine: 4709
				EndLine: 4709
				NodeType: Function

				Alias: autoScrollWatchAction(newVal,oldVal)
				StartLine: 4710
				EndLine: 4717
				NodeType: Function
				Comment: skip the initial scroll if $location.hash is empty

					Alias: jqLiteDocumentLoaded&gt;?()
					StartLine: 4714
					EndLine: 4716
					NodeType: AnonymousFunction

		Alias: mergeClasses(a,b)
		StartLine: 4728
		EndLine: 4735
		NodeType: Function

		Alias: extractElementNode(element)
		StartLine: 4737
		EndLine: 4744
		NodeType: Function

		Alias: splitClasses(classes)
		StartLine: 4746
		EndLine: 4762
		NodeType: Function

			Alias: forEach&gt;?(klass)
			StartLine: 4754
			EndLine: 4760
			NodeType: AnonymousFunction
			Comment: sometimes the split leaves empty string values&#D;&#A; incase extra spaces were applied to the options

		Alias: $$CoreAnimateRunnerProvider()
		StartLine: 4764
		EndLine: 4785
		NodeType: Function

			Alias: ?($q,$$rAF)
			StartLine: 4765
			EndLine: 4784
			NodeType: AnonymousFunction

				Alias: AnimateRunner()
				StartLine: 4766
				EndLine: 4766
				NodeType: Function

				Alias: prototype
				StartLine: 4769
				EndLine: 4782
				NodeType: Object

					Alias: then(pass,fail)
					StartLine: 4775
					EndLine: 4781
					NodeType: Function

						Alias: $q&gt;?(resolve)
						StartLine: 4776
						EndLine: 4780
						NodeType: AnonymousFunction

							Alias: $$rAF&gt;?()
							StartLine: 4777
							EndLine: 4779
							NodeType: AnonymousFunction

		Alias: $$CoreAnimateQueueProvider()
		StartLine: 4789
		EndLine: 4873
		NodeType: Function
		Comment: this is prefixed with Core since it conflicts with&#D;&#A; the animateQueueProvider defined in ngAnimate/animateQueue.js

			Alias: ?($$AnimateRunner,…ootScope)
			StartLine: 4794
			EndLine: 4872
			NodeType: AnonymousFunction

				Alias: ?
				StartLine: 4795
				EndLine: 4814
				NodeType: Object

					Alias: push(element,event,op…peration)
					StartLine: 4801
					EndLine: 4813
					NodeType: Function

				Alias: addRemoveClassesPostDigest(element,add,remove)
				StartLine: 4816
				EndLine: 4871
				NodeType: Function

					Alias: forEach&gt;?(className)
					StartLine: 4826
					EndLine: 4830
					NodeType: AnonymousFunction

					Alias: forEach&gt;?(className)
					StartLine: 4834
					EndLine: 4838
					NodeType: AnonymousFunction

					Alias: $$postDigest&gt;?()
					StartLine: 4843
					EndLine: 4870
					NodeType: AnonymousFunction

						Alias: forEach&gt;?(element)
						StartLine: 4844
						EndLine: 4867
						NodeType: AnonymousFunction

							Alias: forEach&gt;?(status,className)
							StartLine: 4850
							EndLine: 4859
							NodeType: AnonymousFunction

							Alias: forEach&gt;?(elm)
							StartLine: 4861
							EndLine: 4864
							NodeType: AnonymousFunction

		Alias: ?($provide)
		StartLine: 4887
		EndLine: 5294
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc provider&#A; * @name $animateProvider&#A; *&#A; * @description&#A; * Default implementation of $animate that doesn&#39;t perform any animations, instead just&#A; * synchronously performs DOM updates and resolves the returned runner promise.&#A; *&#A; * In order to enable animations the `ngAnimate` module has to be loaded.&#A; *&#A; * To see the functional implementation check out `src/ngAnimate/animate.js`.

			Alias: register(name,factory)
			StartLine: 4931
			EndLine: 4939
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $animateProvider#register&#A;   *&#A;   * @description&#A;   * Registers a new injectable animation factory function. The factory function produces the&#A;   * animation object which contains callback functions for each event that is expected to be&#A;   * animated.&#A;   *&#A;   *   * `eventFn`: `function(element, ... , doneFunction, options)`&#A;   *   The element to animate, the `doneFunction` and the options fed into the animation. Depending&#A;   *   on the type of animation additional arguments will be injected into the animation function. The&#A;   *   list below explains the function signatures for the different animation methods:&#A;   *&#A;   *   - setClass: function(element, addedClasses, removedClasses, doneFunction, options)&#A;   *   - addClass: function(element, addedClasses, doneFunction, options)&#A;   *   - removeClass: function(element, removedClasses, doneFunction, options)&#A;   *   - enter, leave, move: function(element, doneFunction, options)&#A;   *   - animate: function(element, fromStyles, toStyles, doneFunction, options)&#A;   *&#A;   *   Make sure to trigger the `doneFunction` once the animation is fully complete.&#A;   *&#A;   * ```js&#A;   *   return {&#A;   *     //enter, leave, move signature&#A;   *     eventFn : function(element, done, options) {&#A;   *       //code to run the animation&#A;   *       //once complete, then run done()&#A;   *       return function endFunction(wasCancelled) {&#A;   *         //code to cancel the animation&#A;   *       }&#A;   *     }&#A;   *   }&#A;   * ```&#A;   *&#A;   * @param {string} name The name of the animation (this is what the class-based CSS value will be compared to).&#A;   * @param {Function} factory The factory function that will be executed to return the animation&#A;   *                           object.

			Alias: classNameFilter(expression)
			StartLine: 4955
			EndLine: 4967
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $animateProvider#classNameFilter&#A;   *&#A;   * @description&#A;   * Sets and/or returns the CSS class regular expression that is checked when performing&#A;   * an animation. Upon bootstrap the classNameFilter value is not set at all and will&#A;   * therefore enable $animate to attempt to perform an animation on any element that is triggered.&#A;   * When setting the `classNameFilter` value, animations will only be performed on elements&#A;   * that successfully match the filter expression. This in turn can boost performance&#A;   * for low-powered devices as well as applications containing a lot of structural operations.&#A;   * @param {RegExp=} expression The className expression which will be checked against all animations&#A;   * @return {RegExp} The current CSS className expression value. If null then there is no expression value

			Alias: ?($$animateQueue)
			StartLine: 4969
			EndLine: 5293
			NodeType: AnonymousFunction

				Alias: domInsert(element,parentEl…rElement)
				StartLine: 4970
				EndLine: 4981
				NodeType: Function
				Comment: if for some reason the previous element was removed&#D;&#A; from the dom sometime before this code runs then let&#39;s&#D;&#A; just stick to using the parent element as the anchor

				Alias: ?
				StartLine: 5002
				EndLine: 5292
				NodeType: Object
				Comment: *&#A;     * @ngdoc service&#A;     * @name $animate&#A;     * @description The $animate service exposes a series of DOM utility methods that provide support&#A;     * for animation hooks. The default behavior is the application of DOM operations, however,&#A;     * when an animation is detected (and animations are enabled), $animate will do the heavy lifting&#A;     * to ensure that animation runs with the triggered DOM operation.&#A;     *&#A;     * By default $animate doesn&#39;t trigger an animations. This is because the `ngAnimate` module isn&#39;t&#A;     * included and only when it is active then the animation hooks that `$animate` triggers will be&#A;     * functional. Once active then all structural `ng-` directives will trigger animations as they perform&#A;     * their DOM-related operations (enter, leave and move). Other directives such as `ngClass`,&#A;     * `ngShow`, `ngHide` and `ngMessages` also provide support for animations.&#A;     *&#A;     * It is recommended that the`$animate` service is always used when executing DOM-related procedures within directives.&#A;     *&#A;     * To learn more about enabling animation support, click here to visit the&#A;     * {@link ngAnimate ngAnimate module page}.&#A;     &#D;&#A; we don&#39;t call it directly since non-existant arguments may&#D;&#A; be interpreted as null within the sub enabled function

					Alias: cancel(runner)
					StartLine: 5117
					EndLine: 5119
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $animate#cancel&#A;       * @kind function&#A;       * @description Cancels the provided animation.&#A;       *&#A;       * @param {Promise} animationPromise The animation promise that is returned when an animation is started.

					Alias: enter(element,parent,a…,options)
					StartLine: 5139
					EndLine: 5143
					NodeType: Function
					Comment: *&#A;       *&#A;       * @ngdoc method&#A;       * @name $animate#enter&#A;       * @kind function&#A;       * @description Inserts the element into the DOM either after the `after` element (if provided) or&#A;       *   as the first child within the `parent` element and then triggers an animation.&#A;       *   A promise is returned that will be resolved during the next digest once the animation&#A;       *   has completed.&#A;       *&#A;       * @param {DOMElement} element the element which will be inserted into the DOM&#A;       * @param {DOMElement} parent the parent element which will append the element as&#A;       *   a child (so long as the after element is not present)&#A;       * @param {DOMElement=} after the sibling element after which the element will be appended&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

					Alias: move(element,parent,a…,options)
					StartLine: 5163
					EndLine: 5167
					NodeType: Function
					Comment: *&#A;       *&#A;       * @ngdoc method&#A;       * @name $animate#move&#A;       * @kind function&#A;       * @description Inserts (moves) the element into its new position in the DOM either after&#A;       *   the `after` element (if provided) or as the first child within the `parent` element&#A;       *   and then triggers an animation. A promise is returned that will be resolved&#A;       *   during the next digest once the animation has completed.&#A;       *&#A;       * @param {DOMElement} element the element which will be moved into the new DOM position&#A;       * @param {DOMElement} parent the parent element which will append the element as&#A;       *   a child (so long as the after element is not present)&#A;       * @param {DOMElement=} after the sibling element after which the element will be appended&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

					Alias: leave(element,options)
					StartLine: 5182
					EndLine: 5186
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $animate#leave&#A;       * @kind function&#A;       * @description Triggers an animation and then removes the element from the DOM.&#A;       * When the function is called a promise is returned that will be resolved during the next&#A;       * digest once the animation has completed.&#A;       *&#A;       * @param {DOMElement} element the element which will be removed from the DOM&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

						Alias: push&gt;?()
						StartLine: 5183
						EndLine: 5185
						NodeType: AnonymousFunction

					Alias: addClass(element,className,options)
					StartLine: 5206
					EndLine: 5210
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $animate#addClass&#A;       * @kind function&#A;       *&#A;       * @description Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon&#A;       *   execution, the addClass operation will only be handled after the next digest and it will not trigger an&#A;       *   animation if element already contains the CSS class or if the class is removed at a later step.&#A;       *   Note that class-based animations are treated differently compared to structural animations&#A;       *   (like enter, move and leave) since the CSS classes may be added/removed at different points&#A;       *   depending if CSS or JavaScript animations are used.&#A;       *&#A;       * @param {DOMElement} element the element which the CSS classes will be applied to&#A;       * @param {string} className the CSS class(es) that will be added (multiple classes are separated via spaces)&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

					Alias: removeClass(element,className,options)
					StartLine: 5230
					EndLine: 5234
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $animate#removeClass&#A;       * @kind function&#A;       *&#A;       * @description Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon&#A;       *   execution, the removeClass operation will only be handled after the next digest and it will not trigger an&#A;       *   animation if element does not contain the CSS class or if the class is added at a later step.&#A;       *   Note that class-based animations are treated differently compared to structural animations&#A;       *   (like enter, move and leave) since the CSS classes may be added/removed at different points&#A;       *   depending if CSS or JavaScript animations are used.&#A;       *&#A;       * @param {DOMElement} element the element which the CSS classes will be applied to&#A;       * @param {string} className the CSS class(es) that will be removed (multiple classes are separated via spaces)&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

					Alias: setClass(element,add,remo…,options)
					StartLine: 5255
					EndLine: 5260
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $animate#setClass&#A;       * @kind function&#A;       *&#A;       * @description Performs both the addition and removal of a CSS classes on an element and (during the process)&#A;       *    triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and&#A;       *    `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has&#A;       *    passed. Note that class-based animations are treated differently compared to structural animations&#A;       *    (like enter, move and leave) since the CSS classes may be added/removed at different points&#A;       *    depending if CSS or JavaScript animations are used.&#A;       *&#A;       * @param {DOMElement} element the element which the CSS classes will be applied to&#A;       * @param {string} add the CSS class(es) that will be added (multiple classes are separated via spaces)&#A;       * @param {string} remove the CSS class(es) that will be removed (multiple classes are separated via spaces)&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

					Alias: animate(element,from,to,…,options)
					StartLine: 5283
					EndLine: 5291
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $animate#animate&#A;       * @kind function&#A;       *&#A;       * @description Performs an inline animation on the element which applies the provided to and from CSS styles to the element.&#A;       * If any detected CSS transition, keyframe or JavaScript matches the provided className value then the animation will take&#A;       * on the provided styles. For example, if a transition animation is set for the given className then the provided from and&#A;       * to styles will be applied alongside the given transition. If a JavaScript animation is detected then the provided styles&#A;       * will be given in as function paramters into the `animate` method (or as apart of the `options` parameter).&#A;       *&#A;       * @param {DOMElement} element the element which the CSS styles will be applied to&#A;       * @param {object} from the from (starting) CSS styles that will be applied to the element and across the animation.&#A;       * @param {object} to the to (destination) CSS styles that will be applied to the element and across the animation.&#A;       * @param {string=} className an optional CSS class that will be applied to the element for the duration of the animation. If&#A;       *    this value is left as empty then a CSS class of `ng-inline-animate` will be applied to the element.&#A;       *    (Note that if no animation is detected then this value will not be appplied to the element.)&#A;       * @param {object=} options an optional collection of options/styles that will be applied to the element&#A;       *&#A;       * @return {Promise} the animation callback promise

		Alias: $$AsyncCallbackProvider()
		StartLine: 5296
		EndLine: 5304
		NodeType: Function

			Alias: ?($$rAF,$timeout)
			StartLine: 5297
			EndLine: 5303
			NodeType: AnonymousFunction

		Alias: Browser(window,document,…$sniffer)
		StartLine: 5329
		EndLine: 5652
		NodeType: Function
		Comment: *&#A; * ! This is a private undocumented service !&#A; *&#A; * @name $browser&#A; * @requires $log&#A; * @description&#A; * This object has two goals:&#A; *&#A; * - hide all the global state in the browser caused by the window object&#A; * - abstract away all the browser specific features and inconsistencies&#A; *&#A; * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`&#A; * service, which can be used for convenient testing of the application without the interaction with&#A; * the real browser apis.&#A; &#D;&#A;*&#A; * @param {object} window The global window object.&#A; * @param {object} document jQuery wrapped document.&#A; * @param {object} $log window.console or an object with the same interface.&#A; * @param {object} $sniffer $sniffer service

			Alias: $$incOutstandingRequestCount()
			StartLine: 5345
			EndLine: 5345
			NodeType: Function

			Alias: completeOutstandingRequest(fn)
			StartLine: 5351
			EndLine: 5366
			NodeType: Function
			Comment: *&#A;   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`&#A;   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.

			Alias: getHash(url)
			StartLine: 5368
			EndLine: 5371
			NodeType: Function

			Alias: notifyWhenNoOutstandingRequests(callback)
			StartLine: 5379
			EndLine: 5385
			NodeType: Function
			Comment: *&#A;   * @private&#A;   * Note: this method is used only by scenario runner&#A;   * TODO(vojta): prefix this method with $$ ?&#A;   * @param {function()} callback Function that will be called when no outstanding request

			Alias: url(url,replace,state)
			StartLine: 5419
			EndLine: 5473
			NodeType: Function
			Comment: *&#A;   * @name $browser#url&#A;   *&#A;   * @description&#A;   * GETTER:&#A;   * Without any argument, this method just returns current value of location.href.&#A;   *&#A;   * SETTER:&#A;   * With at least one argument, this method sets url to new value.&#A;   * If html5 history api supported, pushState/replaceState is used, otherwise&#A;   * location.href/location.replace is used.&#A;   * Returns its own instance to allow chaining&#A;   *&#A;   * NOTE: this api is intended for use only by the $location service. Please use the&#A;   * {@link ng.$location $location service} to change url.&#A;   *&#A;   * @param {string} url New url (when used as setter)&#A;   * @param {boolean=} replace Should new url replace current history record?&#A;   * @param {object=} state object to use with pushState/replaceState&#A;   &#D;&#A; In modern browsers `history.state` is `null` by default; treating it separately&#D;&#A; from `undefined` would cause `$browser.url(&#39;/foo&#39;)` to change `history.state`&#D;&#A; to undefined via `pushState`. Instead, let&#39;s change `undefined` to `null` here.

			Alias: state()
			StartLine: 5485
			EndLine: 5487
			NodeType: Function
			Comment: *&#A;   * @name $browser#state&#A;   *&#A;   * @description&#A;   * This method is a getter.&#A;   *&#A;   * Return history.state or null if history.state is undefined.&#A;   *&#A;   * @returns {object} state

			Alias: cacheStateAndFireUrlChange()
			StartLine: 5492
			EndLine: 5495
			NodeType: Function

			Alias: getCurrentState()
			StartLine: 5497
			EndLine: 5503
			NodeType: Function

			Alias: cacheState()
			StartLine: 5507
			EndLine: 5517
			NodeType: Function
			Comment: This should be the only place in $browser where `history.state` is read.

			Alias: fireUrlChange()
			StartLine: 5519
			EndLine: 5529
			NodeType: Function

				Alias: forEach&gt;?(listener)
				StartLine: 5526
				EndLine: 5528
				NodeType: AnonymousFunction

			Alias: onUrlChange(callback)
			StartLine: 5552
			EndLine: 5569
			NodeType: Function
			Comment: *&#A;   * @name $browser#onUrlChange&#A;   *&#A;   * @description&#A;   * Register callback function that will be called, when url changes.&#A;   *&#A;   * It&#39;s only called when the url is changed from outside of angular:&#A;   * - user types different url into address bar&#A;   * - user clicks on history (forward/back) button&#A;   * - user clicks on a link&#A;   *&#A;   * It&#39;s not called when url is changed by $browser.url() method&#A;   *&#A;   * The listener gets called with new url as parameter.&#A;   *&#A;   * NOTE: this api is intended for use only by the $location service. Please use the&#A;   * {@link ng.$location $location service} to monitor url changes in angular apps.&#A;   *&#A;   * @param {function(string)} listener Listener function to be called when url changes.&#A;   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.&#A;   &#D;&#A; TODO(vojta): refactor to use node&#39;s syntax for events

			Alias: $$applicationDestroyed()
			StartLine: 5577
			EndLine: 5579
			NodeType: Function
			Comment: *&#A;   * @private&#A;   * Remove popstate and hashchange handler from window.&#A;   *&#A;   * NOTE: this api is intended for use only by $rootScope.

			Alias: baseHref()
			StartLine: 5601
			EndLine: 5604
			NodeType: Function
			Comment: *&#A;   * @name $browser#baseHref&#A;   *&#A;   * @description&#A;   * Returns current &lt;base href&gt;&#A;   * (always relative - without domain)&#A;   *&#A;   * @returns {string} The current base href

			Alias: defer(fn,delay)
			StartLine: 5620
			EndLine: 5629
			NodeType: Function
			Comment: *&#A;   * @name $browser#defer&#A;   * @param {function()} fn A function, who&#39;s execution should be deferred.&#A;   * @param {number=} [delay=0] of milliseconds to defer the function execution.&#A;   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.&#A;   *&#A;   * @description&#A;   * Executes a fn asynchronously via `setTimeout(fn, delay)`.&#A;   *&#A;   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using&#A;   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed&#A;   * via `$browser.defer.flush()`.&#A;   *

				Alias: setTimeout.timeoutId&gt;?()
				StartLine: 5623
				EndLine: 5626
				NodeType: AnonymousFunction

			Alias: cancel(deferId)
			StartLine: 5642
			EndLine: 5650
			NodeType: Function
			Comment: *&#A;   * @name $browser#defer.cancel&#A;   *&#A;   * @description&#A;   * Cancels a deferred task identified with `deferId`.&#A;   *&#A;   * @param {*} deferId Token returned by the `$browser.defer` function.&#A;   * @returns {boolean} Returns `true` if the task hasn&#39;t executed yet and was successfully&#A;   *                    canceled.

		Alias: $BrowserProvider()
		StartLine: 5654
		EndLine: 5659
		NodeType: Function

			Alias: ?($window,$log,$sn…document)
			StartLine: 5656
			EndLine: 5658
			NodeType: AnonymousFunction

		Alias: $CacheFactoryProvider()
		StartLine: 5742
		EndLine: 6010
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $cacheFactory&#A; *&#A; * @description&#A; * Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to&#A; * them.&#A; *&#A; * ```js&#A; *&#A; *  var cache = $cacheFactory(&#39;cacheId&#39;);&#A; *  expect($cacheFactory.get(&#39;cacheId&#39;)).toBe(cache);&#A; *  expect($cacheFactory.get(&#39;noSuchCacheId&#39;)).not.toBeDefined();&#A; *&#A; *  cache.put(&quot;key&quot;, &quot;value&quot;);&#A; *  cache.put(&quot;another key&quot;, &quot;another value&quot;);&#A; *&#A; *  // We&#39;ve specified no options on creation&#A; *  expect(cache.info()).toEqual({id: &#39;cacheId&#39;, size: 2});&#A; *&#A; * ```&#A; *&#A; *&#A; * @param {string} cacheId Name or id of the newly created cache.&#A; * @param {object=} options Options object that specifies the cache behavior. Properties:&#A; *&#A; *   - `{number=}` `capacity` — turns the cache into LRU cache.&#A; *&#A; * @returns {object} Newly created cache object with the following set of methods:&#A; *&#A; * - `{object}` `info()` — Returns id, size, and options of cache.&#A; * - `{{*}}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache and returns&#A; *   it.&#A; * - `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.&#A; * - `{void}` `remove({string} key)` — Removes a key-value pair from the cache.&#A; * - `{void}` `removeAll()` — Removes all cached values.&#A; * - `{void}` `destroy()` — Removes references to this cache from $cacheFactory.&#A; *&#A; * @example&#A;   &lt;example module=&quot;cacheExampleApp&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;div ng-controller=&quot;CacheController&quot;&gt;&#A;         &lt;input ng-model=&quot;newCacheKey&quot; placeholder=&quot;Key&quot;&gt;&#A;         &lt;input ng-model=&quot;newCacheValue&quot; placeholder=&quot;Value&quot;&gt;&#A;         &lt;button ng-click=&quot;put(newCacheKey, newCacheValue)&quot;&gt;Cache&lt;/button&gt;&#A;&#A;         &lt;p ng-if=&quot;keys.length&quot;&gt;Cached Values&lt;/p&gt;&#A;         &lt;div ng-repeat=&quot;key in keys&quot;&gt;&#A;           &lt;span ng-bind=&quot;key&quot;&gt;&lt;/span&gt;&#A;           &lt;span&gt;: &lt;/span&gt;&#A;           &lt;b ng-bind=&quot;cache.get(key)&quot;&gt;&lt;/b&gt;&#A;         &lt;/div&gt;&#A;&#A;         &lt;p&gt;Cache Info&lt;/p&gt;&#A;         &lt;div ng-repeat=&quot;(key, value) in cache.info()&quot;&gt;&#A;           &lt;span ng-bind=&quot;key&quot;&gt;&lt;/span&gt;&#A;           &lt;span&gt;: &lt;/span&gt;&#A;           &lt;b ng-bind=&quot;value&quot;&gt;&lt;/b&gt;&#A;         &lt;/div&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;script.js&quot;&gt;&#A;       angular.module(&#39;cacheExampleApp&#39;, []).&#A;         controller(&#39;CacheController&#39;, [&#39;$scope&#39;, &#39;$cacheFactory&#39;, function($scope, $cacheFactory) {&#A;           $scope.keys = [];&#A;           $scope.cache = $cacheFactory(&#39;cacheId&#39;);&#A;           $scope.put = function(key, value) {&#A;             if ($scope.cache.get(key) === undefined) {&#A;               $scope.keys.push(key);&#A;             }&#A;             $scope.cache.put(key, value === undefined ? null : value);&#A;           };&#A;         }]);&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;style.css&quot;&gt;&#A;       p {&#A;         margin: 10px 0 3px;&#A;       }&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: $get()
			StartLine: 5744
			EndLine: 6009
			NodeType: Function

				Alias: cacheFactory(cacheId,options)
				StartLine: 5747
				EndLine: 5972
				NodeType: Function

					Alias: extend.stats&gt;?
					StartLine: 5753
					EndLine: 5753
					NodeType: Object

					Alias: cacheId
					StartLine: 5799
					EndLine: 5941
					NodeType: Object
					Comment: *&#A;       * @ngdoc type&#A;       * @name $cacheFactory.Cache&#A;       *&#A;       * @description&#A;       * A cache object used to store and retrieve data, primarily used by&#A;       * {@link $http $http} and the {@link ng.directive:script script} directive to cache&#A;       * templates and other data.&#A;       *&#A;       * ```js&#A;       *  angular.module(&#39;superCache&#39;)&#A;       *    .factory(&#39;superCache&#39;, [&#39;$cacheFactory&#39;, function($cacheFactory) {&#A;       *      return $cacheFactory(&#39;super-cache&#39;);&#A;       *    }]);&#A;       * ```&#A;       *&#A;       * Example test:&#A;       *&#A;       * ```js&#A;       *  it(&#39;should behave like a cache&#39;, inject(function(superCache) {&#A;       *    superCache.put(&#39;key&#39;, &#39;value&#39;);&#A;       *    superCache.put(&#39;another key&#39;, &#39;another value&#39;);&#A;       *&#A;       *    expect(superCache.info()).toEqual({&#A;       *      id: &#39;super-cache&#39;,&#A;       *      size: 2&#A;       *    });&#A;       *&#A;       *    superCache.remove(&#39;another key&#39;);&#A;       *    expect(superCache.get(&#39;another key&#39;)).toBeUndefined();&#A;       *&#A;       *    superCache.removeAll();&#A;       *    expect(superCache.info()).toEqual({&#A;       *      id: &#39;super-cache&#39;,&#A;       *      size: 0&#A;       *    });&#A;       *  }));&#A;       * ```

						Alias: put(key,value)
						StartLine: 5819
						EndLine: 5835
						NodeType: Function
						Comment: *&#A;         * @ngdoc method&#A;         * @name $cacheFactory.Cache#put&#A;         * @kind function&#A;         *&#A;         * @description&#A;         * Inserts a named entry into the {@link $cacheFactory.Cache Cache} object to be&#A;         * retrieved later, and incrementing the size of the cache if the key was not already&#A;         * present in the cache. If behaving like an LRU cache, it will also remove stale&#A;         * entries from the set.&#A;         *&#A;         * It will not insert undefined values into the cache.&#A;         *&#A;         * @param {string} key the key under which the cached data is stored.&#A;         * @param {*} value the value to store alongside the key. If it is undefined, the key&#A;         *    will not be stored.&#A;         * @returns {*} the value stored.

							Alias: key.lruEntry
							StartLine: 5822
							EndLine: 5822
							NodeType: Object

						Alias: get(key)
						StartLine: 5848
						EndLine: 5858
						NodeType: Function
						Comment: *&#A;         * @ngdoc method&#A;         * @name $cacheFactory.Cache#get&#A;         * @kind function&#A;         *&#A;         * @description&#A;         * Retrieves named data stored in the {@link $cacheFactory.Cache Cache} object.&#A;         *&#A;         * @param {string} key the key of the data to be retrieved&#A;         * @returns {*} the value stored.

						Alias: remove(key)
						StartLine: 5871
						EndLine: 5886
						NodeType: Function
						Comment: *&#A;         * @ngdoc method&#A;         * @name $cacheFactory.Cache#remove&#A;         * @kind function&#A;         *&#A;         * @description&#A;         * Removes an entry from the {@link $cacheFactory.Cache Cache} object.&#A;         *&#A;         * @param {string} key the key of the entry to be removed

						Alias: removeAll()
						StartLine: 5897
						EndLine: 5902
						NodeType: Function
						Comment: *&#A;         * @ngdoc method&#A;         * @name $cacheFactory.Cache#removeAll&#A;         * @kind function&#A;         *&#A;         * @description&#A;         * Clears the cache object of any entries.

						Alias: destroy()
						StartLine: 5914
						EndLine: 5919
						NodeType: Function
						Comment: *&#A;         * @ngdoc method&#A;         * @name $cacheFactory.Cache#destroy&#A;         * @kind function&#A;         *&#A;         * @description&#A;         * Destroys the {@link $cacheFactory.Cache Cache} object entirely,&#A;         * removing it from the {@link $cacheFactory $cacheFactory} set.

						Alias: info()
						StartLine: 5938
						EndLine: 5940
						NodeType: Function
						Comment: *&#A;         * @ngdoc method&#A;         * @name $cacheFactory.Cache#info&#A;         * @kind function&#A;         *&#A;         * @description&#A;         * Retrieve information regarding a particular {@link $cacheFactory.Cache Cache}.&#A;         *&#A;         * @returns {object} an object with the following properties:&#A;         *   &lt;ul&gt;&#A;         *     &lt;li&gt;**id**: the id of the cache instance&lt;/li&gt;&#A;         *     &lt;li&gt;**size**: the number of entries kept in the cache instance&lt;/li&gt;&#A;         *     &lt;li&gt;**...**: any additional properties from the options object when creating the&#A;         *       cache.&lt;/li&gt;&#A;         *   &lt;/ul&gt;

							Alias: extend&gt;?
							StartLine: 5939
							EndLine: 5939
							NodeType: Object

					Alias: refresh(entry)
					StartLine: 5947
					EndLine: 5960
					NodeType: Function
					Comment: *&#A;       * makes the `entry` the freshEnd of the LRU linked list

					Alias: link(nextEntry,prevEntry)
					StartLine: 5966
					EndLine: 5971
					NodeType: Function
					Comment: *&#A;       * bidirectionally links two entries of the LRU linked list

				Alias: info()
				StartLine: 5984
				EndLine: 5990
				NodeType: Function
				Comment: *&#A;   * @ngdoc method&#A;   * @name $cacheFactory#info&#A;   *&#A;   * @description&#A;   * Get information about all the caches that have been created&#A;   *&#A;   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`

					Alias: forEach&gt;?(cache,cacheId)
					StartLine: 5986
					EndLine: 5988
					NodeType: AnonymousFunction

				Alias: get(cacheId)
				StartLine: 6003
				EndLine: 6005
				NodeType: Function
				Comment: *&#A;   * @ngdoc method&#A;   * @name $cacheFactory#get&#A;   *&#A;   * @description&#A;   * Get access to a cache object by the `cacheId` used when it was created.&#A;   *&#A;   * @param {string} cacheId Name or id of a cache to access.&#A;   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.

		Alias: $TemplateCacheProvider()
		StartLine: 6055
		EndLine: 6059
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $templateCache&#A; *&#A; * @description&#A; * The first time a template is used, it is loaded in the template cache for quick retrieval. You&#A; * can load templates directly into the cache in a `script` tag, or by consuming the&#A; * `$templateCache` service directly.&#A; *&#A; * Adding via the `script` tag:&#A; *&#A; * ```html&#A; *   &lt;script type=&quot;text/ng-template&quot; id=&quot;templateId.html&quot;&gt;&#A; *     &lt;p&gt;This is the content of the template&lt;/p&gt;&#A; *   &lt;/script&gt;&#A; * ```&#A; *&#A; * **Note:** the `script` tag containing the template does not need to be included in the `head` of&#A; * the document, but it must be a descendent of the {@link ng.$rootElement $rootElement} (IE,&#A; * element with ng-app attribute), otherwise the template will be ignored.&#A; *&#A; * Adding via the `$templateCache` service:&#A; *&#A; * ```js&#A; * var myApp = angular.module(&#39;myApp&#39;, []);&#A; * myApp.run(function($templateCache) {&#A; *   $templateCache.put(&#39;templateId.html&#39;, &#39;This is the content of the template&#39;);&#A; * });&#A; * ```&#A; *&#A; * To retrieve the template later, simply use it in your HTML:&#A; * ```html&#A; * &lt;div ng-include=&quot; &#39;templateId.html&#39; &quot;&gt;&lt;/div&gt;&#A; * ```&#A; *&#A; * or get it via Javascript:&#A; * ```js&#A; * $templateCache.get(&#39;templateId.html&#39;)&#A; * ```&#A; *&#A; * See {@link ng.$cacheFactory $cacheFactory}.&#A; *

			Alias: ?($cacheFactory)
			StartLine: 6056
			EndLine: 6058
			NodeType: AnonymousFunction

		Alias: $CompileProvider($provide,$$sanit…Provider)
		StartLine: 6780
		EndLine: 8689
		NodeType: Function

			Alias: parseIsolateBindings(scope,directiveN…ntroller)
			StartLine: 6793
			EndLine: 6819
			NodeType: Function

				Alias: forEach&gt;?(definition,scopeName)
				StartLine: 6798
				EndLine: 6816
				NodeType: AnonymousFunction

					Alias: scopeName
					StartLine: 6810
					EndLine: 6815
					NodeType: Object

			Alias: parseDirectiveBindings(directive,directiveName)
			StartLine: 6821
			EndLine: 6856
			NodeType: Function

				Alias: bindings
				StartLine: 6822
				EndLine: 6825
				NodeType: Object

			Alias: assertValidDirectiveName(name)
			StartLine: 6858
			EndLine: 6868
			NodeType: Function

			Alias: registerDirective(name,directiveFactory)
			StartLine: 6885
			EndLine: 6926
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $compileProvider#directive&#A;   * @kind function&#A;   *&#A;   * @description&#A;   * Register a new directive with the compiler.&#A;   *&#A;   * @param {string|Object} name Name of the directive in camel-case (i.e. &lt;code&gt;ngBind&lt;/code&gt; which&#A;   *    will match as &lt;code&gt;ng-bind&lt;/code&gt;), or an object map of directives where the keys are the&#A;   *    names and the values are the factories.&#A;   * @param {Function|Array} directiveFactory An injectable directive factory function. See&#A;   *    {@link guide/directive} for more info.&#A;   * @returns {ng.$compileProvider} Self for chaining.

				Alias: ?($injector,$excep…nHandler)
				StartLine: 6893
				EndLine: 6919
				NodeType: AnonymousFunction

					Alias: forEach&gt;?(directiveFactory,index)
					StartLine: 6895
					EndLine: 6917
					NodeType: AnonymousFunction

						Alias: directive
						StartLine: 6899
						EndLine: 6899
						NodeType: Object

			Alias: aHrefSanitizationWhitelist(regexp)
			StartLine: 6949
			EndLine: 6956
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $compileProvider#aHrefSanitizationWhitelist&#A;   * @kind function&#A;   *&#A;   * @description&#A;   * Retrieves or overrides the default regular expression that is used for whitelisting of safe&#A;   * urls during a[href] sanitization.&#A;   *&#A;   * The sanitization is a security measure aimed at preventing XSS attacks via html links.&#A;   *&#A;   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into&#A;   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`&#A;   * regular expression. If a match is found, the original url is written into the dom. Otherwise,&#A;   * the absolute url is prefixed with `&#39;unsafe:&#39;` string and only then is it written into the DOM.&#A;   *&#A;   * @param {RegExp=} regexp New regexp to whitelist urls with.&#A;   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for&#A;   *    chaining otherwise.

			Alias: imgSrcSanitizationWhitelist(regexp)
			StartLine: 6979
			EndLine: 6986
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $compileProvider#imgSrcSanitizationWhitelist&#A;   * @kind function&#A;   *&#A;   * @description&#A;   * Retrieves or overrides the default regular expression that is used for whitelisting of safe&#A;   * urls during img[src] sanitization.&#A;   *&#A;   * The sanitization is a security measure aimed at prevent XSS attacks via html links.&#A;   *&#A;   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into&#A;   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`&#A;   * regular expression. If a match is found, the original url is written into the dom. Otherwise,&#A;   * the absolute url is prefixed with `&#39;unsafe:&#39;` string and only then is it written into the DOM.&#A;   *&#A;   * @param {RegExp=} regexp New regexp to whitelist urls with.&#A;   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for&#A;   *    chaining otherwise.

			Alias: debugInfoEnabled(enabled)
			StartLine: 7011
			EndLine: 7017
			NodeType: Function

			Alias: ?($injector,$inter…itizeUri)
			StartLine: 7022
			EndLine: 8688
			NodeType: AnonymousFunction

				Alias: Attributes(element,attributesToCopy)
				StartLine: 7025
				EndLine: 7039
				NodeType: Function

				Alias: prototype
				StartLine: 7041
				EndLine: 7255
				NodeType: Object
				Comment: *&#A;       * @ngdoc method&#A;       * @name $compile.directive.Attributes#$normalize&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or&#A;       * `data-`) to its normalized, camelCase form.&#A;       *&#A;       * Also there is special case for Moz prefix starting with upper case letter.&#A;       *&#A;       * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}&#A;       *&#A;       * @param {string} name Name to normalize

					Alias: $addClass(classVal)
					StartLine: 7071
					EndLine: 7075
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $compile.directive.Attributes#$addClass&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Adds the CSS class value specified by the classVal parameter to the element. If animations&#A;       * are enabled then an animation will be triggered for the class addition.&#A;       *&#A;       * @param {string} classVal The className value that will be added to the element

					Alias: $removeClass(classVal)
					StartLine: 7088
					EndLine: 7092
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $compile.directive.Attributes#$removeClass&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Removes the CSS class value specified by the classVal parameter from the element. If&#A;       * animations are enabled then an animation will be triggered for the class removal.&#A;       *&#A;       * @param {string} classVal The className value that will be removed from the element

					Alias: $updateClass(newClasses,oldClasses)
					StartLine: 7106
					EndLine: 7116
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $compile.directive.Attributes#$updateClass&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Adds and removes the appropriate CSS class values to the element based on the difference&#A;       * between the new and old CSS class values (specified as newClasses and oldClasses).&#A;       *&#A;       * @param {string} newClasses The current CSS className value&#A;       * @param {string} oldClasses The former CSS className value

					Alias: $set(key,value,writeA…attrName)
					StartLine: 7127
					EndLine: 7217
					NodeType: Function
					Comment: *&#A;       * Set a normalized attribute on the element in a way such that all directives&#A;       * can share the attribute. This function properly handles boolean attributes.&#A;       * @param {string} key Normalized key. (ie ngAttribute)&#A;       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.&#A;       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.&#A;       *     Defaults to true.&#A;       * @param {string=} attrName Optional none normalized name. Defaults to key.&#A;       &#D;&#A; TODO: decide whether or not to throw an error if &quot;class&quot;&#D;&#A;is set through this function since it may cause $updateClass to&#D;&#A;become unstable.

						Alias: forEach&gt;?(fn)
						StartLine: 7210
						EndLine: 7216
						NodeType: AnonymousFunction

					Alias: $observe(key,fn)
					StartLine: 7238
					EndLine: 7254
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $compile.directive.Attributes#$observe&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Observes an interpolated attribute.&#A;       *&#A;       * The observer function will be invoked once during the next `$digest` following&#A;       * compilation. The observer is then invoked whenever the interpolated value&#A;       * changes.&#A;       *&#A;       * @param {string} key Normalized key. (ie ngAttribute) .&#A;       * @param {function(interpolatedValue)} fn Function that will be called whenever&#A;                the interpolated value of the attribute changes.&#A;       *        See the {@link guide/directive#text-and-attribute-bindings Directives} guide for more info.&#A;       * @returns {function()} Returns a deregistration function for this observer.

						Alias: $evalAsync&gt;?()
						StartLine: 7244
						EndLine: 7249
						NodeType: AnonymousFunction

						Alias: ?()
						StartLine: 7251
						EndLine: 7253
						NodeType: AnonymousFunction

				Alias: safeAddClass($element,className)
				StartLine: 7258
				EndLine: 7265
				NodeType: Function

				Alias: compile($compileNodes,tr…eContext)
				StartLine: 7306
				EndLine: 7374
				NodeType: Function

					Alias: forEach&gt;?(node,index)
					StartLine: 7315
					EndLine: 7319
					NodeType: AnonymousFunction
					Comment: We can not compile top level text elements since text nodes can be merged and we will&#D;&#A; not be able to attach scope data to them, so we will wrap them in &lt;span&gt;&#D;&#A; non-empty

					Alias: publicLinkFn(scope,cloneConne…,options)
					StartLine: 7325
					EndLine: 7373
					NodeType: Function

				Alias: detectNamespaceForChildElements(parentElement)
				StartLine: 7376
				EndLine: 7384
				NodeType: Function
				Comment: TODO: Make this detect MathML as well...

				Alias: compileNodes(nodeList,transcl…eContext)
				StartLine: 7401
				EndLine: 7505
				NodeType: Function
				Comment: *&#A;     * Compile function matches each node in nodeList against the directives. Once all directives&#A;     * for a particular node are collected their compile functions are executed. The compile&#A;     * functions return values - the linking functions - are combined into a composite linking&#A;     * function, which is the a linking function for the node.&#A;     *&#A;     * @param {NodeList} nodeList an array of nodes or NodeList to compile&#A;     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the&#A;     *        scope argument is auto-generated to the new child of the transcluded parent scope.&#A;     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then&#A;     *        the rootElement must be set the jqLite collection of the compile root. This is&#A;     *        needed so that the jqLite collection items can be replaced with widgets.&#A;     * @param {number=} maxPriority Max directive priority.&#A;     * @returns {Function} A composite linking function of all of the matched directives or null.

					Alias: compositeLinkFn(scope,nodeList,$…scludeFn)
					StartLine: 7444
					EndLine: 7504
					NodeType: Function

				Alias: createBoundTranscludeFn(scope,transclude…sclusion)
				StartLine: 7507
				EndLine: 7524
				NodeType: Function

					Alias: boundTranscludeFn(transcludedScope…ingScope)
					StartLine: 7509
					EndLine: 7521
					NodeType: Function

						Alias: transcludeFn&gt;?
						StartLine: 7516
						EndLine: 7520
						NodeType: Object

				Alias: collectDirectives(node,directives,…irective)
				StartLine: 7536
				EndLine: 7627
				NodeType: Function
				Comment: *&#A;     * Looks for directives on the given node and adds them to the directive collection which is&#A;     * sorted.&#A;     *&#A;     * @param node Node to search.&#A;     * @param directives An array to which the directives are added to. This array is sorted before&#A;     *        the function returns.&#A;     * @param attrs The shared attrs object which is used to populate the normalized attributes.&#A;     * @param {number=} maxPriority Max directive priority.

				Alias: groupScan(node,attrStart,attrEnd)
				StartLine: 7637
				EndLine: 7659
				NodeType: Function
				Comment: *&#A;     * Given a node with an directive-start it collects all of the siblings until it finds&#A;     * directive-end.&#A;     * @param node&#A;     * @param attrStart&#A;     * @param attrEnd&#A;     * @returns {*}

				Alias: groupElementsLinkFnWrapper(linkFn,attrStart,attrEnd)
				StartLine: 7669
				EndLine: 7674
				NodeType: Function
				Comment: *&#A;     * Wrapper for linking function which converts normal linking function into a grouped&#A;     * linking function.&#A;     * @param linkFn&#A;     * @param attrStart&#A;     * @param attrEnd&#A;     * @returns {Function}

					Alias: ?(scope,element,at…scludeFn)
					StartLine: 7670
					EndLine: 7673
					NodeType: AnonymousFunction

				Alias: applyDirectivesToNode(directives,compi…eContext)
				StartLine: 7699
				EndLine: 8126
				NodeType: Function
				Comment: *&#A;     * Once the directives have been collected, their compile functions are executed. This method&#A;     * is responsible for inlining directive templates as well as terminating the application&#A;     * of the directives if the terminal directive has been reached.&#A;     *&#A;     * @param {Array} directives Array of collected directives to execute their compile function.&#A;     *        this needs to be pre-sorted by priority order.&#A;     * @param {Node} compileNode The raw DOM node to apply the compile functions to&#A;     * @param {Object} templateAttrs The shared attribute function&#A;     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the&#A;     *                                                  scope argument is auto-generated to the new&#A;     *                                                  child of the transcluded parent scope.&#A;     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this&#A;     *                              argument has the root jqLite array so that we can replace nodes&#A;     *                              on it.&#A;     * @param {Object=} originalReplaceDirective An optional directive that will be ignored when&#A;     *                                           compiling the transclusion.&#A;     * @param {Array.&lt;Function&gt;} preLinkFns&#A;     * @param {Array.&lt;Function&gt;} postLinkFns&#A;     * @param {Object} previousCompileContext Context used for previous compilation of the current&#A;     *                                        node&#A;     * @returns {Function} linkFn

					Alias: addLinkFns(pre,post,attrSta…,attrEnd)
					StartLine: 7909
					EndLine: 7928
					NodeType: Function

						Alias: cloneAndAnnotateFn.pre&gt;?
						StartLine: 7915
						EndLine: 7915
						NodeType: Object

						Alias: cloneAndAnnotateFn.post&gt;?
						StartLine: 7924
						EndLine: 7924
						NodeType: Object

					Alias: getControllers(directiveName,re…trollers)
					StartLine: 7931
					EndLine: 7968
					NodeType: Function

					Alias: setupControllers($element,attrs,t…pe,scope)
					StartLine: 7970
					EndLine: 7999
					NodeType: Function

					Alias: nodeLinkFn(childLinkFn,scop…isLinkFn)
					StartLine: 8001
					EndLine: 8125
					NodeType: Function

						Alias: controllersBoundTransclude(scope,cloneAttac…tElement)
						StartLine: 8107
						EndLine: 8124
						NodeType: Function
						Comment: This is the function that is injected as `$transclude`.&#D;&#A; Note: all arguments are optional!

				Alias: markDirectivesAsIsolate(directives)
				StartLine: 8128
				EndLine: 8133
				NodeType: Function
				Comment: mark all directives as needing isolate scope.

				Alias: addDirective(tDirectives,name…AttrName)
				StartLine: 8149
				EndLine: 8170
				NodeType: Function
				Comment: *&#A;     * looks up the directive and decorates it with exception handling and proper parameters. We&#A;     * call this the boundDirective.&#A;     *&#A;     * @param {string} name name of the directive to look up.&#A;     * @param {string} location The directive must be found in specific format.&#A;     *   String containing any of theses characters:&#A;     *&#A;     *   * `E`: element name&#A;     *   * `A&#39;: attribute&#A;     *   * `C`: class&#A;     *   * `M`: comment&#A;     * @returns {boolean} true if directive was added.

				Alias: directiveIsMultiElement(name)
				StartLine: 8181
				EndLine: 8192
				NodeType: Function
				Comment: *&#A;     * looks up the directive and returns true if it is a multi-element directive,&#A;     * and therefore requires DOM nodes between -start and -end markers to be grouped&#A;     * together.&#A;     *&#A;     * @param {string} name name of the directive to look up.&#A;     * @returns true if directive was registered as multi-element.

				Alias: mergeTemplateAttributes(dst,src)
				StartLine: 8202
				EndLine: 8233
				NodeType: Function
				Comment: *&#A;     * When the element is replaced with HTML template then the new attributes&#A;     * on the template need to be merged with the existing attributes in the DOM.&#A;     * The desired effect is to have both of the attributes present.&#A;     *&#A;     * @param {object} dst destination attributes (original DOM)&#A;     * @param {object} src source attributes (from the directive template)

					Alias: forEach&gt;?(value,key)
					StartLine: 8208
					EndLine: 8215
					NodeType: AnonymousFunction
					Comment: reapply the old attributes to the new element

					Alias: forEach&gt;?(value,key)
					StartLine: 8218
					EndLine: 8232
					NodeType: AnonymousFunction
					Comment: copy the new attributes on the old attrs object

				Alias: compileTemplateUrl(directives,$comp…eContext)
				StartLine: 8236
				EndLine: 8348
				NodeType: Function

					Alias: inherit.derivedSyncDirective&gt;?
					StartLine: 8243
					EndLine: 8245
					NodeType: Object

					Alias: then&gt;?(content)
					StartLine: 8254
					EndLine: 8330
					NodeType: AnonymousFunction

						Alias: tempTemplateAttrs
						StartLine: 8273
						EndLine: 8273
						NodeType: Object

						Alias: forEach&gt;?(node,i)
						StartLine: 8292
						EndLine: 8296
						NodeType: AnonymousFunction

					Alias: delayedNodeLinkFn(ignoreChildLinkF…scludeFn)
					StartLine: 8332
					EndLine: 8347
					NodeType: Function

				Alias: byPriority(a,b)
				StartLine: 8354
				EndLine: 8359
				NodeType: Function
				Comment: *&#A;     * Sorting function for bound directives.

				Alias: assertNoDuplicate(what,previousDir…,element)
				StartLine: 8362
				EndLine: 8367
				NodeType: Function

				Alias: addTextInterpolateDirective(directives,text)
				StartLine: 8370
				EndLine: 8394
				NodeType: Function

					Alias: push&gt;?
					StartLine: 8373
					EndLine: 8392
					NodeType: Object

						Alias: textInterpolateCompileFn(templateNode)
						StartLine: 8375
						EndLine: 8391
						NodeType: Function

							Alias: textInterpolateLinkFn(scope,node)
							StartLine: 8383
							EndLine: 8390
							NodeType: Function

								Alias: interpolateFnWatchAction(value)
								StartLine: 8387
								EndLine: 8389
								NodeType: Function

				Alias: wrapTemplate(type,template)
				StartLine: 8397
				EndLine: 8408
				NodeType: Function

				Alias: getTrustedContext(node,attrNormalizedName)
				StartLine: 8411
				EndLine: 8423
				NodeType: Function

				Alias: addAttrInterpolateDirective(node,directives,…rNothing)
				StartLine: 8426
				EndLine: 8493
				NodeType: Function

					Alias: push&gt;?
					StartLine: 8442
					EndLine: 8492
					NodeType: Object

						Alias: compile()
						StartLine: 8444
						EndLine: 8491
						NodeType: Function

							Alias: ?
							StartLine: 8445
							EndLine: 8490
							NodeType: Object

								Alias: attrInterpolatePreLinkFn(scope,element,attr)
								StartLine: 8446
								EndLine: 8489
								NodeType: Function

									Alias: interpolateFnWatchAction(newValue,oldValue)
									StartLine: 8476
									EndLine: 8488
									NodeType: Function
									Comment: special case for class attribute addition + removal&#D;&#A;so that class changes can tap into the animation&#D;&#A;hooks provided by the $animate service. Be sure to&#D;&#A;skip animations when the first digest occurs (when&#D;&#A;both the new and the old values are the same) since&#D;&#A;the CSS classes are the non-interpolated values

				Alias: replaceWith($rootElement,ele…,newNode)
				StartLine: 8506
				EndLine: 8577
				NodeType: Function
				Comment: *&#A;     * This is a special jqLite.replaceWith, which can replace items which&#A;     * have no parents, provided that the containing jqLite collection is provided.&#A;     *&#A;     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes&#A;     *                               in the root of the tree.&#A;     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep&#A;     *                                  the shell, but replace its DOM node reference.&#A;     * @param {Node} newNode The new DOM node.

				Alias: cloneAndAnnotateFn(fn,annotation)
				StartLine: 8580
				EndLine: 8582
				NodeType: Function

					Alias: extend&gt;?()
					StartLine: 8581
					EndLine: 8581
					NodeType: AnonymousFunction

				Alias: invokeLinkFn(linkFn,scope,$el…scludeFn)
				StartLine: 8585
				EndLine: 8591
				NodeType: Function

				Alias: initializeDirectiveBindings(scope,attrs,dest…newScope)
				StartLine: 8596
				EndLine: 8687
				NodeType: Function
				Comment: Set up $watches for isolate scope and controller bindings. This process&#D;&#A; only occurs for isolate scopes and new scopes with controllerAs.

					Alias: forEach&gt;?(definition,scopeName)
					StartLine: 8599
					EndLine: 8676
					NodeType: AnonymousFunction

						Alias: $observe&gt;?(value)
						StartLine: 8609
						EndLine: 8611
						NodeType: AnonymousFunction

						Alias: compare(a,b)
						StartLine: 8628
						EndLine: 8628
						NodeType: Function

						Alias: parentSet()
						StartLine: 8630
						EndLine: 8636
						NodeType: Function
						Comment: reset the change, or we will throw this exception on every $digest

						Alias: parentValueWatch(parentValue)
						StartLine: 8638
						EndLine: 8650
						NodeType: Function

						Alias: scopeName(locals)
						StartLine: 8671
						EndLine: 8673
						NodeType: Function

		Alias: directiveNormalize(name)
		StartLine: 8696
		EndLine: 8698
		NodeType: Function
		Comment: *&#A; * Converts all accepted directives format into proper directive name.&#A; * @param name Name to normalize

		Alias: nodesetLinkingFn(scope,nodeList,r…scludeFn)
		StartLine: 8745
		EndLine: 8750
		NodeType: Function
		Comment: angular.Scope &#D;&#A; NodeList &#D;&#A; Element &#D;&#A; function(Function)

		Alias: directiveLinkingFn(nodesetLinkingFn…scludeFn)
		StartLine: 8752
		EndLine: 8758
		NodeType: Function
		Comment: nodesetLinkingFn &#D;&#A; angular.Scope &#D;&#A; Node &#D;&#A; Element &#D;&#A; function(Function)

		Alias: tokenDifference(str1,str2)
		StartLine: 8760
		EndLine: 8774
		NodeType: Function

		Alias: removeComments(jqNodes)
		StartLine: 8776
		EndLine: 8791
		NodeType: Function

		Alias: identifierForController(controller,ident)
		StartLine: 8797
		EndLine: 8803
		NodeType: Function

		Alias: $ControllerProvider()
		StartLine: 8816
		EndLine: 8962
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $controllerProvider&#A; * @description&#A; * The {@link ng.$controller $controller service} is used by Angular to create new&#A; * controllers.&#A; *&#A; * This provider allows controller registration via the&#A; * {@link ng.$controllerProvider#register register} method.

			Alias: register(name,constructor)
			StartLine: 8828
			EndLine: 8835
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $controllerProvider#register&#A;   * @param {string|Object} name Controller name, or an object map of controllers where the keys are&#A;   *    the names and the values are the constructors.&#A;   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI&#A;   *    annotations in the array notation).

			Alias: allowGlobals()
			StartLine: 8842
			EndLine: 8844
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $controllerProvider#allowGlobals&#A;   * @description If called, allows `$controller` to find controller constructors on `window`

			Alias: ?($injector,$window)
			StartLine: 8847
			EndLine: 8961
			NodeType: AnonymousFunction

				Alias: ?(expression,local…er,ident)
				StartLine: 8876
				EndLine: 8950
				NodeType: AnonymousFunction
				Comment: *&#A;     * @ngdoc service&#A;     * @name $controller&#A;     * @requires $injector&#A;     *&#A;     * @param {Function|string} constructor If called with a function then it&#39;s considered to be the&#A;     *    controller constructor function. Otherwise it&#39;s considered to be a string which is used&#A;     *    to retrieve the controller constructor using the following steps:&#A;     *&#A;     *    * check if a controller with given name is registered via `$controllerProvider`&#A;     *    * check if evaluating the string on the current scope returns a constructor&#A;     *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global&#A;     *      `window` object (not recommended)&#A;     *&#A;     *    The string can use the `controller as property` syntax, where the controller instance is published&#A;     *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this&#A;     *    to work correctly.&#A;     *&#A;     * @param {Object} locals Injection locals for Controller.&#A;     * @return {Object} Instance of given controller.&#A;     *&#A;     * @description&#A;     * `$controller` service is responsible for instantiating controllers.&#A;     *&#A;     * It&#39;s just a simple call to {@link auto.$injector $injector}, but extracted into&#A;     * a service, so that one can override this service with [BC version](https://gist.github.com/1649788).&#A;     &#D;&#A; PRIVATE API:&#D;&#A;   param `later` --- indicates that the controller&#39;s constructor is invoked at a later time.&#D;&#A;                     If true, $controller will allocate the object with the correct&#D;&#A;                     prototype chain, but will not invoke the controller until a returned&#D;&#A;                     callback is invoked.&#D;&#A;   param `ident` --- An optional label which overrides the label parsed from the controller&#D;&#A;                     expression, if any.

					Alias: extend.instantiate&gt;?()
					StartLine: 8927
					EndLine: 8937
					NodeType: AnonymousFunction

					Alias: extend.instantiate&gt;?
					StartLine: 8937
					EndLine: 8940
					NodeType: Object

				Alias: addIdentifier(locals,identifie…nce,name)
				StartLine: 8952
				EndLine: 8960
				NodeType: Function

		Alias: $DocumentProvider()
		StartLine: 8989
		EndLine: 8993
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $document&#A; * @requires $window&#A; *&#A; * @description&#A; * A {@link angular.element jQuery or jqLite} wrapper for the browser&#39;s `window.document` object.&#A; *&#A; * @example&#A;   &lt;example module=&quot;documentExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;p&gt;$document title: &lt;b ng-bind=&quot;title&quot;&gt;&lt;/b&gt;&lt;/p&gt;&#A;         &lt;p&gt;window.document title: &lt;b ng-bind=&quot;windowTitle&quot;&gt;&lt;/b&gt;&lt;/p&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;script.js&quot;&gt;&#A;       angular.module(&#39;documentExample&#39;, [])&#A;         .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, &#39;$document&#39;, function($scope, $document) {&#A;           $scope.title = $document[0].title;&#A;           $scope.windowTitle = angular.element(window.document)[0].title;&#A;         }]);&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ?(window)
			StartLine: 8990
			EndLine: 8992
			NodeType: AnonymousFunction

		Alias: $ExceptionHandlerProvider()
		StartLine: 9035
		EndLine: 9041
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $exceptionHandler&#A; * @requires ng.$log&#A; *&#A; * @description&#A; * Any uncaught exception in angular expressions is delegated to this service.&#A; * The default implementation simply delegates to `$log.error` which logs it into&#A; * the browser console.&#A; *&#A; * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by&#A; * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.&#A; *&#A; * ## Example:&#A; *&#A; * ```js&#A; *   angular.module(&#39;exceptionOverride&#39;, []).factory(&#39;$exceptionHandler&#39;, function() {&#A; *     return function(exception, cause) {&#A; *       exception.message += &#39; (caused by &quot;&#39; + cause + &#39;&quot;)&#39;;&#A; *       throw exception;&#A; *     };&#A; *   });&#A; * ```&#A; *&#A; * This example will override the normal action of `$exceptionHandler`, to make angular&#A; * exceptions fail hard when they happen, instead of just logging to the console.&#A; *&#A; * &lt;hr /&gt;&#A; * Note, that code executed in event-listeners (even those registered using jqLite&#39;s `on`/`bind`&#A; * methods) does not delegate exceptions to the {@link ng.$exceptionHandler $exceptionHandler}&#A; * (unless executed during a digest).&#A; *&#A; * If you wish, you can manually delegate exceptions, e.g.&#A; * `try { ... } catch(e) { $exceptionHandler(e); }`&#A; *&#A; * @param {Error} exception Exception associated with the error.&#A; * @param {string=} cause optional information about the context in which&#A; *       the error was thrown.&#A; *

			Alias: ?($log)
			StartLine: 9036
			EndLine: 9040
			NodeType: AnonymousFunction

				Alias: ?(exception,cause)
				StartLine: 9037
				EndLine: 9039
				NodeType: AnonymousFunction

		Alias: CONTENT_TYPE_APPLICATION_JSON
		StartLine: 9044
		EndLine: 9044
		NodeType: Object

		Alias: JSON_ENDS
		StartLine: 9046
		EndLine: 9049
		NodeType: Object

		Alias: serializeValue(v)
		StartLine: 9052
		EndLine: 9057
		NodeType: Function

		Alias: $HttpParamSerializerProvider()
		StartLine: 9060
		EndLine: 9091
		NodeType: Function
		Comment: *&#A;   * @ngdoc service&#A;   * @name $httpParamSerializer&#A;   * @description&#A;   *&#A;   * Default $http params serializer that converts objects to a part of a request URL&#A;   * according to the following rules:&#A;   * * `{&#39;foo&#39;: &#39;bar&#39;}` results in `foo=bar`&#A;   * * `{&#39;foo&#39;: Date.now()}` results in `foo=2015-04-01T09%3A50%3A49.262Z` (`toISOString()` and encoded representation of a Date object)&#A;   * * `{&#39;foo&#39;: [&#39;bar&#39;, &#39;baz&#39;]}` results in `foo=bar&amp;foo=baz` (repeated key for each array element)&#A;   * * `{&#39;foo&#39;: {&#39;bar&#39;:&#39;baz&#39;}}` results in `foo=%7B%22bar%22%3A%22baz%22%7D&quot;` (stringified and encoded representation of an object)&#A;   *

			Alias: $get()
			StartLine: 9073
			EndLine: 9090
			NodeType: Function

				Alias: ngParamSerializer(params)
				StartLine: 9074
				EndLine: 9089
				NodeType: Function

					Alias: forEachSorted&gt;?(value,key)
					StartLine: 9077
					EndLine: 9086
					NodeType: AnonymousFunction

						Alias: forEach&gt;?(v,k)
						StartLine: 9080
						EndLine: 9082
						NodeType: AnonymousFunction

		Alias: $HttpParamSerializerJQLikeProvider()
		StartLine: 9093
		EndLine: 9127
		NodeType: Function
		Comment: *&#A;   * @ngdoc service&#A;   * @name $httpParamSerializerJQLike&#A;   * @description&#A;   *&#A;   * Alternative $http params serializer that follows jQuery&#39;s [`param()`](http://api.jquery.com/jquery.param/) method logic.&#A;   *

			Alias: $get()
			StartLine: 9101
			EndLine: 9126
			NodeType: Function

				Alias: jQueryLikeParamSerializer(params)
				StartLine: 9102
				EndLine: 9125
				NodeType: Function

					Alias: serialize(toSerialize,pref…topLevel)
					StartLine: 9108
					EndLine: 9124
					NodeType: Function

						Alias: forEach&gt;?(value)
						StartLine: 9111
						EndLine: 9113
						NodeType: AnonymousFunction

						Alias: forEachSorted&gt;?(value,key)
						StartLine: 9115
						EndLine: 9120
						NodeType: AnonymousFunction

		Alias: defaultHttpResponseTransform(data,headers)
		StartLine: 9129
		EndLine: 9143
		NodeType: Function

		Alias: isJsonLike(str)
		StartLine: 9145
		EndLine: 9148
		NodeType: Function

		Alias: parseHeaders(headers)
		StartLine: 9156
		EndLine: 9177
		NodeType: Function
		Comment: *&#A; * Parse headers into key value object&#A; *&#A; * @param {string} headers Raw headers as a string&#A; * @returns {Object} Parsed headers as key value object

			Alias: fillInParsed(key,val)
			StartLine: 9159
			EndLine: 9163
			NodeType: Function

			Alias: forEach&gt;?(line)
			StartLine: 9166
			EndLine: 9169
			NodeType: AnonymousFunction

			Alias: forEach&gt;?(headerVal,headerKey)
			StartLine: 9171
			EndLine: 9173
			NodeType: AnonymousFunction

		Alias: headersGetter(headers)
		StartLine: 9192
		EndLine: 9208
		NodeType: Function
		Comment: *&#A; * Returns a function that provides access to parsed headers.&#A; *&#A; * Headers are lazy parsed when first requested.&#A; * @see parseHeaders&#A; *&#A; * @param {(string|Object)} headers Headers to provide access to.&#A; * @returns {function(string=)} Returns a getter function which if called with:&#A; *&#A; *   - if called with single an argument returns a single header value or null&#A; *   - if called with no arguments returns an object containing all headers.

			Alias: ?(name)
			StartLine: 9195
			EndLine: 9207
			NodeType: AnonymousFunction

		Alias: transformData(data,headers,status,fns)
		StartLine: 9222
		EndLine: 9232
		NodeType: Function
		Comment: *&#A; * Chain all given functions&#A; *&#A; * This function is used for both request and response transforming&#A; *&#A; * @param {*} data Data to transform.&#A; * @param {function(string=)} headers HTTP headers getter fn.&#A; * @param {number} status HTTP status code of the response.&#A; * @param {(Function|Array.&lt;Function&gt;)} fns Function or an array of functions.&#A; * @returns {*} Transformed data.

			Alias: forEach&gt;?(fn)
			StartLine: 9227
			EndLine: 9229
			NodeType: AnonymousFunction

		Alias: isSuccess(status)
		StartLine: 9235
		EndLine: 9237
		NodeType: Function

		Alias: $HttpProvider()
		StartLine: 9246
		EndLine: 10285
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $httpProvider&#A; * @description&#A; * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.&#A; * &#D;&#A;*&#A;   * @ngdoc property&#A;   * @name $httpProvider#defaults&#A;   * @description&#A;   *&#A;   * Object containing default values for all {@link ng.$http $http} requests.&#A;   *&#A;   * - **`defaults.cache`** - {Object} - an object built with {@link ng.$cacheFactory `$cacheFactory`}&#A;   * that will provide the cache for all requests who set their `cache` property to `true`.&#A;   * If you set the `default.cache = false` then only requests that specify their own custom&#A;   * cache object will be cached. See {@link $http#caching $http Caching} for more information.&#A;   *&#A;   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.&#A;   * Defaults value is `&#39;XSRF-TOKEN&#39;`.&#A;   *&#A;   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the&#A;   * XSRF token. Defaults value is `&#39;X-XSRF-TOKEN&#39;`.&#A;   *&#A;   * - **`defaults.headers`** - {Object} - Default headers for all $http requests.&#A;   * Refer to {@link ng.$http#setting-http-headers $http} for documentation on&#A;   * setting default headers.&#A;   *     - **`defaults.headers.common`**&#A;   *     - **`defaults.headers.post`**&#A;   *     - **`defaults.headers.put`**&#A;   *     - **`defaults.headers.patch`**&#A;   *&#A;   * - **`defaults.paramSerializer`** - {string|function(Object&lt;string,string&gt;):string} - A function used to prepare string representation&#A;   * of request parameters (specified as an object).&#A;   * If specified as string, it is interpreted as a function registered with the {@link auto.$injector $injector}.&#A;   * Defaults to {@link ng.$httpParamSerializer $httpParamSerializer}.&#A;   *&#A;   *

			Alias: defaults.defaults
			StartLine: 9279
			EndLine: 9302
			NodeType: Object
			Comment: transform incoming response data

				Alias: ?(d)
				StartLine: 9284
				EndLine: 9286
				NodeType: AnonymousFunction
				Comment: transform outgoing request data

				Alias: headers
				StartLine: 9289
				EndLine: 9296
				NodeType: Object
				Comment: default headers

					Alias: common
					StartLine: 9290
					EndLine: 9292
					NodeType: Object

			Alias: useApplyAsync(value)
			StartLine: 9324
			EndLine: 9330
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $httpProvider#useApplyAsync&#A;   * @description&#A;   *&#A;   * Configure $http service to combine processing of multiple http responses received at around&#A;   * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in&#A;   * significant performance improvement for bigger applications that make many HTTP requests&#A;   * concurrently (common during application bootstrap).&#A;   *&#A;   * Defaults to false. If no value is specified, returns the current configured value.&#A;   *&#A;   * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred&#A;   *    &quot;apply&quot; on the next tick, giving time for subsequent requests in a roughly ~10ms window&#A;   *    to load and share the same digest cycle.&#A;   *&#A;   * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.&#A;   *    otherwise, returns the current configured value.&#A;   *

			Alias: ?($httpBackend,$$c…injector)
			StartLine: 9348
			EndLine: 10284
			NodeType: AnonymousFunction

				Alias: forEach&gt;?(interceptorFactory)
				StartLine: 9365
				EndLine: 9368
				NodeType: AnonymousFunction

				Alias: $http(requestConfig)
				StartLine: 9891
				EndLine: 10024
				NodeType: Function
				Comment: *&#A;     * @ngdoc service&#A;     * @kind function&#A;     * @name $http&#A;     * @requires ng.$httpBackend&#A;     * @requires $cacheFactory&#A;     * @requires $rootScope&#A;     * @requires $q&#A;     * @requires $injector&#A;     *&#A;     * @description&#A;     * The `$http` service is a core Angular service that facilitates communication with the remote&#A;     * HTTP servers via the browser&#39;s [XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)&#A;     * object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).&#A;     *&#A;     * For unit testing applications that use `$http` service, see&#A;     * {@link ngMock.$httpBackend $httpBackend mock}.&#A;     *&#A;     * For a higher level of abstraction, please check out the {@link ngResource.$resource&#A;     * $resource} service.&#A;     *&#A;     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by&#A;     * the $q service. While for simple usage patterns this doesn&#39;t matter much, for advanced usage&#A;     * it is important to familiarize yourself with these APIs and the guarantees they provide.&#A;     *&#A;     *&#A;     * ## General usage&#A;     * The `$http` service is a function which takes a single argument — a configuration object —&#A;     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}&#A;     * with two $http specific methods: `success` and `error`.&#A;     *&#A;     * ```js&#A;     *   // Simple GET request example :&#A;     *   $http.get(&#39;/someUrl&#39;).&#A;     *     success(function(data, status, headers, config) {&#A;     *       // this callback will be called asynchronously&#A;     *       // when the response is available&#A;     *     }).&#A;     *     error(function(data, status, headers, config) {&#A;     *       // called asynchronously if an error occurs&#A;     *       // or server returns response with an error status.&#A;     *     });&#A;     * ```&#A;     *&#A;     * ```js&#A;     *   // Simple POST request example (passing data) :&#A;     *   $http.post(&#39;/someUrl&#39;, {msg:&#39;hello word!&#39;}).&#A;     *     success(function(data, status, headers, config) {&#A;     *       // this callback will be called asynchronously&#A;     *       // when the response is available&#A;     *     }).&#A;     *     error(function(data, status, headers, config) {&#A;     *       // called asynchronously if an error occurs&#A;     *       // or server returns response with an error status.&#A;     *     });&#A;     * ```&#A;     *&#A;     *&#A;     * Since the returned value of calling the $http function is a `promise`, you can also use&#A;     * the `then` method to register callbacks, and these callbacks will receive a single argument –&#A;     * an object representing the response. See the API signature and type info below for more&#A;     * details.&#A;     *&#A;     * A response status code between 200 and 299 is considered a success status and&#A;     * will result in the success callback being called. Note that if the response is a redirect,&#A;     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be&#A;     * called for such responses.&#A;     *&#A;     * ## Writing Unit Tests that use $http&#A;     * When unit testing (using {@link ngMock ngMock}), it is necessary to call&#A;     * {@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush each pending&#A;     * request using trained responses.&#A;     *&#A;     * ```&#A;     * $httpBackend.expectGET(...);&#A;     * $http.get(...);&#A;     * $httpBackend.flush();&#A;     * ```&#A;     *&#A;     * ## Shortcut methods&#A;     *&#A;     * Shortcut methods are also available. All shortcut methods require passing in the URL, and&#A;     * request data must be passed in for POST/PUT requests.&#A;     *&#A;     * ```js&#A;     *   $http.get(&#39;/someUrl&#39;).success(successCallback);&#A;     *   $http.post(&#39;/someUrl&#39;, data).success(successCallback);&#A;     * ```&#A;     *&#A;     * Complete list of shortcut methods:&#A;     *&#A;     * - {@link ng.$http#get $http.get}&#A;     * - {@link ng.$http#head $http.head}&#A;     * - {@link ng.$http#post $http.post}&#A;     * - {@link ng.$http#put $http.put}&#A;     * - {@link ng.$http#delete $http.delete}&#A;     * - {@link ng.$http#jsonp $http.jsonp}&#A;     * - {@link ng.$http#patch $http.patch}&#A;     *&#A;     *&#A;     * ## Setting HTTP Headers&#A;     *&#A;     * The $http service will automatically add certain HTTP headers to all requests. These defaults&#A;     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration&#A;     * object, which currently contains this default configuration:&#A;     *&#A;     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):&#A;     *   - `Accept: application/json, text/plain, * / *`&#A;     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)&#A;     *   - `Content-Type: application/json`&#A;     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)&#A;     *   - `Content-Type: application/json`&#A;     *&#A;     * To add or overwrite these defaults, simply add or remove a property from these configuration&#A;     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object&#A;     * with the lowercased HTTP method name as the key, e.g.&#A;     * `$httpProvider.defaults.headers.get = { &#39;My-Header&#39; : &#39;value&#39; }`.&#A;     *&#A;     * The defaults can also be set at runtime via the `$http.defaults` object in the same&#A;     * fashion. For example:&#A;     *&#A;     * ```&#A;     * module.run(function($http) {&#A;     *   $http.defaults.headers.common.Authorization = &#39;Basic YmVlcDpib29w&#39;&#A;     * });&#A;     * ```&#A;     *&#A;     * In addition, you can supply a `headers` property in the config object passed when&#A;     * calling `$http(config)`, which overrides the defaults without changing them globally.&#A;     *&#A;     * To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis,&#A;     * Use the `headers` property, setting the desired header to `undefined`. For example:&#A;     *&#A;     * ```js&#A;     * var req = {&#A;     *  method: &#39;POST&#39;,&#A;     *  url: &#39;http://example.com&#39;,&#A;     *  headers: {&#A;     *    &#39;Content-Type&#39;: undefined&#A;     *  },&#A;     *  data: { test: &#39;test&#39; }&#A;     * }&#A;     *&#A;     * $http(req).success(function(){...}).error(function(){...});&#A;     * ```&#A;     *&#A;     * ## Transforming Requests and Responses&#A;     *&#A;     * Both requests and responses can be transformed using transformation functions: `transformRequest`&#A;     * and `transformResponse`. These properties can be a single function that returns&#A;     * the transformed value (`function(data, headersGetter, status)`) or an array of such transformation functions,&#A;     * which allows you to `push` or `unshift` a new transformation function into the transformation chain.&#A;     *&#A;     * ### Default Transformations&#A;     *&#A;     * The `$httpProvider` provider and `$http` service expose `defaults.transformRequest` and&#A;     * `defaults.transformResponse` properties. If a request does not provide its own transformations&#A;     * then these will be applied.&#A;     *&#A;     * You can augment or replace the default transformations by modifying these properties by adding to or&#A;     * replacing the array.&#A;     *&#A;     * Angular provides the following default transformations:&#A;     *&#A;     * Request transformations (`$httpProvider.defaults.transformRequest` and `$http.defaults.transformRequest`):&#A;     *&#A;     * - If the `data` property of the request configuration object contains an object, serialize it&#A;     *   into JSON format.&#A;     *&#A;     * Response transformations (`$httpProvider.defaults.transformResponse` and `$http.defaults.transformResponse`):&#A;     *&#A;     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).&#A;     *  - If JSON response is detected, deserialize it using a JSON parser.&#A;     *&#A;     *&#A;     * ### Overriding the Default Transformations Per Request&#A;     *&#A;     * If you wish override the request/response transformations only for a single request then provide&#A;     * `transformRequest` and/or `transformResponse` properties on the configuration object passed&#A;     * into `$http`.&#A;     *&#A;     * Note that if you provide these properties on the config object the default transformations will be&#A;     * overwritten. If you wish to augment the default transformations then you must include them in your&#A;     * local transformation array.&#A;     *&#A;     * The following code demonstrates adding a new response transformation to be run after the default response&#A;     * transformations have been run.&#A;     *&#A;     * ```js&#A;     * function appendTransform(defaults, transform) {&#A;     *&#A;     *   // We can&#39;t guarantee that the default transformation is an array&#A;     *   defaults = angular.isArray(defaults) ? defaults : [defaults];&#A;     *&#A;     *   // Append the new transformation to the defaults&#A;     *   return defaults.concat(transform);&#A;     * }&#A;     *&#A;     * $http({&#A;     *   url: &#39;...&#39;,&#A;     *   method: &#39;GET&#39;,&#A;     *   transformResponse: appendTransform($http.defaults.transformResponse, function(value) {&#A;     *     return doTransform(value);&#A;     *   })&#A;     * });&#A;     * ```&#A;     *&#A;     *&#A;     * ## Caching&#A;     *&#A;     * To enable caching, set the request configuration `cache` property to `true` (to use default&#A;     * cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).&#A;     * When the cache is enabled, `$http` stores the response from the server in the specified&#A;     * cache. The next time the same request is made, the response is served from the cache without&#A;     * sending a request to the server.&#A;     *&#A;     * Note that even if the response is served from cache, delivery of the data is asynchronous in&#A;     * the same way that real requests are.&#A;     *&#A;     * If there are multiple GET requests for the same URL that should be cached using the same&#A;     * cache, but the cache is not populated yet, only one request to the server will be made and&#A;     * the remaining requests will be fulfilled using the response from the first request.&#A;     *&#A;     * You can change the default cache to a new object (built with&#A;     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the&#A;     * {@link ng.$http#defaults `$http.defaults.cache`} property. All requests who set&#A;     * their `cache` property to `true` will now use this cache object.&#A;     *&#A;     * If you set the default cache to `false` then only requests that specify their own custom&#A;     * cache object will be cached.&#A;     *&#A;     * ## Interceptors&#A;     *&#A;     * Before you start creating interceptors, be sure to understand the&#A;     * {@link ng.$q $q and deferred/promise APIs}.&#A;     *&#A;     * For purposes of global error handling, authentication, or any kind of synchronous or&#A;     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be&#A;     * able to intercept requests before they are handed to the server and&#A;     * responses before they are handed over to the application code that&#A;     * initiated these requests. The interceptors leverage the {@link ng.$q&#A;     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.&#A;     *&#A;     * The interceptors are service factories that are registered with the `$httpProvider` by&#A;     * adding them to the `$httpProvider.interceptors` array. The factory is called and&#A;     * injected with dependencies (if specified) and returns the interceptor.&#A;     *&#A;     * There are two kinds of interceptors (and two kinds of rejection interceptors):&#A;     *&#A;     *   * `request`: interceptors get called with a http `config` object. The function is free to&#A;     *     modify the `config` object or create a new one. The function needs to return the `config`&#A;     *     object directly, or a promise containing the `config` or a new `config` object.&#A;     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or&#A;     *     resolved with a rejection.&#A;     *   * `response`: interceptors get called with http `response` object. The function is free to&#A;     *     modify the `response` object or create a new one. The function needs to return the `response`&#A;     *     object directly, or as a promise containing the `response` or a new `response` object.&#A;     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or&#A;     *     resolved with a rejection.&#A;     *&#A;     *&#A;     * ```js&#A;     *   // register the interceptor as a service&#A;     *   $provide.factory(&#39;myHttpInterceptor&#39;, function($q, dependency1, dependency2) {&#A;     *     return {&#A;     *       // optional method&#A;     *       &#39;request&#39;: function(config) {&#A;     *         // do something on success&#A;     *         return config;&#A;     *       },&#A;     *&#A;     *       // optional method&#A;     *      &#39;requestError&#39;: function(rejection) {&#A;     *         // do something on error&#A;     *         if (canRecover(rejection)) {&#A;     *           return responseOrNewPromise&#A;     *         }&#A;     *         return $q.reject(rejection);&#A;     *       },&#A;     *&#A;     *&#A;     *&#A;     *       // optional method&#A;     *       &#39;response&#39;: function(response) {&#A;     *         // do something on success&#A;     *         return response;&#A;     *       },&#A;     *&#A;     *       // optional method&#A;     *      &#39;responseError&#39;: function(rejection) {&#A;     *         // do something on error&#A;     *         if (canRecover(rejection)) {&#A;     *           return responseOrNewPromise&#A;     *         }&#A;     *         return $q.reject(rejection);&#A;     *       }&#A;     *     };&#A;     *   });&#A;     *&#A;     *   $httpProvider.interceptors.push(&#39;myHttpInterceptor&#39;);&#A;     *&#A;     *&#A;     *   // alternatively, register the interceptor via an anonymous factory&#A;     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {&#A;     *     return {&#A;     *      &#39;request&#39;: function(config) {&#A;     *          // same as above&#A;     *       },&#A;     *&#A;     *       &#39;response&#39;: function(response) {&#A;     *          // same as above&#A;     *       }&#A;     *     };&#A;     *   });&#A;     * ```&#A;     *&#A;     * ## Security Considerations&#A;     *&#A;     * When designing web applications, consider security threats from:&#A;     *&#A;     * - [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)&#A;     * - [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)&#A;     *&#A;     * Both server and the client must cooperate in order to eliminate these threats. Angular comes&#A;     * pre-configured with strategies that address these issues, but for this to work backend server&#A;     * cooperation is required.&#A;     *&#A;     * ### JSON Vulnerability Protection&#A;     *&#A;     * A [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)&#A;     * allows third party website to turn your JSON resource URL into&#A;     * [JSONP](http://en.wikipedia.org/wiki/JSONP) request under some conditions. To&#A;     * counter this your server can prefix all JSON requests with following string `&quot;)]}&#39;,\n&quot;`.&#A;     * Angular will automatically strip the prefix before processing it as JSON.&#A;     *&#A;     * For example if your server needs to return:&#A;     * ```js&#A;     * [&#39;one&#39;,&#39;two&#39;]&#A;     * ```&#A;     *&#A;     * which is vulnerable to attack, your server can return:&#A;     * ```js&#A;     * )]}&#39;,&#A;     * [&#39;one&#39;,&#39;two&#39;]&#A;     * ```&#A;     *&#A;     * Angular will strip the prefix, before processing the JSON.&#A;     *&#A;     *&#A;     * ### Cross Site Request Forgery (XSRF) Protection&#A;     *&#A;     * [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) is a technique by which&#A;     * an unauthorized site can gain your user&#39;s private data. Angular provides a mechanism&#A;     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie&#A;     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only&#A;     * JavaScript that runs on your domain could read the cookie, your server can be assured that&#A;     * the XHR came from JavaScript running on your domain. The header will not be set for&#A;     * cross-domain requests.&#A;     *&#A;     * To take advantage of this, your server needs to set a token in a JavaScript readable session&#A;     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the&#A;     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure&#A;     * that only JavaScript running on your domain could have sent the request. The token must be&#A;     * unique for each user and must be verifiable by the server (to prevent the JavaScript from&#A;     * making up its own tokens). We recommend that the token is a digest of your site&#39;s&#A;     * authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography&amp;#41;)&#A;     * for added security.&#A;     *&#A;     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName&#A;     * properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,&#A;     * or the per-request config object.&#A;     *&#A;     *&#A;     * @param {object} config Object describing the request to be made and how it should be&#A;     *    processed. The object has following properties:&#A;     *&#A;     *    - **method** – `{string}` – HTTP method (e.g. &#39;GET&#39;, &#39;POST&#39;, etc)&#A;     *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.&#A;     *    - **params** – `{Object.&lt;string|Object&gt;}` – Map of strings or objects which will be turned&#A;     *      to `?key1=value1&amp;key2=value2` after the url. If the value is not a string, it will be&#A;     *      JSONified.&#A;     *    - **data** – `{string|Object}` – Data to be sent as the request message data.&#A;     *    - **headers** – `{Object}` – Map of strings or functions which return strings representing&#A;     *      HTTP headers to send to the server. If the return value of a function is null, the&#A;     *      header will not be sent. Functions accept a config object as an argument.&#A;     *    - **xsrfHeaderName** – `{string}` – Name of HTTP header to populate with the XSRF token.&#A;     *    - **xsrfCookieName** – `{string}` – Name of cookie containing the XSRF token.&#A;     *    - **transformRequest** –&#A;     *      `{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}` –&#A;     *      transform function or an array of such functions. The transform function takes the http&#A;     *      request body and headers and returns its transformed (typically serialized) version.&#A;     *      See {@link ng.$http#overriding-the-default-transformations-per-request&#A;     *      Overriding the Default Transformations}&#A;     *    - **transformResponse** –&#A;     *      `{function(data, headersGetter, status)|Array.&lt;function(data, headersGetter, status)&gt;}` –&#A;     *      transform function or an array of such functions. The transform function takes the http&#A;     *      response body, headers and status and returns its transformed (typically deserialized) version.&#A;     *      See {@link ng.$http#overriding-the-default-transformations-per-request&#A;     *      Overriding the Default Transformations}&#A;     *    - **paramSerializer** - {string|function(Object&lt;string,string&gt;):string} - A function used to prepare string representation&#A;     *      of request parameters (specified as an object).&#A;     *      Is specified as string, it is interpreted as function registered in with the {$injector}.&#A;     *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the&#A;     *      GET request, otherwise if a cache instance built with&#A;     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for&#A;     *      caching.&#A;     *    - **timeout** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise}&#A;     *      that should abort the request when resolved.&#A;     *    - **withCredentials** - `{boolean}` - whether to set the `withCredentials` flag on the&#A;     *      XHR object. See [requests with credentials](https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials)&#A;     *      for more information.&#A;     *    - **responseType** - `{string}` - see&#A;     *      [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).&#A;     *&#A;     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the&#A;     *   standard `then` method and two http specific methods: `success` and `error`. The `then`&#A;     *   method takes two arguments a success and an error callback which will be called with a&#A;     *   response object. The `success` and `error` methods take a single argument - a function that&#A;     *   will be called when the request succeeds or fails respectively. The arguments passed into&#A;     *   these functions are destructured representation of the response object passed into the&#A;     *   `then` method. The response object has these properties:&#A;     *&#A;     *   - **data** – `{string|Object}` – The response body transformed with the transform&#A;     *     functions.&#A;     *   - **status** – `{number}` – HTTP status code of the response.&#A;     *   - **headers** – `{function([headerName])}` – Header getter function.&#A;     *   - **config** – `{Object}` – The configuration object that was used to generate the request.&#A;     *   - **statusText** – `{string}` – HTTP status text of the response.&#A;     *&#A;     * @property {Array.&lt;Object&gt;} pendingRequests Array of config objects for currently pending&#A;     *   requests. This is primarily meant to be used for debugging purposes.&#A;     *&#A;     *&#A;     * @example&#A;&lt;example module=&quot;httpExample&quot;&gt;&#A;&lt;file name=&quot;index.html&quot;&gt;&#A;  &lt;div ng-controller=&quot;FetchController&quot;&gt;&#A;    &lt;select ng-model=&quot;method&quot; aria-label=&quot;Request method&quot;&gt;&#A;      &lt;option&gt;GET&lt;/option&gt;&#A;      &lt;option&gt;JSONP&lt;/option&gt;&#A;    &lt;/select&gt;&#A;    &lt;input type=&quot;text&quot; ng-model=&quot;url&quot; size=&quot;80&quot; aria-label=&quot;URL&quot; /&gt;&#A;    &lt;button id=&quot;fetchbtn&quot; ng-click=&quot;fetch()&quot;&gt;fetch&lt;/button&gt;&lt;br&gt;&#A;    &lt;button id=&quot;samplegetbtn&quot; ng-click=&quot;updateModel(&#39;GET&#39;, &#39;http-hello.html&#39;)&quot;&gt;Sample GET&lt;/button&gt;&#A;    &lt;button id=&quot;samplejsonpbtn&quot;&#A;      ng-click=&quot;updateModel(&#39;JSONP&#39;,&#A;                    &#39;https://angularjs.org/greet.php?callback=JSON_CALLBACK&amp;name=Super%20Hero&#39;)&quot;&gt;&#A;      Sample JSONP&#A;    &lt;/button&gt;&#A;    &lt;button id=&quot;invalidjsonpbtn&quot;&#A;      ng-click=&quot;updateModel(&#39;JSONP&#39;, &#39;https://angularjs.org/doesntexist&amp;callback=JSON_CALLBACK&#39;)&quot;&gt;&#A;        Invalid JSONP&#A;      &lt;/button&gt;&#A;    &lt;pre&gt;http status code: {{status}}&lt;/pre&gt;&#A;    &lt;pre&gt;http response data: {{data}}&lt;/pre&gt;&#A;  &lt;/div&gt;&#A;&lt;/file&gt;&#A;&lt;file name=&quot;script.js&quot;&gt;&#A;  angular.module(&#39;httpExample&#39;, [])&#A;    .controller(&#39;FetchController&#39;, [&#39;$scope&#39;, &#39;$http&#39;, &#39;$templateCache&#39;,&#A;      function($scope, $http, $templateCache) {&#A;        $scope.method = &#39;GET&#39;;&#A;        $scope.url = &#39;http-hello.html&#39;;&#A;&#A;        $scope.fetch = function() {&#A;          $scope.code = null;&#A;          $scope.response = null;&#A;&#A;          $http({method: $scope.method, url: $scope.url, cache: $templateCache}).&#A;            success(function(data, status) {&#A;              $scope.status = status;&#A;              $scope.data = data;&#A;            }).&#A;            error(function(data, status) {&#A;              $scope.data = data || &quot;Request failed&quot;;&#A;              $scope.status = status;&#A;          });&#A;        };&#A;&#A;        $scope.updateModel = function(method, url) {&#A;          $scope.method = method;&#A;          $scope.url = url;&#A;        };&#A;      }]);&#A;&lt;/file&gt;&#A;&lt;file name=&quot;http-hello.html&quot;&gt;&#A;  Hello, $http!&#A;&lt;/file&gt;&#A;&lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;  var status = element(by.binding(&#39;status&#39;));&#A;  var data = element(by.binding(&#39;data&#39;));&#A;  var fetchBtn = element(by.id(&#39;fetchbtn&#39;));&#A;  var sampleGetBtn = element(by.id(&#39;samplegetbtn&#39;));&#A;  var sampleJsonpBtn = element(by.id(&#39;samplejsonpbtn&#39;));&#A;  var invalidJsonpBtn = element(by.id(&#39;invalidjsonpbtn&#39;));&#A;&#A;  it(&#39;should make an xhr GET request&#39;, function() {&#A;    sampleGetBtn.click();&#A;    fetchBtn.click();&#A;    expect(status.getText()).toMatch(&#39;200&#39;);&#A;    expect(data.getText()).toMatch(/Hello, \$http!/);&#A;  });&#A;&#A;// Commented out due to flakes. See https://github.com/angular/angular.js/issues/9185&#A;// it(&#39;should make a JSONP request to angularjs.org&#39;, function() {&#A;//   sampleJsonpBtn.click();&#A;//   fetchBtn.click();&#A;//   expect(status.getText()).toMatch(&#39;200&#39;);&#A;//   expect(data.getText()).toMatch(/Super Hero!/);&#A;// });&#A;&#A;  it(&#39;should make JSONP request to invalid URL and invoke the error handler&#39;,&#A;      function() {&#A;    invalidJsonpBtn.click();&#A;    fetchBtn.click();&#A;    expect(status.getText()).toMatch(&#39;0&#39;);&#A;    expect(data.getText()).toMatch(&#39;Request failed&#39;);&#A;  });&#A;&lt;/file&gt;&#A;&lt;/example&gt;

					Alias: extend.config&gt;?
					StartLine: 9897
					EndLine: 9902
					NodeType: Object

					Alias: serverRequest(config)
					StartLine: 9909
					EndLine: 9928
					NodeType: Function

						Alias: forEach&gt;?(value,header)
						StartLine: 9915
						EndLine: 9919
						NodeType: AnonymousFunction

					Alias: forEach&gt;?(interceptor)
					StartLine: 9934
					EndLine: 9941
					NodeType: AnonymousFunction
					Comment: apply interceptors

					Alias: success(fn)
					StartLine: 9950
					EndLine: 9957
					NodeType: Function

						Alias: then&gt;?(response)
						StartLine: 9953
						EndLine: 9955
						NodeType: AnonymousFunction

					Alias: error(fn)
					StartLine: 9959
					EndLine: 9966
					NodeType: Function

						Alias: then&gt;?(response)
						StartLine: 9962
						EndLine: 9964
						NodeType: AnonymousFunction

					Alias: transformResponse(response)
					StartLine: 9970
					EndLine: 9981
					NodeType: Function
					Comment: make a copy since the response must be cacheable

					Alias: executeHeaderFns(headers,config)
					StartLine: 9983
					EndLine: 9998
					NodeType: Function

						Alias: forEach&gt;?(headerFn,header)
						StartLine: 9986
						EndLine: 9995
						NodeType: AnonymousFunction

					Alias: mergeHeaders(config)
					StartLine: 10000
					EndLine: 10023
					NodeType: Function

				Alias: createShortMethods(names)
				StartLine: 10134
				EndLine: 10143
				NodeType: Function

					Alias: forEach&gt;?(name)
					StartLine: 10135
					EndLine: 10142
					NodeType: AnonymousFunction

						Alias: name(url,config)
						StartLine: 10136
						EndLine: 10141
						NodeType: Function

							Alias: extend.$http&gt;?&gt;?
							StartLine: 10137
							EndLine: 10140
							NodeType: Object

				Alias: createShortMethodsWithData(name)
				StartLine: 10146
				EndLine: 10156
				NodeType: Function

					Alias: forEach&gt;?(name)
					StartLine: 10147
					EndLine: 10155
					NodeType: AnonymousFunction

						Alias: name(url,data,config)
						StartLine: 10148
						EndLine: 10154
						NodeType: Function

							Alias: extend.$http&gt;?&gt;?
							StartLine: 10149
							EndLine: 10153
							NodeType: Object

				Alias: sendReq(config,reqData)
				StartLine: 10165
				EndLine: 10275
				NodeType: Function
				Comment: *&#A;     * Makes the request.&#A;     *&#A;     * !!! ACCESSES CLOSURE VARS:&#A;     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests

					Alias: done(status,response,…atusText)
					StartLine: 10228
					EndLine: 10248
					NodeType: Function
					Comment: *&#A;       * Callback registered to $httpBackend():&#A;       *  - caches the response if desired&#A;       *  - resolves the raw $http promise&#A;       *  - calls $apply

						Alias: resolveHttpPromise()
						StartLine: 10238
						EndLine: 10240
						NodeType: Function

					Alias: resolvePromise(response,status,…atusText)
					StartLine: 10254
					EndLine: 10265
					NodeType: Function
					Comment: *&#A;       * Resolves the raw $http promise.&#A;       &#D;&#A; normalize internal statuses to 0

						Alias: ?
						StartLine: 10258
						EndLine: 10264
						NodeType: Object

					Alias: resolvePromiseWithResult(result)
					StartLine: 10267
					EndLine: 10269
					NodeType: Function

					Alias: removePendingReq()
					StartLine: 10271
					EndLine: 10274
					NodeType: Function

				Alias: buildUrl(url,serializedParams)
				StartLine: 10278
				EndLine: 10283
				NodeType: Function

		Alias: createXhr()
		StartLine: 10287
		EndLine: 10289
		NodeType: Function

		Alias: $HttpBackendProvider()
		StartLine: 10307
		EndLine: 10311
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $httpBackend&#A; * @requires $window&#A; * @requires $document&#A; *&#A; * @description&#A; * HTTP backend used by the {@link ng.$http service} that delegates to&#A; * XMLHttpRequest object or JSONP and deals with browser incompatibilities.&#A; *&#A; * You should never need to use this service directly, instead use the higher-level abstractions:&#A; * {@link ng.$http $http} or {@link ngResource.$resource $resource}.&#A; *&#A; * During testing this implementation is swapped with {@link ngMock.$httpBackend mock&#A; * $httpBackend} which can be trained with responses.

			Alias: ?($browser,$window…document)
			StartLine: 10308
			EndLine: 10310
			NodeType: AnonymousFunction

		Alias: createHttpBackend($browser,createX…Document)
		StartLine: 10313
		EndLine: 10458
		NodeType: Function
		Comment: TODO(vojta): fix the signature

			Alias: ?(method,url,post,…onseType)
			StartLine: 10315
			EndLine: 10421
			NodeType: AnonymousFunction

				Alias: callbackId(data)
				StartLine: 10321
				EndLine: 10324
				NodeType: Function

				Alias: jsonpReq.jsonpDone&gt;?(status,text)
				StartLine: 10327
				EndLine: 10330
				NodeType: AnonymousFunction

				Alias: forEach&gt;?(value,key)
				StartLine: 10336
				EndLine: 10340
				NodeType: AnonymousFunction

				Alias: requestLoaded()
				StartLine: 10342
				EndLine: 10364
				NodeType: Function

				Alias: requestError()
				StartLine: 10366
				EndLine: 10370
				NodeType: Function
				Comment: The response is always empty&#D;&#A; See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error

				Alias: timeoutRequest()
				StartLine: 10406
				EndLine: 10409
				NodeType: Function

				Alias: completeRequest(callback,status,…atusText)
				StartLine: 10411
				EndLine: 10420
				NodeType: Function
				Comment: cancel timeout and subsequent timeout promise resolution

			Alias: jsonpReq(url,callbackId,done)
			StartLine: 10423
			EndLine: 10457
			NodeType: Function
			Comment: we can&#39;t use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:&#D;&#A; - fetches local scripts via XHR and evals them&#D;&#A; - adds and immediately removes script elements from the document

				Alias: callback(event)
				StartLine: 10432
				EndLine: 10451
				NodeType: Function

					Alias: event
					StartLine: 10442
					EndLine: 10442
					NodeType: Object

		Alias: throwNoconcat(text)
		StartLine: 10461
		EndLine: 10466
		NodeType: Function

		Alias: interr(text,err)
		StartLine: 10468
		EndLine: 10470
		NodeType: Function

		Alias: $InterpolateProvider()
		StartLine: 10507
		EndLine: 10808
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $interpolateProvider&#A; *&#A; * @description&#A; *&#A; * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.&#A; *&#A; * @example&#A;&lt;example module=&quot;customInterpolationApp&quot;&gt;&#A;&lt;file name=&quot;index.html&quot;&gt;&#A;&lt;script&gt;&#A;  var customInterpolationApp = angular.module(&#39;customInterpolationApp&#39;, []);&#A;&#A;  customInterpolationApp.config(function($interpolateProvider) {&#A;    $interpolateProvider.startSymbol(&#39;//&#39;);&#A;    $interpolateProvider.endSymbol(&#39;//&#39;);&#A;  });&#A;&#A;&#A;  customInterpolationApp.controller(&#39;DemoController&#39;, function() {&#A;      this.label = &quot;This binding is brought you by // interpolation symbols.&quot;;&#A;  });&#A;&lt;/script&gt;&#A;&lt;div ng-app=&quot;App&quot; ng-controller=&quot;DemoController as demo&quot;&gt;&#A;    //demo.label//&#A;&lt;/div&gt;&#A;&lt;/file&gt;&#A;&lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;  it(&#39;should interpolate binding with custom symbols&#39;, function() {&#A;    expect(element(by.binding(&#39;demo.label&#39;)).getText()).toBe(&#39;This binding is brought you by // interpolation symbols.&#39;);&#A;  });&#A;&lt;/file&gt;&#A;&lt;/example&gt;

			Alias: startSymbol(value)
			StartLine: 10520
			EndLine: 10527
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $interpolateProvider#startSymbol&#A;   * @description&#A;   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.&#A;   *&#A;   * @param {string=} value new value to set the starting symbol to.&#A;   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.

			Alias: endSymbol(value)
			StartLine: 10538
			EndLine: 10545
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $interpolateProvider#endSymbol&#A;   * @description&#A;   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.&#A;   *&#A;   * @param {string=} value new value to set the ending symbol to.&#A;   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.

			Alias: ?($parse,$exceptio…ler,$sce)
			StartLine: 10548
			EndLine: 10807
			NodeType: AnonymousFunction

				Alias: escape(ch)
				StartLine: 10554
				EndLine: 10556
				NodeType: Function

				Alias: unescapeText(text)
				StartLine: 10558
				EndLine: 10561
				NodeType: Function

				Alias: stringify(value)
				StartLine: 10563
				EndLine: 10578
				NodeType: Function
				Comment: null || undefined

				Alias: $interpolate(text,mustHaveExp…rNothing)
				StartLine: 10674
				EndLine: 10772
				NodeType: Function
				Comment: *&#A;     * @ngdoc service&#A;     * @name $interpolate&#A;     * @kind function&#A;     *&#A;     * @requires $parse&#A;     * @requires $sce&#A;     *&#A;     * @description&#A;     *&#A;     * Compiles a string with markup into an interpolation function. This service is used by the&#A;     * HTML {@link ng.$compile $compile} service for data binding. See&#A;     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the&#A;     * interpolation markup.&#A;     *&#A;     *&#A;     * ```js&#A;     *   var $interpolate = ...; // injected&#A;     *   var exp = $interpolate(&#39;Hello {{name | uppercase}}!&#39;);&#A;     *   expect(exp({name:&#39;Angular&#39;}).toEqual(&#39;Hello ANGULAR!&#39;);&#A;     * ```&#A;     *&#A;     * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is&#A;     * `true`, the interpolation function will return `undefined` unless all embedded expressions&#A;     * evaluate to a value other than `undefined`.&#A;     *&#A;     * ```js&#A;     *   var $interpolate = ...; // injected&#A;     *   var context = {greeting: &#39;Hello&#39;, name: undefined };&#A;     *&#A;     *   // default &quot;forgiving&quot; mode&#A;     *   var exp = $interpolate(&#39;{{greeting}} {{name}}!&#39;);&#A;     *   expect(exp(context)).toEqual(&#39;Hello !&#39;);&#A;     *&#A;     *   // &quot;allOrNothing&quot; mode&#A;     *   exp = $interpolate(&#39;{{greeting}} {{name}}!&#39;, false, null, true);&#A;     *   expect(exp(context)).toBeUndefined();&#A;     *   context.name = &#39;Angular&#39;;&#A;     *   expect(exp(context)).toEqual(&#39;Hello Angular!&#39;);&#A;     * ```&#A;     *&#A;     * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.&#A;     *&#A;     * ####Escaped Interpolation&#A;     * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers&#A;     * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).&#A;     * It will be rendered as a regular start/end marker, and will not be interpreted as an expression&#A;     * or binding.&#A;     *&#A;     * This enables web-servers to prevent script injection attacks and defacing attacks, to some&#A;     * degree, while also enabling code examples to work without relying on the&#A;     * {@link ng.directive:ngNonBindable ngNonBindable} directive.&#A;     *&#A;     * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,&#A;     * replacing angle brackets (&amp;lt;, &amp;gt;) with &amp;amp;lt; and &amp;amp;gt; respectively, and replacing all&#A;     * interpolation start/end markers with their escaped counterparts.**&#A;     *&#A;     * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered&#A;     * output when the $interpolate service processes the text. So, for HTML elements interpolated&#A;     * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter&#A;     * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,&#A;     * this is typically useful only when user-data is used in rendering a template from the server, or&#A;     * when otherwise untrusted data is used by a directive.&#A;     *&#A;     * &lt;example&gt;&#A;     *  &lt;file name=&quot;index.html&quot;&gt;&#A;     *    &lt;div ng-init=&quot;username=&#39;A user&#39;&quot;&gt;&#A;     *      &lt;p ng-init=&quot;apptitle=&#39;Escaping demo&#39;&quot;&gt;{{apptitle}}: \{\{ username = &quot;defaced value&quot;; \}\}&#A;     *        &lt;/p&gt;&#A;     *      &lt;p&gt;&lt;strong&gt;{{username}}&lt;/strong&gt; attempts to inject code which will deface the&#A;     *        application, but fails to accomplish their task, because the server has correctly&#A;     *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)&#A;     *        characters.&lt;/p&gt;&#A;     *      &lt;p&gt;Instead, the result of the attempted script injection is visible, and can be removed&#A;     *        from the database by an administrator.&lt;/p&gt;&#A;     *    &lt;/div&gt;&#A;     *  &lt;/file&gt;&#A;     * &lt;/example&gt;&#A;     *&#A;     * @param {string} text The text with markup to interpolate.&#A;     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have&#A;     *    embedded expression in order to return an interpolation function. Strings with no&#A;     *    embedded expression will return null for the interpolation function.&#A;     * @param {string=} trustedContext when provided, the returned function passes the interpolated&#A;     *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,&#A;     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that&#A;     *    provides Strict Contextual Escaping for details.&#A;     * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined&#A;     *    unless all embedded expressions evaluate to a value other than `undefined`.&#A;     * @returns {function(context)} an interpolation function which is used to compute the&#A;     *    interpolated string. The function has these parameters:&#A;     *&#A;     * - `context`: evaluation context for all expressions embedded in the interpolated text

					Alias: compute(values)
					StartLine: 10718
					EndLine: 10724
					NodeType: Function

					Alias: getValue(value)
					StartLine: 10726
					EndLine: 10730
					NodeType: Function

					Alias: interpolationFn(context)
					StartLine: 10732
					EndLine: 10747
					NodeType: Function

					Alias: extend&gt;?
					StartLine: 10747
					EndLine: 10761
					NodeType: Object
					Comment: all of these properties are undocumented for now&#D;&#A;just for compatibility with regular watchers created via $watch

						Alias: $$watchDelegate(scope,listener)
						StartLine: 10751
						EndLine: 10760
						NodeType: Function

							Alias: interpolateFnWatcher(values,oldValues)
							StartLine: 10753
							EndLine: 10759
							NodeType: Function

					Alias: parseStringifyInterceptor(value)
					StartLine: 10764
					EndLine: 10771
					NodeType: Function

				Alias: startSymbol()
				StartLine: 10786
				EndLine: 10788
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $interpolate#startSymbol&#A;     * @description&#A;     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.&#A;     *&#A;     * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change&#A;     * the symbol.&#A;     *&#A;     * @returns {string} start symbol.

				Alias: endSymbol()
				StartLine: 10802
				EndLine: 10804
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $interpolate#endSymbol&#A;     * @description&#A;     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.&#A;     *&#A;     * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change&#A;     * the symbol.&#A;     *&#A;     * @returns {string} end symbol.

		Alias: $IntervalProvider()
		StartLine: 10810
		EndLine: 10998
		NodeType: Function

			Alias: ?($rootScope,$window,$q,$$q)
			StartLine: 10812
			EndLine: 10997
			NodeType: AnonymousFunction

				Alias: interval(fn,delay,count,i…okeApply)
				StartLine: 10941
				EndLine: 10973
				NodeType: Function
				Comment: *&#A;      * @ngdoc service&#A;      * @name $interval&#A;      *&#A;      * @description&#A;      * Angular&#39;s wrapper for `window.setInterval`. The `fn` function is executed every `delay`&#A;      * milliseconds.&#A;      *&#A;      * The return value of registering an interval function is a promise. This promise will be&#A;      * notified upon each tick of the interval, and will be resolved after `count` iterations, or&#A;      * run indefinitely if `count` is not defined. The value of the notification will be the&#A;      * number of iterations that have run.&#A;      * To cancel an interval, call `$interval.cancel(promise)`.&#A;      *&#A;      * In tests you can use {@link ngMock.$interval#flush `$interval.flush(millis)`} to&#A;      * move forward by `millis` milliseconds and trigger any functions scheduled to run in that&#A;      * time.&#A;      *&#A;      * &lt;div class=&quot;alert alert-warning&quot;&gt;&#A;      * **Note**: Intervals created by this service must be explicitly destroyed when you are finished&#A;      * with them.  In particular they are not automatically destroyed when a controller&#39;s scope or a&#A;      * directive&#39;s element are destroyed.&#A;      * You should take this into consideration and make sure to always cancel the interval at the&#A;      * appropriate moment.  See the example below for more details on how and when to do this.&#A;      * &lt;/div&gt;&#A;      *&#A;      * @param {function()} fn A function that should be called repeatedly.&#A;      * @param {number} delay Number of milliseconds between each function call.&#A;      * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat&#A;      *   indefinitely.&#A;      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise&#A;      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.&#A;      * @param {...*=} Pass additional parameters to the executed function.&#A;      * @returns {promise} A promise which will be notified on each iteration.&#A;      *&#A;      * @example&#A;      * &lt;example module=&quot;intervalExample&quot;&gt;&#A;      * &lt;file name=&quot;index.html&quot;&gt;&#A;      *   &lt;script&gt;&#A;      *     angular.module(&#39;intervalExample&#39;, [])&#A;      *       .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, &#39;$interval&#39;,&#A;      *         function($scope, $interval) {&#A;      *           $scope.format = &#39;M/d/yy h:mm:ss a&#39;;&#A;      *           $scope.blood_1 = 100;&#A;      *           $scope.blood_2 = 120;&#A;      *&#A;      *           var stop;&#A;      *           $scope.fight = function() {&#A;      *             // Don&#39;t start a new fight if we are already fighting&#A;      *             if ( angular.isDefined(stop) ) return;&#A;      *&#A;      *             stop = $interval(function() {&#A;      *               if ($scope.blood_1 &gt; 0 &amp;&amp; $scope.blood_2 &gt; 0) {&#A;      *                 $scope.blood_1 = $scope.blood_1 - 3;&#A;      *                 $scope.blood_2 = $scope.blood_2 - 4;&#A;      *               } else {&#A;      *                 $scope.stopFight();&#A;      *               }&#A;      *             }, 100);&#A;      *           };&#A;      *&#A;      *           $scope.stopFight = function() {&#A;      *             if (angular.isDefined(stop)) {&#A;      *               $interval.cancel(stop);&#A;      *               stop = undefined;&#A;      *             }&#A;      *           };&#A;      *&#A;      *           $scope.resetFight = function() {&#A;      *             $scope.blood_1 = 100;&#A;      *             $scope.blood_2 = 120;&#A;      *           };&#A;      *&#A;      *           $scope.$on(&#39;$destroy&#39;, function() {&#A;      *             // Make sure that the interval is destroyed too&#A;      *             $scope.stopFight();&#A;      *           });&#A;      *         }])&#A;      *       // Register the &#39;myCurrentTime&#39; directive factory method.&#A;      *       // We inject $interval and dateFilter service since the factory method is DI.&#A;      *       .directive(&#39;myCurrentTime&#39;, [&#39;$interval&#39;, &#39;dateFilter&#39;,&#A;      *         function($interval, dateFilter) {&#A;      *           // return the directive link function. (compile function not needed)&#A;      *           return function(scope, element, attrs) {&#A;      *             var format,  // date format&#A;      *                 stopTime; // so that we can cancel the time updates&#A;      *&#A;      *             // used to update the UI&#A;      *             function updateTime() {&#A;      *               element.text(dateFilter(new Date(), format));&#A;      *             }&#A;      *&#A;      *             // watch the expression, and update the UI on change.&#A;      *             scope.$watch(attrs.myCurrentTime, function(value) {&#A;      *               format = value;&#A;      *               updateTime();&#A;      *             });&#A;      *&#A;      *             stopTime = $interval(updateTime, 1000);&#A;      *&#A;      *             // listen on DOM destroy (removal) event, and cancel the next UI update&#A;      *             // to prevent updating time after the DOM element was removed.&#A;      *             element.on(&#39;$destroy&#39;, function() {&#A;      *               $interval.cancel(stopTime);&#A;      *             });&#A;      *           }&#A;      *         }]);&#A;      *   &lt;/script&gt;&#A;      *&#A;      *   &lt;div&gt;&#A;      *     &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;      *       &lt;label&gt;Date format: &lt;input ng-model=&quot;format&quot;&gt;&lt;/label&gt; &lt;hr/&gt;&#A;      *       Current time is: &lt;span my-current-time=&quot;format&quot;&gt;&lt;/span&gt;&#A;      *       &lt;hr/&gt;&#A;      *       Blood 1 : &lt;font color=&#39;red&#39;&gt;{{blood_1}}&lt;/font&gt;&#A;      *       Blood 2 : &lt;font color=&#39;red&#39;&gt;{{blood_2}}&lt;/font&gt;&#A;      *       &lt;button type=&quot;button&quot; data-ng-click=&quot;fight()&quot;&gt;Fight&lt;/button&gt;&#A;      *       &lt;button type=&quot;button&quot; data-ng-click=&quot;stopFight()&quot;&gt;StopFight&lt;/button&gt;&#A;      *       &lt;button type=&quot;button&quot; data-ng-click=&quot;resetFight()&quot;&gt;resetFight&lt;/button&gt;&#A;      *     &lt;/div&gt;&#A;      *   &lt;/div&gt;&#A;      *&#A;      * &lt;/file&gt;&#A;      * &lt;/example&gt;

					Alias: tick()
					StartLine: 10957
					EndLine: 10968
					NodeType: Function

				Alias: cancel(promise)
				StartLine: 10986
				EndLine: 10994
				NodeType: Function
				Comment: *&#A;      * @ngdoc method&#A;      * @name $interval#cancel&#A;      *&#A;      * @description&#A;      * Cancels a task associated with the `promise`.&#A;      *&#A;      * @param {promise} promise returned by the `$interval` function.&#A;      * @returns {boolean} Returns `true` if the task was successfully canceled.

		Alias: $LocaleProvider()
		StartLine: 11010
		EndLine: 11078
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $locale&#A; *&#A; * @description&#A; * $locale service provides localization rules for various Angular components. As of right now the&#A; * only public api is:&#A; *&#A; * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)

			Alias: $get()
			StartLine: 11011
			EndLine: 11077
			NodeType: Function

				Alias: ?
				StartLine: 11012
				EndLine: 11076
				NodeType: Object

					Alias: NUMBER_FORMATS
					StartLine: 11015
					EndLine: 11042
					NodeType: Object

						Alias: ?
						StartLine: 11019
						EndLine: 11029
						NodeType: Object
						Comment: Decimal Pattern

						Alias: ?
						StartLine: 11029
						EndLine: 11039
						NodeType: Object
						Comment: Currency Pattern

					Alias: DATETIME_FORMATS
					StartLine: 11044
					EndLine: 11068
					NodeType: Object

					Alias: pluralCat(num)
					StartLine: 11070
					EndLine: 11075
					NodeType: Function

		Alias: DEFAULT_PORTS
		StartLine: 11081
		EndLine: 11081
		NodeType: Object

		Alias: encodePath(path)
		StartLine: 11091
		EndLine: 11100
		NodeType: Function
		Comment: *&#A; * Encode path using encodeUriSegment, ignoring forward slashes&#A; *&#A; * @param {string} path Path to encode&#A; * @returns {string}

		Alias: parseAbsoluteUrl(absoluteUrl,locationObj)
		StartLine: 11102
		EndLine: 11108
		NodeType: Function

		Alias: parseAppUrl(relativeUrl,locationObj)
		StartLine: 11111
		EndLine: 11126
		NodeType: Function

		Alias: beginsWith(begin,whole)
		StartLine: 11136
		EndLine: 11140
		NodeType: Function
		Comment: *&#A; *&#A; * @param {string} begin&#A; * @param {string} whole&#A; * @returns {string} returns text from whole after begin or undefined if it does not begin with&#A; *                   expected string.

		Alias: stripHash(url)
		StartLine: 11143
		EndLine: 11146
		NodeType: Function

		Alias: trimEmptyHash(url)
		StartLine: 11148
		EndLine: 11150
		NodeType: Function

		Alias: stripFile(url)
		StartLine: 11153
		EndLine: 11155
		NodeType: Function

		Alias: serverBase(url)
		StartLine: 11158
		EndLine: 11160
		NodeType: Function
		Comment: return the server only (scheme://host:port)

		Alias: LocationHtml5Url(appBase,basePrefix)
		StartLine: 11171
		EndLine: 11238
		NodeType: Function
		Comment: *&#A; * LocationHtml5Url represents an url&#A; * This object is exposed as $location service when HTML5 mode is enabled and supported&#A; *&#A; * @constructor&#A; * @param {string} appBase application base URL&#A; * @param {string} basePrefix url path prefix

			Alias: $$parse(url)
			StartLine: 11183
			EndLine: 11197
			NodeType: Function
			Comment: *&#A;   * Parse given html5 (regular) url string into properties&#A;   * @param {string} url HTML5 url&#A;   * @private

			Alias: $$compose()
			StartLine: 11203
			EndLine: 11209
			NodeType: Function
			Comment: *&#A;   * Compose url and update `absUrl` property&#A;   * @private

			Alias: $$parseLinkUrl(url,relHref)
			StartLine: 11211
			EndLine: 11237
			NodeType: Function

		Alias: LocationHashbangUrl(appBase,hashPrefix)
		StartLine: 11250
		EndLine: 11342
		NodeType: Function
		Comment: *&#A; * LocationHashbangUrl represents url&#A; * This object is exposed as $location service when developer doesn&#39;t opt into html5 mode.&#A; * It also serves as the base class for html5 mode fallback on legacy browsers.&#A; *&#A; * @constructor&#A; * @param {string} appBase application base URL&#A; * @param {string} hashPrefix hashbang prefix

			Alias: $$parse(url)
			StartLine: 11261
			EndLine: 11321
			NodeType: Function
			Comment: *&#A;   * Parse given hashbang url into properties&#A;   * @param {string} url Hashbang url&#A;   * @private

				Alias: removeWindowsDriveName(path,url,base)
				StartLine: 11299
				EndLine: 11320
				NodeType: Function
				Comment: * In Windows, on an anchor node on documents loaded from&#A;     * the filesystem, the browser will return a pathname&#A;     * prefixed with the drive name (&#39;/C:/path&#39;) when a&#A;     * pathname without a drive is set:&#A;     *  * a.setAttribute(&#39;href&#39;, &#39;/foo&#39;)&#A;     *   * a.pathname === &#39;/C:/foo&#39; //true&#A;     *&#A;     * Inside of Angular, we&#39;re always using pathnames that&#A;     * do not include drive names for routing.&#A;     &#D;&#A;&#A;      Matches paths for file protocol on windows,&#A;      such as /C:/foo/bar, and captures only /foo/bar.

			Alias: $$compose()
			StartLine: 11327
			EndLine: 11333
			NodeType: Function
			Comment: *&#A;   * Compose hashbang url and update `absUrl` property&#A;   * @private

			Alias: $$parseLinkUrl(url,relHref)
			StartLine: 11335
			EndLine: 11341
			NodeType: Function

		Alias: LocationHashbangInHtml5Url(appBase,hashPrefix)
		StartLine: 11354
		EndLine: 11393
		NodeType: Function
		Comment: *&#A; * LocationHashbangUrl represents url&#A; * This object is exposed as $location service when html5 history api is enabled but the browser&#A; * does not support it.&#A; *&#A; * @constructor&#A; * @param {string} appBase application base URL&#A; * @param {string} hashPrefix hashbang prefix

			Alias: $$parseLinkUrl(url,relHref)
			StartLine: 11360
			EndLine: 11382
			NodeType: Function

			Alias: $$compose()
			StartLine: 11384
			EndLine: 11391
			NodeType: Function

		Alias: locationPrototype
		StartLine: 11396
		EndLine: 11677
		NodeType: Object

			Alias: url(url)
			StartLine: 11452
			EndLine: 11463
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $location#url&#A;   *&#A;   * @description&#A;   * This method is getter / setter.&#A;   *&#A;   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.&#A;   *&#A;   * Change path, search and hash, when called with parameter and return `$location`.&#A;   *&#A;   *&#A;   * ```js&#A;   * // given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#A;   * var url = $location.url();&#A;   * // =&gt; &quot;/some/path?foo=bar&amp;baz=xoxo&quot;&#A;   * ```&#A;   *&#A;   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)&#A;   * @return {string} url

			Alias: locationGetterSetter.path&gt;?(path)
			StartLine: 11557
			EndLine: 11560
			NodeType: AnonymousFunction
			Comment: *&#A;   * @ngdoc method&#A;   * @name $location#path&#A;   *&#A;   * @description&#A;   * This method is getter / setter.&#A;   *&#A;   * Return path of current url when called without any parameter.&#A;   *&#A;   * Change path when called with parameter and return `$location`.&#A;   *&#A;   * Note: Path should always begin with forward slash (/), this method will add the forward slash&#A;   * if it is missing.&#A;   *&#A;   *&#A;   * ```js&#A;   * // given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#A;   * var path = $location.path();&#A;   * // =&gt; &quot;/some/path&quot;&#A;   * ```&#A;   *&#A;   * @param {(string|number)=} path New path&#A;   * @return {string} path

			Alias: search(search,paramValue)
			StartLine: 11607
			EndLine: 11638
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $location#search&#A;   *&#A;   * @description&#A;   * This method is getter / setter.&#A;   *&#A;   * Return search part (as object) of current url when called without any parameter.&#A;   *&#A;   * Change search part when called with parameter and return `$location`.&#A;   *&#A;   *&#A;   * ```js&#A;   * // given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#A;   * var searchObject = $location.search();&#A;   * // =&gt; {foo: &#39;bar&#39;, baz: &#39;xoxo&#39;}&#A;   *&#A;   * // set foo to &#39;yipee&#39;&#A;   * $location.search(&#39;foo&#39;, &#39;yipee&#39;);&#A;   * // $location.search() =&gt; {foo: &#39;yipee&#39;, baz: &#39;xoxo&#39;}&#A;   * ```&#A;   *&#A;   * @param {string|Object.&lt;string&gt;|Object.&lt;Array.&lt;string&gt;&gt;} search New search params - string or&#A;   * hash object.&#A;   *&#A;   * When called with a single argument the method acts as a setter, setting the `search` component&#A;   * of `$location` to the specified value.&#A;   *&#A;   * If the argument is a hash object containing an array of values, these values will be encoded&#A;   * as duplicate search parameters in the url.&#A;   *&#A;   * @param {(string|Number|Array&lt;string&gt;|boolean)=} paramValue If `search` is a string or number, then `paramValue`&#A;   * will override only a single search property.&#A;   *&#A;   * If `paramValue` is an array, it will override the property of the `search` component of&#A;   * `$location` specified via the first argument.&#A;   *&#A;   * If `paramValue` is `null`, the property specified via the first argument will be deleted.&#A;   *&#A;   * If `paramValue` is `true`, the property specified via the first argument will be added with no&#A;   * value nor trailing equal sign.&#A;   *&#A;   * @return {Object} If called with no arguments returns the parsed `search` object. If called with&#A;   * one or more arguments returns `$location` object itself.

				Alias: forEach&gt;?(value,key)
				StartLine: 11618
				EndLine: 11620
				NodeType: AnonymousFunction
				Comment: remove object undefined or null properties

			Alias: locationGetterSetter.hash&gt;?(hash)
			StartLine: 11661
			EndLine: 11663
			NodeType: AnonymousFunction
			Comment: *&#A;   * @ngdoc method&#A;   * @name $location#hash&#A;   *&#A;   * @description&#A;   * This method is getter / setter.&#A;   *&#A;   * Return hash fragment when called without any parameter.&#A;   *&#A;   * Change hash fragment when called with parameter and return `$location`.&#A;   *&#A;   *&#A;   * ```js&#A;   * // given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo#hashValue&#A;   * var hash = $location.hash();&#A;   * // =&gt; &quot;hashValue&quot;&#A;   * ```&#A;   *&#A;   * @param {(string|number)=} hash New hash fragment&#A;   * @return {string} hash

			Alias: replace()
			StartLine: 11673
			EndLine: 11676
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $location#replace&#A;   *&#A;   * @description&#A;   * If called, all changes to $location during current `$digest` will be replacing current history&#A;   * record, instead of adding new one.

		Alias: forEach&gt;?(Location)
		StartLine: 11679
		EndLine: 11717
		NodeType: AnonymousFunction

			Alias: state(state)
			StartLine: 11701
			EndLine: 11716
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $location#state&#A;   *&#A;   * @description&#A;   * This method is getter / setter.&#A;   *&#A;   * Return the history state object when called without any parameter.&#A;   *&#A;   * Change the history state object when called with one parameter and return `$location`.&#A;   * The state object is later passed to `pushState` or `replaceState`.&#A;   *&#A;   * NOTE: This method is supported only in HTML5 mode and only in browsers supporting&#A;   * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support&#A;   * older browsers (like IE9 or Android &lt; 4.0), don&#39;t use this method.&#A;   *&#A;   * @param {object=} state State object for pushState or replaceState&#A;   * @return {object} state

		Alias: locationGetter(property)
		StartLine: 11720
		EndLine: 11724
		NodeType: Function

			Alias: ?()
			StartLine: 11721
			EndLine: 11723
			NodeType: AnonymousFunction

		Alias: locationGetterSetter(property,preprocess)
		StartLine: 11727
		EndLine: 11738
		NodeType: Function

			Alias: ?(value)
			StartLine: 11728
			EndLine: 11737
			NodeType: AnonymousFunction

		Alias: $LocationProvider()
		StartLine: 11773
		EndLine: 12052
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $locationProvider&#A; * @description&#A; * Use the `$locationProvider` to configure how the application deep linking paths are stored.

			Alias: html5Mode
			StartLine: 11775
			EndLine: 11779
			NodeType: Object

			Alias: hashPrefix(prefix)
			StartLine: 11788
			EndLine: 11795
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $locationProvider#hashPrefix&#A;   * @description&#A;   * @param {string=} prefix Prefix for hash part (containing path and search)&#A;   * @returns {*} current value if used as getter or itself (chaining) if used as setter

			Alias: html5Mode(mode)
			StartLine: 11816
			EndLine: 11838
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $locationProvider#html5Mode&#A;   * @description&#A;   * @param {(boolean|Object)=} mode If boolean, sets `html5Mode.enabled` to value.&#A;   *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to respective values. Supported&#A;   *   properties:&#A;   *   - **enabled** – `{boolean}` – (default: false) If true, will rely on `history.pushState` to&#A;   *     change urls where supported. Will fall back to hash-prefixed paths in browsers that do not&#A;   *     support `pushState`.&#A;   *   - **requireBase** - `{boolean}` - (default: `true`) When html5Mode is enabled, specifies&#A;   *     whether or not a &lt;base&gt; tag is required to be present. If `enabled` and `requireBase` are&#A;   *     true, and a base tag is not present, an error will be thrown when `$location` is injected.&#A;   *     See the {@link guide/$location $location guide for more information}&#A;   *   - **rewriteLinks** - `{boolean}` - (default: `true`) When html5Mode is enabled,&#A;   *     enables/disables url rewriting for relative links.&#A;   *&#A;   * @returns {Object} html5Mode object if used as getter or itself (chaining) if used as setter

			Alias: ?($rootScope,$brow…,$window)
			StartLine: 11880
			EndLine: 12051
			NodeType: AnonymousFunction

				Alias: setBrowserUrlWithFallback(url,replace,state)
				StartLine: 11905
				EndLine: 11922
				NodeType: Function

				Alias: on&gt;?(event)
				StartLine: 11924
				EndLine: 11966
				NodeType: AnonymousFunction
				Comment: TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)&#D;&#A; currently we open nice url link and redirect then

				Alias: onUrlChange&gt;?(newUrl,newState)
				StartLine: 11977
				EndLine: 12003
				NodeType: AnonymousFunction
				Comment: update $location when $browser url changes

					Alias: $evalAsync&gt;?()
					StartLine: 11978
					EndLine: 12001
					NodeType: AnonymousFunction

				Alias: $locationWatch()
				StartLine: 12006
				EndLine: 12043
				NodeType: Function
				Comment: update browser

					Alias: $evalAsync&gt;?()
					StartLine: 12017
					EndLine: 12036
					NodeType: AnonymousFunction

				Alias: afterLocationChange(oldUrl,oldState)
				StartLine: 12047
				EndLine: 12050
				NodeType: Function

		Alias: $LogProvider()
		StartLine: 12098
		EndLine: 12215
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $logProvider&#A; * @description&#A; * Use the `$logProvider` to configure how the application logs messages

			Alias: debugEnabled(flag)
			StartLine: 12109
			EndLine: 12116
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $logProvider#debugEnabled&#A;   * @description&#A;   * @param {boolean=} flag enable or disable debug level messages&#A;   * @returns {*} current value if used as getter or itself (chaining) if used as setter

			Alias: ?($window)
			StartLine: 12118
			EndLine: 12214
			NodeType: AnonymousFunction

				Alias: ?
				StartLine: 12119
				EndLine: 12172
				NodeType: Object
				Comment: *&#A;       * @ngdoc method&#A;       * @name $log#log&#A;       *&#A;       * @description&#A;       * Write a log message

					Alias: debug()
					StartLine: 12163
					EndLine: 12171
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $log#debug&#A;       *&#A;       * @description&#A;       * Write a debug message

						Alias: ?()
						StartLine: 12166
						EndLine: 12170
						NodeType: AnonymousFunction

				Alias: formatError(arg)
				StartLine: 12174
				EndLine: 12185
				NodeType: Function

				Alias: consoleLog(type)
				StartLine: 12187
				EndLine: 12213
				NodeType: Function

					Alias: ?()
					StartLine: 12199
					EndLine: 12205
					NodeType: AnonymousFunction

						Alias: forEach&gt;?(arg)
						StartLine: 12201
						EndLine: 12203
						NodeType: AnonymousFunction

					Alias: ?(arg1,arg2)
					StartLine: 12210
					EndLine: 12212
					NodeType: AnonymousFunction
					Comment: we are IE which either doesn&#39;t have window.console =&gt; this is noop and we do nothing,&#D;&#A; or we are IE where console.log doesn&#39;t have apply so we log at least first 2 args

		Alias: ensureSafeMemberName(name,fullExpression)
		StartLine: 12254
		EndLine: 12263
		NodeType: Function

		Alias: ensureSafeObject(obj,fullExpression)
		StartLine: 12265
		EndLine: 12290
		NodeType: Function
		Comment: nifty check if obj is Function that is fast and works across iframes and other contexts

		Alias: ensureSafeFunction(obj,fullExpression)
		StartLine: 12296
		EndLine: 12308
		NodeType: Function

		Alias: forEach&gt;?(operator)
		StartLine: 12311
		EndLine: 12311
		NodeType: AnonymousFunction

		Alias: ESCAPE
		StartLine: 12312
		EndLine: 12312
		NodeType: Object

		Alias: Lexer(options)
		StartLine: 12321
		EndLine: 12323
		NodeType: Function
		Comment: *&#A; * @constructor

		Alias: prototype
		StartLine: 12325
		EndLine: 12491
		NodeType: Object

			Alias: lex(text)
			StartLine: 12328
			EndLine: 12362
			NodeType: Function

			Alias: is(ch,chars)
			StartLine: 12364
			EndLine: 12366
			NodeType: Function

			Alias: peek(i)
			StartLine: 12368
			EndLine: 12371
			NodeType: Function

			Alias: isNumber(ch)
			StartLine: 12373
			EndLine: 12375
			NodeType: Function

			Alias: isWhitespace(ch)
			StartLine: 12377
			EndLine: 12381
			NodeType: Function
			Comment: IE treats non-breaking space as \u00A0

			Alias: isIdent(ch)
			StartLine: 12383
			EndLine: 12387
			NodeType: Function

			Alias: isExpOperator(ch)
			StartLine: 12389
			EndLine: 12391
			NodeType: Function

			Alias: throwError(error,start,end)
			StartLine: 12393
			EndLine: 12400
			NodeType: Function

			Alias: readNumber()
			StartLine: 12402
			EndLine: 12433
			NodeType: Function

				Alias: push&gt;?
				StartLine: 12427
				EndLine: 12432
				NodeType: Object

			Alias: readIdent()
			StartLine: 12435
			EndLine: 12449
			NodeType: Function

				Alias: push&gt;?
				StartLine: 12444
				EndLine: 12448
				NodeType: Object

			Alias: readString(quote)
			StartLine: 12451
			EndLine: 12490
			NodeType: Function

		Alias: AST(lexer,options)
		StartLine: 12493
		EndLine: 12496
		NodeType: Function

		Alias: prototype
		StartLine: 12517
		EndLine: 12815
		NodeType: Object

			Alias: ast(text)
			StartLine: 12518
			EndLine: 12529
			NodeType: Function

			Alias: program()
			StartLine: 12531
			EndLine: 12540
			NodeType: Function

			Alias: expressionStatement()
			StartLine: 12542
			EndLine: 12544
			NodeType: Function

				Alias: ?
				StartLine: 12543
				EndLine: 12543
				NodeType: Object

			Alias: filterChain()
			StartLine: 12546
			EndLine: 12553
			NodeType: Function

			Alias: expression()
			StartLine: 12555
			EndLine: 12557
			NodeType: Function

			Alias: assignment()
			StartLine: 12559
			EndLine: 12565
			NodeType: Function

				Alias: result
				StartLine: 12562
				EndLine: 12562
				NodeType: Object

			Alias: ternary()
			StartLine: 12567
			EndLine: 12579
			NodeType: Function

				Alias: ?
				StartLine: 12575
				EndLine: 12575
				NodeType: Object

			Alias: logicalOR()
			StartLine: 12581
			EndLine: 12587
			NodeType: Function

			Alias: logicalAND()
			StartLine: 12589
			EndLine: 12595
			NodeType: Function

			Alias: equality()
			StartLine: 12597
			EndLine: 12604
			NodeType: Function

			Alias: relational()
			StartLine: 12606
			EndLine: 12613
			NodeType: Function

			Alias: additive()
			StartLine: 12615
			EndLine: 12622
			NodeType: Function

			Alias: multiplicative()
			StartLine: 12624
			EndLine: 12631
			NodeType: Function

			Alias: unary()
			StartLine: 12633
			EndLine: 12640
			NodeType: Function

				Alias: ?
				StartLine: 12636
				EndLine: 12636
				NodeType: Object

			Alias: primary()
			StartLine: 12642
			EndLine: 12676
			NodeType: Function

			Alias: filter(baseExpression)
			StartLine: 12678
			EndLine: 12687
			NodeType: Function

				Alias: result
				StartLine: 12680
				EndLine: 12680
				NodeType: Object

			Alias: parseArguments()
			StartLine: 12689
			EndLine: 12697
			NodeType: Function

			Alias: identifier()
			StartLine: 12699
			EndLine: 12705
			NodeType: Function

				Alias: ?
				StartLine: 12704
				EndLine: 12704
				NodeType: Object

			Alias: constant()
			StartLine: 12707
			EndLine: 12710
			NodeType: Function
			Comment: TODO check that it is a constant

				Alias: ?
				StartLine: 12709
				EndLine: 12709
				NodeType: Object

			Alias: arrayDeclaration()
			StartLine: 12712
			EndLine: 12726
			NodeType: Function

				Alias: ?
				StartLine: 12725
				EndLine: 12725
				NodeType: Object

			Alias: object()
			StartLine: 12728
			EndLine: 12752
			NodeType: Function

				Alias: ?
				StartLine: 12751
				EndLine: 12751
				NodeType: Object

			Alias: throwError(msg,token)
			StartLine: 12754
			EndLine: 12758
			NodeType: Function

			Alias: consume(e1)
			StartLine: 12760
			EndLine: 12770
			NodeType: Function

			Alias: peekToken()
			StartLine: 12772
			EndLine: 12777
			NodeType: Function

			Alias: peek(e1,e2,e3,e4)
			StartLine: 12779
			EndLine: 12781
			NodeType: Function

			Alias: peekAhead(i,e1,e2,e3,e4)
			StartLine: 12783
			EndLine: 12793
			NodeType: Function

			Alias: expect(e1,e2,e3,e4)
			StartLine: 12795
			EndLine: 12802
			NodeType: Function

			Alias: constants
			StartLine: 12808
			EndLine: 12814
			NodeType: Object
			Comment: `undefined` is not a constant, it is an identifier,&#A;   * but using it as an identifier is not supported

				Alias: &#39;true&#39;
				StartLine: 12809
				EndLine: 12809
				NodeType: Object

				Alias: &#39;false&#39;
				StartLine: 12810
				EndLine: 12810
				NodeType: Object

				Alias: &#39;null&#39;
				StartLine: 12811
				EndLine: 12811
				NodeType: Object

				Alias: &#39;undefined&#39;
				StartLine: 12812
				EndLine: 12812
				NodeType: Object

				Alias: &#39;this&#39;
				StartLine: 12813
				EndLine: 12813
				NodeType: Object

		Alias: ifDefined(v,d)
		StartLine: 12817
		EndLine: 12819
		NodeType: Function

		Alias: plusFn(l,r)
		StartLine: 12821
		EndLine: 12825
		NodeType: Function

		Alias: isStateless($filter,filterName)
		StartLine: 12827
		EndLine: 12830
		NodeType: Function

		Alias: findConstantAndWatchExpressions(ast,$filter)
		StartLine: 12832
		EndLine: 12934
		NodeType: Function

			Alias: forEach&gt;?(expr)
			StartLine: 12838
			EndLine: 12841
			NodeType: AnonymousFunction

			Alias: forEach&gt;?(expr)
			StartLine: 12887
			EndLine: 12893
			NodeType: AnonymousFunction

			Alias: forEach&gt;?(expr)
			StartLine: 12906
			EndLine: 12912
			NodeType: AnonymousFunction

			Alias: forEach&gt;?(property)
			StartLine: 12919
			EndLine: 12925
			NodeType: AnonymousFunction

		Alias: getInputs(body)
		StartLine: 12936
		EndLine: 12942
		NodeType: Function

		Alias: isAssignable(ast)
		StartLine: 12944
		EndLine: 12946
		NodeType: Function

		Alias: assignableAST(ast)
		StartLine: 12948
		EndLine: 12952
		NodeType: Function

			Alias: ?
			StartLine: 12950
			EndLine: 12950
			NodeType: Object

				Alias: right
				StartLine: 12950
				EndLine: 12950
				NodeType: Object

		Alias: isLiteral(ast)
		StartLine: 12954
		EndLine: 12960
		NodeType: Function

		Alias: isConstant(ast)
		StartLine: 12962
		EndLine: 12964
		NodeType: Function

		Alias: ASTCompiler(astBuilder,$filter)
		StartLine: 12966
		EndLine: 12969
		NodeType: Function

		Alias: prototype
		StartLine: 12971
		EndLine: 13432
		NodeType: Object

			Alias: compile(expression,expen…veChecks)
			StartLine: 12972
			EndLine: 13039
			NodeType: Function

				Alias: state
				StartLine: 12975
				EndLine: 12982
				NodeType: Object

					Alias: fn
					StartLine: 12979
					EndLine: 12979
					NodeType: Object

					Alias: assign
					StartLine: 12980
					EndLine: 12980
					NodeType: Object

				Alias: forEach&gt;?(watch,key)
				StartLine: 12995
				EndLine: 13004
				NodeType: AnonymousFunction

					Alias: fnKey
					StartLine: 12997
					EndLine: 12997
					NodeType: Object

			Alias: watchFns()
			StartLine: 13045
			EndLine: 13056
			NodeType: Function

				Alias: forEach&gt;?(name)
				StartLine: 13049
				EndLine: 13051
				NodeType: AnonymousFunction

			Alias: generateFunction(name,params)
			StartLine: 13058
			EndLine: 13063
			NodeType: Function

			Alias: filterPrefix()
			StartLine: 13065
			EndLine: 13073
			NodeType: Function

				Alias: forEach&gt;?(id,filter)
				StartLine: 13068
				EndLine: 13070
				NodeType: AnonymousFunction

			Alias: varsPrefix(section)
			StartLine: 13075
			EndLine: 13077
			NodeType: Function

			Alias: body(section)
			StartLine: 13079
			EndLine: 13081
			NodeType: Function

			Alias: recurse(ast,intoId,nameI…hIdCheck)
			StartLine: 13083
			EndLine: 13293
			NodeType: Function

				Alias: forEach&gt;?(expression,pos)
				StartLine: 13096
				EndLine: 13103
				NodeType: AnonymousFunction

					Alias: recurse&gt;?(expr)
					StartLine: 13097
					EndLine: 13097
					NodeType: AnonymousFunction

				Alias: recurse&gt;?(expr)
				StartLine: 13111
				EndLine: 13111
				NodeType: AnonymousFunction

				Alias: recurse&gt;?(expr)
				StartLine: 13117
				EndLine: 13117
				NodeType: AnonymousFunction

				Alias: recurse&gt;?(expr)
				StartLine: 13118
				EndLine: 13118
				NodeType: AnonymousFunction

				Alias: if_&gt;?()
				StartLine: 13150
				EndLine: 13159
				NodeType: AnonymousFunction

					Alias: if_&gt;?()
					StartLine: 13151
					EndLine: 13158
					NodeType: AnonymousFunction

				Alias: recurse&gt;?()
				StartLine: 13169
				EndLine: 13201
				NodeType: AnonymousFunction

					Alias: if_&gt;?()
					StartLine: 13170
					EndLine: 13200
					NodeType: AnonymousFunction

				Alias: forEach&gt;?(expr)
				StartLine: 13208
				EndLine: 13212
				NodeType: AnonymousFunction

				Alias: recurse&gt;?()
				StartLine: 13220
				EndLine: 13240
				NodeType: AnonymousFunction

					Alias: if_&gt;?()
					StartLine: 13221
					EndLine: 13239
					NodeType: AnonymousFunction

						Alias: forEach&gt;?(expr)
						StartLine: 13223
						EndLine: 13227
						NodeType: AnonymousFunction

							Alias: recurse&gt;?(argument)
							StartLine: 13224
							EndLine: 13226
							NodeType: AnonymousFunction

				Alias: recurse&gt;?()
				StartLine: 13249
				EndLine: 13257
				NodeType: AnonymousFunction

					Alias: if_&gt;?()
					StartLine: 13250
					EndLine: 13256
					NodeType: AnonymousFunction

				Alias: forEach&gt;?(expr)
				StartLine: 13261
				EndLine: 13265
				NodeType: AnonymousFunction

					Alias: recurse&gt;?(argument)
					StartLine: 13262
					EndLine: 13264
					NodeType: AnonymousFunction

				Alias: forEach&gt;?(property)
				StartLine: 13272
				EndLine: 13279
				NodeType: AnonymousFunction

					Alias: recurse&gt;?(expr)
					StartLine: 13273
					EndLine: 13278
					NodeType: AnonymousFunction

			Alias: getHasOwnProperty(element,property)
			StartLine: 13295
			EndLine: 13302
			NodeType: Function

			Alias: assign(id,value)
			StartLine: 13304
			EndLine: 13308
			NodeType: Function

			Alias: filter(filterName)
			StartLine: 13310
			EndLine: 13315
			NodeType: Function

			Alias: ifDefined(id,defaultValue)
			StartLine: 13317
			EndLine: 13319
			NodeType: Function

			Alias: plus(left,right)
			StartLine: 13321
			EndLine: 13323
			NodeType: Function

			Alias: return_(id)
			StartLine: 13325
			EndLine: 13327
			NodeType: Function

			Alias: if_(test,alternate,consequent)
			StartLine: 13329
			EndLine: 13343
			NodeType: Function

			Alias: not(expression)
			StartLine: 13345
			EndLine: 13347
			NodeType: Function

			Alias: notNull(expression)
			StartLine: 13349
			EndLine: 13351
			NodeType: Function

			Alias: nonComputedMember(left,right)
			StartLine: 13353
			EndLine: 13355
			NodeType: Function

			Alias: computedMember(left,right)
			StartLine: 13357
			EndLine: 13359
			NodeType: Function

			Alias: member(left,right,computed)
			StartLine: 13361
			EndLine: 13364
			NodeType: Function

			Alias: addEnsureSafeObject(item)
			StartLine: 13366
			EndLine: 13368
			NodeType: Function

			Alias: addEnsureSafeMemberName(item)
			StartLine: 13370
			EndLine: 13372
			NodeType: Function

			Alias: addEnsureSafeFunction(item)
			StartLine: 13374
			EndLine: 13376
			NodeType: Function

			Alias: ensureSafeObject(item)
			StartLine: 13378
			EndLine: 13380
			NodeType: Function

			Alias: ensureSafeMemberName(item)
			StartLine: 13382
			EndLine: 13384
			NodeType: Function

			Alias: ensureSafeFunction(item)
			StartLine: 13386
			EndLine: 13388
			NodeType: Function

			Alias: lazyRecurse(ast,intoId,nameI…hIdCheck)
			StartLine: 13390
			EndLine: 13395
			NodeType: Function

				Alias: ?()
				StartLine: 13392
				EndLine: 13394
				NodeType: AnonymousFunction

			Alias: lazyAssign(id,value)
			StartLine: 13397
			EndLine: 13402
			NodeType: Function

				Alias: ?()
				StartLine: 13399
				EndLine: 13401
				NodeType: AnonymousFunction

			Alias: stringEscapeFn(c)
			StartLine: 13406
			EndLine: 13408
			NodeType: Function

			Alias: escape(value)
			StartLine: 13410
			EndLine: 13419
			NodeType: Function

			Alias: nextId(skip,init)
			StartLine: 13421
			EndLine: 13427
			NodeType: Function

			Alias: current()
			StartLine: 13429
			EndLine: 13431
			NodeType: Function

		Alias: ASTInterpreter(astBuilder,$filter)
		StartLine: 13435
		EndLine: 13438
		NodeType: Function

		Alias: prototype
		StartLine: 13440
		EndLine: 13801
		NodeType: Object

			Alias: compile(expression,expen…veChecks)
			StartLine: 13441
			EndLine: 13487
			NodeType: Function

				Alias: forEach&gt;?(watch,key)
				StartLine: 13456
				EndLine: 13461
				NodeType: AnonymousFunction

				Alias: forEach&gt;?(expression)
				StartLine: 13464
				EndLine: 13466
				NodeType: AnonymousFunction

				Alias: assign(scope,value,locals)
				StartLine: 13477
				EndLine: 13479
				NodeType: Function

			Alias: recurse(ast,context,create)
			StartLine: 13489
			EndLine: 13607
			NodeType: Function

				Alias: forEach&gt;?(expr)
				StartLine: 13532
				EndLine: 13534
				NodeType: AnonymousFunction

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13563
				EndLine: 13569
				NodeType: AnonymousFunction

				Alias: forEach&gt;?(expr)
				StartLine: 13572
				EndLine: 13574
				NodeType: AnonymousFunction

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13575
				EndLine: 13581
				NodeType: AnonymousFunction

				Alias: forEach&gt;?(property)
				StartLine: 13584
				EndLine: 13590
				NodeType: AnonymousFunction

					Alias: push&gt;?
					StartLine: 13585
					EndLine: 13589
					NodeType: Object

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13591
				EndLine: 13597
				NodeType: AnonymousFunction

				Alias: ?(scope)
				StartLine: 13599
				EndLine: 13601
				NodeType: AnonymousFunction

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13603
				EndLine: 13605
				NodeType: AnonymousFunction

			Alias: &#39;unary+&#39;(argument,context)
			StartLine: 13609
			EndLine: 13619
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13610
				EndLine: 13618
				NodeType: AnonymousFunction

			Alias: &#39;unary-&#39;(argument,context)
			StartLine: 13620
			EndLine: 13630
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13621
				EndLine: 13629
				NodeType: AnonymousFunction

			Alias: &#39;unary!&#39;(argument,context)
			StartLine: 13631
			EndLine: 13636
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13632
				EndLine: 13635
				NodeType: AnonymousFunction

			Alias: &#39;binary+&#39;(left,right,context)
			StartLine: 13637
			EndLine: 13644
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13638
				EndLine: 13643
				NodeType: AnonymousFunction

			Alias: &#39;binary-&#39;(left,right,context)
			StartLine: 13645
			EndLine: 13652
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13646
				EndLine: 13651
				NodeType: AnonymousFunction

			Alias: &#39;binary*&#39;(left,right,context)
			StartLine: 13653
			EndLine: 13658
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13654
				EndLine: 13657
				NodeType: AnonymousFunction

			Alias: &#39;binary/&#39;(left,right,context)
			StartLine: 13659
			EndLine: 13664
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13660
				EndLine: 13663
				NodeType: AnonymousFunction

			Alias: &#39;binary%&#39;(left,right,context)
			StartLine: 13665
			EndLine: 13670
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13666
				EndLine: 13669
				NodeType: AnonymousFunction

			Alias: &#39;binary===&#39;(left,right,context)
			StartLine: 13671
			EndLine: 13676
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13672
				EndLine: 13675
				NodeType: AnonymousFunction

			Alias: &#39;binary!==&#39;(left,right,context)
			StartLine: 13677
			EndLine: 13682
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13678
				EndLine: 13681
				NodeType: AnonymousFunction

			Alias: &#39;binary==&#39;(left,right,context)
			StartLine: 13683
			EndLine: 13688
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13684
				EndLine: 13687
				NodeType: AnonymousFunction

			Alias: &#39;binary!=&#39;(left,right,context)
			StartLine: 13689
			EndLine: 13694
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13690
				EndLine: 13693
				NodeType: AnonymousFunction

			Alias: &#39;binary&lt;&#39;(left,right,context)
			StartLine: 13695
			EndLine: 13700
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13696
				EndLine: 13699
				NodeType: AnonymousFunction

			Alias: &#39;binary&gt;&#39;(left,right,context)
			StartLine: 13701
			EndLine: 13706
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13702
				EndLine: 13705
				NodeType: AnonymousFunction

			Alias: &#39;binary&lt;=&#39;(left,right,context)
			StartLine: 13707
			EndLine: 13712
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13708
				EndLine: 13711
				NodeType: AnonymousFunction

			Alias: &#39;binary&gt;=&#39;(left,right,context)
			StartLine: 13713
			EndLine: 13718
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13714
				EndLine: 13717
				NodeType: AnonymousFunction

			Alias: &#39;binary&amp;&amp;&#39;(left,right,context)
			StartLine: 13719
			EndLine: 13724
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13720
				EndLine: 13723
				NodeType: AnonymousFunction

			Alias: &#39;binary||&#39;(left,right,context)
			StartLine: 13725
			EndLine: 13730
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13726
				EndLine: 13729
				NodeType: AnonymousFunction

			Alias: &#39;ternary?:&#39;(test,alternate,c…,context)
			StartLine: 13731
			EndLine: 13736
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13732
				EndLine: 13735
				NodeType: AnonymousFunction

			Alias: value(value,context)
			StartLine: 13737
			EndLine: 13739
			NodeType: Function

				Alias: ?()
				StartLine: 13738
				EndLine: 13738
				NodeType: AnonymousFunction

			Alias: identifier(name,expensiveCh…pression)
			StartLine: 13740
			EndLine: 13756
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13741
				EndLine: 13755
				NodeType: AnonymousFunction

					Alias: ?
					StartLine: 13751
					EndLine: 13751
					NodeType: Object

			Alias: computedMember(left,right,conte…pression)
			StartLine: 13757
			EndLine: 13777
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13758
				EndLine: 13776
				NodeType: AnonymousFunction

					Alias: ?
					StartLine: 13772
					EndLine: 13772
					NodeType: Object

			Alias: nonComputedMember(left,right,expen…pression)
			StartLine: 13778
			EndLine: 13794
			NodeType: Function

				Alias: ?(scope,locals,ass…n,inputs)
				StartLine: 13779
				EndLine: 13793
				NodeType: AnonymousFunction

					Alias: ?
					StartLine: 13789
					EndLine: 13789
					NodeType: Object

			Alias: inputs(input,watchId)
			StartLine: 13795
			EndLine: 13800
			NodeType: Function

				Alias: ?(scope,value,locals,inputs)
				StartLine: 13796
				EndLine: 13799
				NodeType: AnonymousFunction

		Alias: Parser(lexer,$filter,options)
		StartLine: 13806
		EndLine: 13813
		NodeType: Function
		Comment: *&#A; * @constructor

		Alias: prototype
		StartLine: 13815
		EndLine: 13821
		NodeType: Object

			Alias: parse(text)
			StartLine: 13818
			EndLine: 13820
			NodeType: Function

		Alias: setter(obj,path,setValue,fullExp)
		StartLine: 13827
		EndLine: 13844
		NodeType: Function

		Alias: isPossiblyDangerousMemberName(name)
		StartLine: 13849
		EndLine: 13851
		NodeType: Function

		Alias: getValueOf(value)
		StartLine: 13855
		EndLine: 13857
		NodeType: Function

		Alias: $ParseProvider()
		StartLine: 13910
		EndLine: 14121
		NodeType: Function
		Comment: *&#A; * @ngdoc provider&#A; * @name $parseProvider&#A; *&#A; * @description&#A; * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}&#A; *  service.

			Alias: ?($filter,$sniffer)
			StartLine: 13914
			EndLine: 14120
			NodeType: AnonymousFunction

				Alias: $parseOptions
				StartLine: 13915
				EndLine: 13918
				NodeType: Object

				Alias: $parseOptionsExpensive
				StartLine: 13919
				EndLine: 13922
				NodeType: Object

				Alias: $parse(exp,interceptorF…veChecks)
				StartLine: 13924
				EndLine: 13962
				NodeType: Function

				Alias: expressionInputDirtyCheck(newValue,oldValueOfValue)
				StartLine: 13964
				EndLine: 13987
				NodeType: Function

				Alias: inputsWatchDelegate(scope,listener,o…pression)
				StartLine: 13989
				EndLine: 14030
				NodeType: Function

					Alias: expressionInputWatch(scope)
					StartLine: 13996
					EndLine: 14003
					NodeType: Function

					Alias: expressionInputsWatch(scope)
					StartLine: 14013
					EndLine: 14029
					NodeType: Function

				Alias: oneTimeWatchDelegate(scope,listener,o…pression)
				StartLine: 14032
				EndLine: 14049
				NodeType: Function

					Alias: oneTimeWatch(scope)
					StartLine: 14034
					EndLine: 14036
					NodeType: Function

					Alias: oneTimeListener(value,old,scope)
					StartLine: 14036
					EndLine: 14048
					NodeType: Function

						Alias: $$postDigest&gt;?()
						StartLine: 14042
						EndLine: 14046
						NodeType: AnonymousFunction

				Alias: oneTimeLiteralWatchDelegate(scope,listener,o…pression)
				StartLine: 14051
				EndLine: 14074
				NodeType: Function

					Alias: oneTimeWatch(scope)
					StartLine: 14053
					EndLine: 14055
					NodeType: Function

					Alias: oneTimeListener(value,old,scope)
					StartLine: 14055
					EndLine: 14065
					NodeType: Function

						Alias: $$postDigest&gt;?()
						StartLine: 14061
						EndLine: 14063
						NodeType: AnonymousFunction

					Alias: isAllDefined(value)
					StartLine: 14067
					EndLine: 14073
					NodeType: Function

						Alias: forEach&gt;?(val)
						StartLine: 14069
						EndLine: 14071
						NodeType: AnonymousFunction

				Alias: constantWatchDelegate(scope,listener,o…pression)
				StartLine: 14076
				EndLine: 14086
				NodeType: Function

					Alias: constantWatch(scope)
					StartLine: 14078
					EndLine: 14080
					NodeType: Function

					Alias: constantListener(value,old,scope)
					StartLine: 14080
					EndLine: 14085
					NodeType: Function

				Alias: addInterceptor(parsedExpression…ceptorFn)
				StartLine: 14088
				EndLine: 14119
				NodeType: Function

		Alias: $QProvider()
		StartLine: 14337
		EndLine: 14344
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $q&#A; * @requires $rootScope&#A; *&#A; * @description&#A; * A service that helps you run functions asynchronously, and use their return values (or exceptions)&#A; * when they are done processing.&#A; *&#A; * This is an implementation of promises/deferred objects inspired by&#A; * [Kris Kowal&#39;s Q](https://github.com/kriskowal/q).&#A; *&#A; * $q can be used in two fashions --- one which is more similar to Kris Kowal&#39;s Q or jQuery&#39;s Deferred&#A; * implementations, and the other which resembles ES6 promises to some degree.&#A; *&#A; * # $q constructor&#A; *&#A; * The streamlined ES6 style promise is essentially just using $q as a constructor which takes a `resolver`&#A; * function as the first argument. This is similar to the native Promise implementation from ES6 Harmony,&#A; * see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).&#A; *&#A; * While the constructor-style use is supported, not all of the supporting methods from ES6 Harmony promises are&#A; * available yet.&#A; *&#A; * It can be used like so:&#A; *&#A; * ```js&#A; *   // for the purpose of this example let&#39;s assume that variables `$q` and `okToGreet`&#A; *   // are available in the current lexical scope (they could have been injected or passed in).&#A; *&#A; *   function asyncGreet(name) {&#A; *     // perform some asynchronous operation, resolve or reject the promise when appropriate.&#A; *     return $q(function(resolve, reject) {&#A; *       setTimeout(function() {&#A; *         if (okToGreet(name)) {&#A; *           resolve(&#39;Hello, &#39; + name + &#39;!&#39;);&#A; *         } else {&#A; *           reject(&#39;Greeting &#39; + name + &#39; is not allowed.&#39;);&#A; *         }&#A; *       }, 1000);&#A; *     });&#A; *   }&#A; *&#A; *   var promise = asyncGreet(&#39;Robin Hood&#39;);&#A; *   promise.then(function(greeting) {&#A; *     alert(&#39;Success: &#39; + greeting);&#A; *   }, function(reason) {&#A; *     alert(&#39;Failed: &#39; + reason);&#A; *   });&#A; * ```&#A; *&#A; * Note: progress/notify callbacks are not currently supported via the ES6-style interface.&#A; *&#A; * However, the more traditional CommonJS-style usage is still available, and documented below.&#A; *&#A; * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an&#A; * interface for interacting with an object that represents the result of an action that is&#A; * performed asynchronously, and may or may not be finished at any given point in time.&#A; *&#A; * From the perspective of dealing with error handling, deferred and promise APIs are to&#A; * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.&#A; *&#A; * ```js&#A; *   // for the purpose of this example let&#39;s assume that variables `$q` and `okToGreet`&#A; *   // are available in the current lexical scope (they could have been injected or passed in).&#A; *&#A; *   function asyncGreet(name) {&#A; *     var deferred = $q.defer();&#A; *&#A; *     setTimeout(function() {&#A; *       deferred.notify(&#39;About to greet &#39; + name + &#39;.&#39;);&#A; *&#A; *       if (okToGreet(name)) {&#A; *         deferred.resolve(&#39;Hello, &#39; + name + &#39;!&#39;);&#A; *       } else {&#A; *         deferred.reject(&#39;Greeting &#39; + name + &#39; is not allowed.&#39;);&#A; *       }&#A; *     }, 1000);&#A; *&#A; *     return deferred.promise;&#A; *   }&#A; *&#A; *   var promise = asyncGreet(&#39;Robin Hood&#39;);&#A; *   promise.then(function(greeting) {&#A; *     alert(&#39;Success: &#39; + greeting);&#A; *   }, function(reason) {&#A; *     alert(&#39;Failed: &#39; + reason);&#A; *   }, function(update) {&#A; *     alert(&#39;Got notification: &#39; + update);&#A; *   });&#A; * ```&#A; *&#A; * At first it might not be obvious why this extra complexity is worth the trouble. The payoff&#A; * comes in the way of guarantees that promise and deferred APIs make, see&#A; * https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.&#A; *&#A; * Additionally the promise api allows for composition that is very hard to do with the&#A; * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.&#A; * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the&#A; * section on serial or parallel joining of promises.&#A; *&#A; * # The Deferred API&#A; *&#A; * A new instance of deferred is constructed by calling `$q.defer()`.&#A; *&#A; * The purpose of the deferred object is to expose the associated Promise instance as well as APIs&#A; * that can be used for signaling the successful or unsuccessful completion, as well as the status&#A; * of the task.&#A; *&#A; * **Methods**&#A; *&#A; * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection&#A; *   constructed via `$q.reject`, the promise will be rejected instead.&#A; * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to&#A; *   resolving it with a rejection constructed via `$q.reject`.&#A; * - `notify(value)` - provides updates on the status of the promise&#39;s execution. This may be called&#A; *   multiple times before the promise is either resolved or rejected.&#A; *&#A; * **Properties**&#A; *&#A; * - promise – `{Promise}` – promise object associated with this deferred.&#A; *&#A; *&#A; * # The Promise API&#A; *&#A; * A new promise instance is created when a deferred instance is created and can be retrieved by&#A; * calling `deferred.promise`.&#A; *&#A; * The purpose of the promise object is to allow for interested parties to get access to the result&#A; * of the deferred task when it completes.&#A; *&#A; * **Methods**&#A; *&#A; * - `then(successCallback, errorCallback, notifyCallback)` – regardless of when the promise was or&#A; *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously&#A; *   as soon as the result is available. The callbacks are called with a single argument: the result&#A; *   or rejection reason. Additionally, the notify callback may be called zero or more times to&#A; *   provide a progress indication, before the promise is resolved or rejected.&#A; *&#A; *   This method *returns a new promise* which is resolved or rejected via the return value of the&#A; *   `successCallback`, `errorCallback` (unless that value is a promise, in which case it is resolved&#A; *   with the value which is resolved in that promise using&#A; *   [promise chaining](http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues)).&#A; *   It also notifies via the return value of the `notifyCallback` method. The promise cannot be&#A; *   resolved or rejected from the notifyCallback method.&#A; *&#A; * - `catch(errorCallback)` – shorthand for `promise.then(null, errorCallback)`&#A; *&#A; * - `finally(callback, notifyCallback)` – allows you to observe either the fulfillment or rejection of a promise,&#A; *   but to do so without modifying the final value. This is useful to release resources or do some&#A; *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full&#A; *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for&#A; *   more information.&#A; *&#A; * # Chaining promises&#A; *&#A; * Because calling the `then` method of a promise returns a new derived promise, it is easily&#A; * possible to create a chain of promises:&#A; *&#A; * ```js&#A; *   promiseB = promiseA.then(function(result) {&#A; *     return result + 1;&#A; *   });&#A; *&#A; *   // promiseB will be resolved immediately after promiseA is resolved and its value&#A; *   // will be the result of promiseA incremented by 1&#A; * ```&#A; *&#A; * It is possible to create chains of any length and since a promise can be resolved with another&#A; * promise (which will defer its resolution further), it is possible to pause/defer resolution of&#A; * the promises at any point in the chain. This makes it possible to implement powerful APIs like&#A; * $http&#39;s response interceptors.&#A; *&#A; *&#A; * # Differences between Kris Kowal&#39;s Q and $q&#A; *&#A; *  There are two main differences:&#A; *&#A; * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation&#A; *   mechanism in angular, which means faster propagation of resolution or rejection into your&#A; *   models and avoiding unnecessary browser repaints, which would result in flickering UI.&#A; * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains&#A; *   all the important functionality needed for common async tasks.&#A; *&#A; *  # Testing&#A; *&#A; *  ```js&#A; *    it(&#39;should simulate promise&#39;, inject(function($q, $rootScope) {&#A; *      var deferred = $q.defer();&#A; *      var promise = deferred.promise;&#A; *      var resolvedValue;&#A; *&#A; *      promise.then(function(value) { resolvedValue = value; });&#A; *      expect(resolvedValue).toBeUndefined();&#A; *&#A; *      // Simulate resolving of promise&#A; *      deferred.resolve(123);&#A; *      // Note that the &#39;then&#39; function does not get called synchronously.&#A; *      // This is because we want the promise API to always be async, whether or not&#A; *      // it got called synchronously or asynchronously.&#A; *      expect(resolvedValue).toBeUndefined();&#A; *&#A; *      // Propagate promise resolution to &#39;then&#39; functions using $apply().&#A; *      $rootScope.$apply();&#A; *      expect(resolvedValue).toEqual(123);&#A; *    }));&#A; *  ```&#A; *&#A; * @param {function(function, function)} resolver Function which is responsible for resolving or&#A; *   rejecting the newly created promise. The first parameter is a function which resolves the&#A; *   promise, the second parameter is a function which rejects the promise.&#A; *&#A; * @returns {Promise} The newly created promise.

			Alias: ?($rootScope,$exce…nHandler)
			StartLine: 14339
			EndLine: 14343
			NodeType: AnonymousFunction

				Alias: qFactory&gt;?(callback)
				StartLine: 14340
				EndLine: 14342
				NodeType: AnonymousFunction

		Alias: $$QProvider()
		StartLine: 14346
		EndLine: 14352
		NodeType: Function

			Alias: ?($browser,$except…nHandler)
			StartLine: 14347
			EndLine: 14351
			NodeType: AnonymousFunction

				Alias: qFactory&gt;?(callback)
				StartLine: 14348
				EndLine: 14350
				NodeType: AnonymousFunction

		Alias: qFactory(nextTick,exceptionHandler)
		StartLine: 14362
		EndLine: 14691
		NodeType: Function
		Comment: *&#A; * Constructs a promise manager.&#A; *&#A; * @param {function(function)} nextTick Function for executing functions in the next turn.&#A; * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for&#A; *     debugging purposes.&#A; * @returns {object} Promise manager.

			Alias: callOnce(self,resolveFn,rejectFn)
			StartLine: 14364
			EndLine: 14375
			NodeType: Function

				Alias: wrap(fn)
				StartLine: 14366
				EndLine: 14372
				NodeType: Function

					Alias: ?(value)
					StartLine: 14367
					EndLine: 14371
					NodeType: AnonymousFunction

			Alias: defer()
			StartLine: 14387
			EndLine: 14389
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ng.$q#defer&#A;   * @kind function&#A;   *&#A;   * @description&#A;   * Creates a `Deferred` object which represents a task which will finish in the future.&#A;   *&#A;   * @returns {Deferred} Returns a new instance of deferred.

			Alias: Promise()
			StartLine: 14391
			EndLine: 14393
			NodeType: Function

				Alias: $$state
				StartLine: 14392
				EndLine: 14392
				NodeType: Object

			Alias: prototype
			StartLine: 14395
			EndLine: 14417
			NodeType: Object

				Alias: then(onFulfilled,onRe…ressBack)
				StartLine: 14396
				EndLine: 14404
				NodeType: Function

				Alias: &quot;catch&quot;(callback)
				StartLine: 14406
				EndLine: 14408
				NodeType: Function

				Alias: &quot;finally&quot;(callback,progressBack)
				StartLine: 14410
				EndLine: 14416
				NodeType: Function

					Alias: then&gt;?(value)
					StartLine: 14411
					EndLine: 14413
					NodeType: AnonymousFunction

					Alias: then&gt;?(error)
					StartLine: 14413
					EndLine: 14415
					NodeType: AnonymousFunction

			Alias: simpleBind(context,fn)
			StartLine: 14420
			EndLine: 14424
			NodeType: Function
			Comment: Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native

				Alias: ?(value)
				StartLine: 14421
				EndLine: 14423
				NodeType: AnonymousFunction

			Alias: processQueue(state)
			StartLine: 14426
			EndLine: 14448
			NodeType: Function

			Alias: scheduleProcessQueue(state)
			StartLine: 14450
			EndLine: 14454
			NodeType: Function

				Alias: nextTick&gt;?()
				StartLine: 14453
				EndLine: 14453
				NodeType: AnonymousFunction

			Alias: Deferred()
			StartLine: 14456
			EndLine: 14462
			NodeType: Function

			Alias: prototype
			StartLine: 14464
			EndLine: 14527
			NodeType: Object

				Alias: resolve(val)
				StartLine: 14465
				EndLine: 14476
				NodeType: Function

				Alias: $$resolve(val)
				StartLine: 14478
				EndLine: 14496
				NodeType: Function

				Alias: reject(reason)
				StartLine: 14498
				EndLine: 14501
				NodeType: Function

				Alias: $$reject(reason)
				StartLine: 14503
				EndLine: 14507
				NodeType: Function

				Alias: notify(progress)
				StartLine: 14509
				EndLine: 14526
				NodeType: Function

					Alias: nextTick&gt;?()
					StartLine: 14513
					EndLine: 14524
					NodeType: AnonymousFunction

			Alias: reject(reason)
			StartLine: 14565
			EndLine: 14569
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $q#reject&#A;   * @kind function&#A;   *&#A;   * @description&#A;   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be&#A;   * used to forward rejection in a chain of promises. If you are dealing with the last promise in&#A;   * a promise chain, you don&#39;t need to worry about it.&#A;   *&#A;   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of&#A;   * `reject` as the `throw` keyword in JavaScript. This also means that if you &quot;catch&quot; an error via&#A;   * a promise error callback and you want to forward the error to the promise derived from the&#A;   * current promise, you have to &quot;rethrow&quot; the error by returning a rejection constructed via&#A;   * `reject`.&#A;   *&#A;   * ```js&#A;   *   promiseB = promiseA.then(function(result) {&#A;   *     // success: do something and resolve promiseB&#A;   *     //          with the old or a new result&#A;   *     return result;&#A;   *   }, function(reason) {&#A;   *     // error: handle the error if possible and&#A;   *     //        resolve promiseB with newPromiseOrValue,&#A;   *     //        otherwise forward the rejection to promiseB&#A;   *     if (canHandle(reason)) {&#A;   *      // handle the error and recover&#A;   *      return newPromiseOrValue;&#A;   *     }&#A;   *     return $q.reject(reason);&#A;   *   });&#A;   * ```&#A;   *&#A;   * @param {*} reason Constant, message, exception or an object representing the rejection reason.&#A;   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.

			Alias: makePromise(value,resolved)
			StartLine: 14571
			EndLine: 14579
			NodeType: Function

			Alias: handleCallback(value,isResolved,callback)
			StartLine: 14581
			EndLine: 14597
			NodeType: Function

				Alias: then&gt;?()
				StartLine: 14589
				EndLine: 14591
				NodeType: AnonymousFunction

				Alias: then&gt;?(error)
				StartLine: 14591
				EndLine: 14593
				NodeType: AnonymousFunction

			Alias: when(value,callback,e…ressBack)
			StartLine: 14614
			EndLine: 14618
			NodeType: Function

			Alias: all(promises)
			StartLine: 14636
			EndLine: 14658
			NodeType: Function

				Alias: forEach&gt;?(promise,key)
				StartLine: 14641
				EndLine: 14651
				NodeType: AnonymousFunction

					Alias: then&gt;?(value)
					StartLine: 14643
					EndLine: 14647
					NodeType: AnonymousFunction

					Alias: then&gt;?(reason)
					StartLine: 14647
					EndLine: 14650
					NodeType: AnonymousFunction

			Alias: Q(resolver)
			StartLine: 14660
			EndLine: 14683
			NodeType: Function

				Alias: resolveFn(value)
				StartLine: 14672
				EndLine: 14674
				NodeType: Function

				Alias: rejectFn(reason)
				StartLine: 14676
				EndLine: 14678
				NodeType: Function

		Alias: $$RAFProvider()
		StartLine: 14693
		EndLine: 14759
		NodeType: Function
		Comment: rAF

			Alias: ?($window,$timeout)
			StartLine: 14694
			EndLine: 14758
			NodeType: AnonymousFunction

				Alias: flush()
				StartLine: 14724
				EndLine: 14733
				NodeType: Function

				Alias: queueFn(asyncFn)
				StartLine: 14735
				EndLine: 14757
				NodeType: Function

					Alias: cancelQueueFn()
					StartLine: 14745
					EndLine: 14756
					NodeType: Function

		Alias: $RootScopeProvider()
		StartLine: 14828
		EndLine: 16107
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $rootScope&#A; * @description&#A; *&#A; * Every application has a single root {@link ng.$rootScope.Scope scope}.&#A; * All other scopes are descendant scopes of the root scope. Scopes provide separation&#A; * between the model and the view, via a mechanism for watching the model for changes.&#A; * They also provide an event emission/broadcast and subscription facility. See the&#A; * {@link guide/scope developer guide on scopes}.

			Alias: digestTtl(value)
			StartLine: 14834
			EndLine: 14839
			NodeType: Function

			Alias: createChildScopeClass(parent)
			StartLine: 14841
			EndLine: 14853
			NodeType: Function

				Alias: ChildScope()
				StartLine: 14842
				EndLine: 14850
				NodeType: Function

			Alias: ?($injector,$excep…$browser)
			StartLine: 14856
			EndLine: 16106
			NodeType: AnonymousFunction

				Alias: destroyChildScope($event)
				StartLine: 14858
				EndLine: 14860
				NodeType: Function

				Alias: Scope()
				StartLine: 14905
				EndLine: 14916
				NodeType: Function
				Comment: *&#A;     * @ngdoc type&#A;     * @name $rootScope.Scope&#A;     *&#A;     * @description&#A;     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the&#A;     * {@link auto.$injector $injector}. Child scopes are created using the&#A;     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when&#A;     * compiled HTML template is executed.)&#A;     *&#A;     * Here is a simple scope snippet to show how you can interact with the scope.&#A;     * ```html&#A;     * &lt;file src=&quot;./test/ng/rootScopeSpec.js&quot; tag=&quot;docs1&quot; /&gt;&#A;     * ```&#A;     *&#A;     * # Inheritance&#A;     * A scope can inherit from a parent scope, as in this example:&#A;     * ```js&#A;         var parent = $rootScope;&#A;         var child = parent.$new();&#A;&#A;         parent.salutation = &quot;Hello&quot;;&#A;         expect(child.salutation).toEqual(&#39;Hello&#39;);&#A;&#A;         child.salutation = &quot;Welcome&quot;;&#A;         expect(child.salutation).toEqual(&#39;Welcome&#39;);&#A;         expect(parent.salutation).toEqual(&#39;Hello&#39;);&#A;     * ```&#A;     *&#A;     * When interacting with `Scope` in tests, additional helper methods are available on the&#A;     * instances of `Scope` type. See {@link ngMock.$rootScope.Scope ngMock Scope} for additional&#A;     * details.&#A;     *&#A;     *&#A;     * @param {Object.&lt;string, function()&gt;=} providers Map of service factory which need to be&#A;     *                                       provided for the current scope. Defaults to {@link ng}.&#A;     * @param {Object.&lt;string, *&gt;=} instanceCache Provides pre-instantiated services which should&#A;     *                              append/override services provided by `providers`. This is handy&#A;     *                              when unit-testing and having the need to override a default&#A;     *                              service.&#A;     * @returns {Object} Newly created scope.&#A;     *

				Alias: prototype
				StartLine: 14942
				EndLine: 16042
				NodeType: Object

					Alias: $new(isolate,parent)
					StartLine: 14973
					EndLine: 15006
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$new&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Creates a new child {@link ng.$rootScope.Scope scope}.&#A;       *&#A;       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} event.&#A;       * The scope can be removed from the scope hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.&#A;       *&#A;       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is&#A;       * desired for the scope and its child scopes to be permanently detached from the parent and&#A;       * thus stop participating in model change detection and listener notification by invoking.&#A;       *&#A;       * @param {boolean} isolate If true, then the scope does not prototypically inherit from the&#A;       *         parent scope. The scope is isolated, as it can not see parent scope properties.&#A;       *         When creating widgets, it is useful for the widget to not accidentally read parent&#A;       *         state.&#A;       *&#A;       * @param {Scope} [parent=this] The {@link ng.$rootScope.Scope `Scope`} that will be the `$parent`&#A;       *                              of the newly created scope. Defaults to `this` scope if not provided.&#A;       *                              This is used when creating a transclude scope to correctly place it&#A;       *                              in the scope hierarchy while maintaining the correct prototypical&#A;       *                              inheritance.&#A;       *&#A;       * @returns {Object} The newly created child scope.&#A;       *

					Alias: $watch(watchExp,listene…pression)
					StartLine: 15124
					EndLine: 15160
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$watch&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.&#A;       *&#A;       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest&#A;       *   $digest()} and should return the value that will be watched. (Since&#A;       *   {@link ng.$rootScope.Scope#$digest $digest()} reruns when it detects changes the&#A;       *   `watchExpression` can execute multiple times per&#A;       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)&#A;       * - The `listener` is called only when the value from the current `watchExpression` and the&#A;       *   previous call to `watchExpression` are not equal (with the exception of the initial run,&#A;       *   see below). Inequality is determined according to reference inequality,&#A;       *   [strict comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)&#A;       *    via the `!==` Javascript operator, unless `objectEquality == true`&#A;       *   (see next point)&#A;       * - When `objectEquality == true`, inequality of the `watchExpression` is determined&#A;       *   according to the {@link angular.equals} function. To save the value of the object for&#A;       *   later comparison, the {@link angular.copy} function is used. This therefore means that&#A;       *   watching complex objects will have adverse memory and performance implications.&#A;       * - The watch `listener` may change the model, which may trigger other `listener`s to fire.&#A;       *   This is achieved by rerunning the watchers until no changes are detected. The rerun&#A;       *   iteration limit is 10 to prevent an infinite loop deadlock.&#A;       *&#A;       *&#A;       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,&#A;       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`&#A;       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a&#A;       * change is detected, be prepared for multiple calls to your listener.)&#A;       *&#A;       * After a watcher is registered with the scope, the `listener` fn is called asynchronously&#A;       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the&#A;       * watcher. In rare cases, this is undesirable because the listener is called when the result&#A;       * of `watchExpression` didn&#39;t change. To detect this scenario within the `listener` fn, you&#A;       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the&#A;       * listener was called due to initialization.&#A;       *&#A;       *&#A;       *&#A;       * # Example&#A;       * ```js&#A;           // let&#39;s assume that scope was dependency injected as the $rootScope&#A;           var scope = $rootScope;&#A;           scope.name = &#39;misko&#39;;&#A;           scope.counter = 0;&#A;&#A;           expect(scope.counter).toEqual(0);&#A;           scope.$watch(&#39;name&#39;, function(newValue, oldValue) {&#A;             scope.counter = scope.counter + 1;&#A;           });&#A;           expect(scope.counter).toEqual(0);&#A;&#A;           scope.$digest();&#A;           // the listener is always called during the first $digest loop after it was registered&#A;           expect(scope.counter).toEqual(1);&#A;&#A;           scope.$digest();&#A;           // but now it will not be called unless the value changes&#A;           expect(scope.counter).toEqual(1);&#A;&#A;           scope.name = &#39;adam&#39;;&#A;           scope.$digest();&#A;           expect(scope.counter).toEqual(2);&#A;&#A;&#A;&#A;           // Using a function as a watchExpression&#A;           var food;&#A;           scope.foodCounter = 0;&#A;           expect(scope.foodCounter).toEqual(0);&#A;           scope.$watch(&#A;             // This function returns the value being watched. It is called for each turn of the $digest loop&#A;             function() { return food; },&#A;             // This is the change listener, called when the value returned from the above function changes&#A;             function(newValue, oldValue) {&#A;               if ( newValue !== oldValue ) {&#A;                 // Only increment the counter if the value changed&#A;                 scope.foodCounter = scope.foodCounter + 1;&#A;               }&#A;             }&#A;           );&#A;           // No digest has been run so the counter will be zero&#A;           expect(scope.foodCounter).toEqual(0);&#A;&#A;           // Run the digest but since food has not changed count will still be zero&#A;           scope.$digest();&#A;           expect(scope.foodCounter).toEqual(0);&#A;&#A;           // Update food and run digest.  Now the counter will increment&#A;           food = &#39;cheeseburger&#39;;&#A;           scope.$digest();&#A;           expect(scope.foodCounter).toEqual(1);&#A;&#A;       * ```&#A;       *&#A;       *&#A;       *&#A;       * @param {(function()|string)} watchExpression Expression that is evaluated on each&#A;       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers&#A;       *    a call to the `listener`.&#A;       *&#A;       *    - `string`: Evaluated as {@link guide/expression expression}&#A;       *    - `function(scope)`: called with current `scope` as a parameter.&#A;       * @param {function(newVal, oldVal, scope)} listener Callback called whenever the value&#A;       *    of `watchExpression` changes.&#A;       *&#A;       *    - `newVal` contains the current value of the `watchExpression`&#A;       *    - `oldVal` contains the previous value of the `watchExpression`&#A;       *    - `scope` refers to the current scope&#A;       * @param {boolean=} objectEquality Compare for object equality using {@link angular.equals} instead of&#A;       *     comparing for reference equality.&#A;       * @returns {function()} Returns a deregistration function for this listener.

						Alias: watcher
						StartLine: 15132
						EndLine: 15138
						NodeType: Object

						Alias: deregisterWatch()
						StartLine: 15154
						EndLine: 15159
						NodeType: Function

					Alias: $watchGroup(watchExpressions,listener)
					StartLine: 15187
					EndLine: 15243
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$watchGroup&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`.&#A;       * If any one expression in the collection changes the `listener` is executed.&#A;       *&#A;       * - The items in the `watchExpressions` array are observed via standard $watch operation and are examined on every&#A;       *   call to $digest() to see if any items changes.&#A;       * - The `listener` is called whenever any expression in the `watchExpressions` array changes.&#A;       *&#A;       * @param {Array.&lt;string|Function(scope)&gt;} watchExpressions Array of expressions that will be individually&#A;       * watched using {@link ng.$rootScope.Scope#$watch $watch()}&#A;       *&#A;       * @param {function(newValues, oldValues, scope)} listener Callback called whenever the return value of any&#A;       *    expression in `watchExpressions` changes&#A;       *    The `newValues` array contains the current values of the `watchExpressions`, with the indexes matching&#A;       *    those of `watchExpression`&#A;       *    and the `oldValues` array contains the previous values of the `watchExpressions`, with the indexes matching&#A;       *    those of `watchExpression`&#A;       *    The `scope` refers to the current scope.&#A;       * @returns {function()} Returns a de-registration function for all listeners.

						Alias: $evalAsync&gt;?()
						StartLine: 15198
						EndLine: 15200
						NodeType: AnonymousFunction

						Alias: deregisterWatchGroup()
						StartLine: 15201
						EndLine: 15203
						NodeType: Function

						Alias: watchGroupAction(value,oldValue,scope)
						StartLine: 15208
						EndLine: 15212
						NodeType: Function
						Comment: Special case size of one

						Alias: forEach&gt;?(expr,i)
						StartLine: 15215
						EndLine: 15225
						NodeType: AnonymousFunction

							Alias: watchGroupSubAction(value,oldValue)
							StartLine: 15216
							EndLine: 15223
							NodeType: Function

						Alias: watchGroupAction()
						StartLine: 15227
						EndLine: 15236
						NodeType: Function

						Alias: deregisterWatchGroup()
						StartLine: 15238
						EndLine: 15242
						NodeType: Function

					Alias: $watchCollection(obj,listener)
					StartLine: 15301
					EndLine: 15431
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$watchCollection&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Shallow watches the properties of an object and fires whenever any of the properties change&#A;       * (for arrays, this implies watching the array items; for object maps, this implies watching&#A;       * the properties). If a change is detected, the `listener` callback is fired.&#A;       *&#A;       * - The `obj` collection is observed via standard $watch operation and is examined on every&#A;       *   call to $digest() to see if any items have been added, removed, or moved.&#A;       * - The `listener` is called whenever anything within the `obj` has changed. Examples include&#A;       *   adding, removing, and moving items belonging to an object or array.&#A;       *&#A;       *&#A;       * # Example&#A;       * ```js&#A;          $scope.names = [&#39;igor&#39;, &#39;matias&#39;, &#39;misko&#39;, &#39;james&#39;];&#A;          $scope.dataCount = 4;&#A;&#A;          $scope.$watchCollection(&#39;names&#39;, function(newNames, oldNames) {&#A;            $scope.dataCount = newNames.length;&#A;          });&#A;&#A;          expect($scope.dataCount).toEqual(4);&#A;          $scope.$digest();&#A;&#A;          //still at 4 ... no changes&#A;          expect($scope.dataCount).toEqual(4);&#A;&#A;          $scope.names.pop();&#A;          $scope.$digest();&#A;&#A;          //now there&#39;s been a change&#A;          expect($scope.dataCount).toEqual(3);&#A;       * ```&#A;       *&#A;       *&#A;       * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The&#A;       *    expression value should evaluate to an object or an array which is observed on each&#A;       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the&#A;       *    collection will trigger a call to the `listener`.&#A;       *&#A;       * @param {function(newCollection, oldCollection, scope)} listener a callback function called&#A;       *    when a change is detected.&#A;       *    - The `newCollection` object is the newly modified data obtained from the `obj` expression&#A;       *    - The `oldCollection` object is a copy of the former collection data.&#A;       *      Due to performance considerations, the`oldCollection` value is computed only if the&#A;       *      `listener` function declares two or more arguments.&#A;       *    - The `scope` argument refers to the current scope.&#A;       *&#A;       * @returns {function()} Returns a de-registration function for this listener. When the&#A;       *    de-registration function is executed, the internal watch operation is terminated.

						Alias: $watchCollectionInterceptor(_value)
						StartLine: 15321
						EndLine: 15399
						NodeType: Function

						Alias: $watchCollectionAction()
						StartLine: 15401
						EndLine: 15428
						NodeType: Function

					Alias: $digest()
					StartLine: 15484
					EndLine: 15594
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$digest&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and&#A;       * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}&#39;s listener can change&#A;       * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers}&#A;       * until no more listeners are firing. This means that it is possible to get into an infinite&#A;       * loop. This function will throw `&#39;Maximum iteration limit exceeded.&#39;` if the number of&#A;       * iterations exceeds 10.&#A;       *&#A;       * Usually, you don&#39;t call `$digest()` directly in&#A;       * {@link ng.directive:ngController controllers} or in&#A;       * {@link ng.$compileProvider#directive directives}.&#A;       * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within&#A;       * a {@link ng.$compileProvider#directive directive}), which will force a `$digest()`.&#A;       *&#A;       * If you want to be notified whenever `$digest()` is called,&#A;       * you can register a `watchExpression` function with&#A;       * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.&#A;       *&#A;       * In unit tests, you may need to call `$digest()` to simulate the scope life cycle.&#A;       *&#A;       * # Example&#A;       * ```js&#A;           var scope = ...;&#A;           scope.name = &#39;misko&#39;;&#A;           scope.counter = 0;&#A;&#A;           expect(scope.counter).toEqual(0);&#A;           scope.$watch(&#39;name&#39;, function(newValue, oldValue) {&#A;             scope.counter = scope.counter + 1;&#A;           });&#A;           expect(scope.counter).toEqual(0);&#A;&#A;           scope.$digest();&#A;           // the listener is always called during the first $digest loop after it was registered&#A;           expect(scope.counter).toEqual(1);&#A;&#A;           scope.$digest();&#A;           // but now it will not be called unless the value changes&#A;           expect(scope.counter).toEqual(1);&#A;&#A;           scope.name = &#39;adam&#39;;&#A;           scope.$digest();&#A;           expect(scope.counter).toEqual(2);&#A;       * ```&#A;       *

					Alias: $destroy()
					StartLine: 15631
					EndLine: 15671
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$destroy&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Removes the current scope (and all of its children) from the parent scope. Removal implies&#A;       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer&#A;       * propagate to the current scope and its children. Removal also implies that the current&#A;       * scope is eligible for garbage collection.&#A;       *&#A;       * The `$destroy()` is usually used by directives such as&#A;       * {@link ng.directive:ngRepeat ngRepeat} for managing the&#A;       * unrolling of the loop.&#A;       *&#A;       * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope.&#A;       * Application code can register a `$destroy` event handler that will give it a chance to&#A;       * perform any necessary cleanup.&#A;       *&#A;       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to&#A;       * clean up DOM bindings before an element is removed from the DOM.&#A;       &#D;&#A; We can&#39;t destroy a scope that has been already destroyed.

						Alias: $watchGroup.$watch.$on()
						StartLine: 15658
						EndLine: 15658
						NodeType: Function

					Alias: $eval(expr,locals)
					StartLine: 15701
					EndLine: 15703
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$eval&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Executes the `expression` on the current scope and returns the result. Any exceptions in&#A;       * the expression are propagated (uncaught). This is useful when evaluating Angular&#A;       * expressions.&#A;       *&#A;       * # Example&#A;       * ```js&#A;           var scope = ng.$rootScope.Scope();&#A;           scope.a = 1;&#A;           scope.b = 2;&#A;&#A;           expect(scope.$eval(&#39;a+b&#39;)).toEqual(3);&#A;           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);&#A;       * ```&#A;       *&#A;       * @param {(string|function())=} expression An angular expression to be executed.&#A;       *&#A;       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.&#A;       *    - `function(scope)`: execute the function with the current `scope` parameter.&#A;       *&#A;       * @param {(object)=} locals Local variables object, useful for overriding values in scope.&#A;       * @returns {*} The result of evaluating the expression.

					Alias: $evalAsync(expr,locals)
					StartLine: 15735
					EndLine: 15747
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$evalAsync&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Executes the expression on the current scope at a later point in time.&#A;       *&#A;       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only&#A;       * that:&#A;       *&#A;       *   - it will execute after the function that scheduled the evaluation (preferably before DOM&#A;       *     rendering).&#A;       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after&#A;       *     `expression` execution.&#A;       *&#A;       * Any exceptions from the execution of the expression are forwarded to the&#A;       * {@link ng.$exceptionHandler $exceptionHandler} service.&#A;       *&#A;       * __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle&#A;       * will be scheduled. However, it is encouraged to always call code that changes the model&#A;       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.&#A;       *&#A;       * @param {(string|function())=} expression An angular expression to be executed.&#A;       *&#A;       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.&#A;       *    - `function(scope)`: execute the function with the current `scope` parameter.&#A;       *&#A;       * @param {(object)=} locals Local variables object, useful for overriding values in scope.&#A;       &#D;&#A; if we are outside of an $digest loop and this is the first time we are scheduling async&#D;&#A; task also schedule async auto-flush

						Alias: defer&gt;?()
						StartLine: 15739
						EndLine: 15743
						NodeType: AnonymousFunction

						Alias: push&gt;?
						StartLine: 15746
						EndLine: 15746
						NodeType: Object

					Alias: $$postDigest(fn)
					StartLine: 15749
					EndLine: 15751
					NodeType: Function

					Alias: $apply(expr)
					StartLine: 15798
					EndLine: 15813
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$apply&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * `$apply()` is used to execute an expression in angular from outside of the angular&#A;       * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).&#A;       * Because we are calling into the angular framework we need to perform proper scope life&#A;       * cycle of {@link ng.$exceptionHandler exception handling},&#A;       * {@link ng.$rootScope.Scope#$digest executing watches}.&#A;       *&#A;       * ## Life cycle&#A;       *&#A;       * # Pseudo-Code of `$apply()`&#A;       * ```js&#A;           function $apply(expr) {&#A;             try {&#A;               return $eval(expr);&#A;             } catch (e) {&#A;               $exceptionHandler(e);&#A;             } finally {&#A;               $root.$digest();&#A;             }&#A;           }&#A;       * ```&#A;       *&#A;       *&#A;       * Scope&#39;s `$apply()` method transitions through the following stages:&#A;       *&#A;       * 1. The {@link guide/expression expression} is executed using the&#A;       *    {@link ng.$rootScope.Scope#$eval $eval()} method.&#A;       * 2. Any exceptions from the execution of the expression are forwarded to the&#A;       *    {@link ng.$exceptionHandler $exceptionHandler} service.&#A;       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the&#A;       *    expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.&#A;       *&#A;       *&#A;       * @param {(string|function())=} exp An angular expression to be executed.&#A;       *&#A;       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.&#A;       *    - `function(scope)`: execute the function with current `scope` parameter.&#A;       *&#A;       * @returns {*} The result of evaluating the expression.

					Alias: $applyAsync(expr)
					StartLine: 15832
					EndLine: 15840
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$applyAsync&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Schedule the invocation of $apply to occur at a later time. The actual time difference&#A;       * varies across browsers, but is typically around ~10 milliseconds.&#A;       *&#A;       * This can be used to queue up multiple expressions which need to be evaluated in the same&#A;       * digest.&#A;       *&#A;       * @param {(string|function())=} exp An angular expression to be executed.&#A;       *&#A;       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.&#A;       *    - `function(scope)`: execute the function with current `scope` parameter.

						Alias: $applyAsyncExpression()
						StartLine: 15837
						EndLine: 15839
						NodeType: Function

					Alias: $on(name,listener)
					StartLine: 15869
					EndLine: 15892
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$on&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for&#A;       * discussion of event life cycle.&#A;       *&#A;       * The event listener function format is: `function(event, args...)`. The `event` object&#A;       * passed into the listener has the following attributes:&#A;       *&#A;       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or&#A;       *     `$broadcast`-ed.&#A;       *   - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the&#A;       *     event propagates through the scope hierarchy, this property is set to null.&#A;       *   - `name` - `{string}`: name of the event.&#A;       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel&#A;       *     further event propagation (available only for events that were `$emit`-ed).&#A;       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag&#A;       *     to true.&#A;       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.&#A;       *&#A;       * @param {string} name Event name to listen on.&#A;       * @param {function(event, ...args)} listener Function to call when the event is emitted.&#A;       * @returns {function()} Returns a deregistration function for this listener.

						Alias: ?()
						StartLine: 15885
						EndLine: 15891
						NodeType: AnonymousFunction

					Alias: $emit(name,args)
					StartLine: 15917
					EndLine: 15965
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$emit&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Dispatches an event `name` upwards through the scope hierarchy notifying the&#A;       * registered {@link ng.$rootScope.Scope#$on} listeners.&#A;       *&#A;       * The event life cycle starts at the scope on which `$emit` was called. All&#A;       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get&#A;       * notified. Afterwards, the event traverses upwards toward the root scope and calls all&#A;       * registered listeners along the way. The event will stop propagating if one of the listeners&#A;       * cancels it.&#A;       *&#A;       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed&#A;       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.&#A;       *&#A;       * @param {string} name Event name to emit.&#A;       * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.&#A;       * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}).

						Alias: event
						StartLine: 15922
						EndLine: 15930
						NodeType: Object

							Alias: stopPropagation()
							StartLine: 15925
							EndLine: 15925
							NodeType: Function

							Alias: preventDefault()
							StartLine: 15926
							EndLine: 15928
							NodeType: Function

					Alias: $broadcast(name,args)
					StartLine: 15989
					EndLine: 16041
					NodeType: Function
					Comment: *&#A;       * @ngdoc method&#A;       * @name $rootScope.Scope#$broadcast&#A;       * @kind function&#A;       *&#A;       * @description&#A;       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the&#A;       * registered {@link ng.$rootScope.Scope#$on} listeners.&#A;       *&#A;       * The event life cycle starts at the scope on which `$broadcast` was called. All&#A;       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get&#A;       * notified. Afterwards, the event propagates to all direct and indirect scopes of the current&#A;       * scope and calls all registered listeners along the way. The event cannot be canceled.&#A;       *&#A;       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed&#A;       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.&#A;       *&#A;       * @param {string} name Event name to broadcast.&#A;       * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.&#A;       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}

						Alias: event
						StartLine: 15993
						EndLine: 16000
						NodeType: Object

							Alias: preventDefault()
							StartLine: 15996
							EndLine: 15998
							NodeType: Function

				Alias: beginPhase(phase)
				StartLine: 16054
				EndLine: 16060
				NodeType: Function

				Alias: clearPhase()
				StartLine: 16062
				EndLine: 16064
				NodeType: Function

				Alias: incrementWatchersCount(current,count)
				StartLine: 16066
				EndLine: 16070
				NodeType: Function

				Alias: decrementListenerCount(current,count,name)
				StartLine: 16072
				EndLine: 16080
				NodeType: Function

				Alias: initWatchVal()
				StartLine: 16086
				EndLine: 16086
				NodeType: Function
				Comment: *&#A;     * function used as an initial value for watchers.&#A;     * because it&#39;s unique we can easily tell it apart from other values

				Alias: flushApplyAsync()
				StartLine: 16088
				EndLine: 16097
				NodeType: Function

				Alias: scheduleApplyAsync()
				StartLine: 16099
				EndLine: 16105
				NodeType: Function

					Alias: defer.applyAsyncId&gt;?()
					StartLine: 16101
					EndLine: 16103
					NodeType: AnonymousFunction

		Alias: $$SanitizeUriProvider()
		StartLine: 16113
		EndLine: 16177
		NodeType: Function
		Comment: *&#A; * @description&#A; * Private service to sanitize uris for links and images. Used by $compile and $sanitize.

			Alias: aHrefSanitizationWhitelist(regexp)
			StartLine: 16133
			EndLine: 16139
			NodeType: Function
			Comment: *&#A;   * @description&#A;   * Retrieves or overrides the default regular expression that is used for whitelisting of safe&#A;   * urls during a[href] sanitization.&#A;   *&#A;   * The sanitization is a security measure aimed at prevent XSS attacks via html links.&#A;   *&#A;   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into&#A;   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`&#A;   * regular expression. If a match is found, the original url is written into the dom. Otherwise,&#A;   * the absolute url is prefixed with `&#39;unsafe:&#39;` string and only then is it written into the DOM.&#A;   *&#A;   * @param {RegExp=} regexp New regexp to whitelist urls with.&#A;   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for&#A;   *    chaining otherwise.

			Alias: imgSrcSanitizationWhitelist(regexp)
			StartLine: 16158
			EndLine: 16164
			NodeType: Function
			Comment: *&#A;   * @description&#A;   * Retrieves or overrides the default regular expression that is used for whitelisting of safe&#A;   * urls during img[src] sanitization.&#A;   *&#A;   * The sanitization is a security measure aimed at prevent XSS attacks via html links.&#A;   *&#A;   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into&#A;   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`&#A;   * regular expression. If a match is found, the original url is written into the dom. Otherwise,&#A;   * the absolute url is prefixed with `&#39;unsafe:&#39;` string and only then is it written into the DOM.&#A;   *&#A;   * @param {RegExp=} regexp New regexp to whitelist urls with.&#A;   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for&#A;   *    chaining otherwise.

			Alias: $get()
			StartLine: 16166
			EndLine: 16176
			NodeType: Function

				Alias: sanitizeUri(uri,isImage)
				StartLine: 16167
				EndLine: 16175
				NodeType: Function

		Alias: SCE_CONTEXTS
		StartLine: 16192
		EndLine: 16200
		NodeType: Object

		Alias: adjustMatcher(matcher)
		StartLine: 16204
		EndLine: 16229
		NodeType: Function

		Alias: adjustMatchers(matchers)
		StartLine: 16232
		EndLine: 16240
		NodeType: Function

			Alias: forEach&gt;?(matcher)
			StartLine: 16235
			EndLine: 16237
			NodeType: AnonymousFunction

		Alias: $SceDelegateProvider()
		StartLine: 16310
		EndLine: 16556
		NodeType: Function

			Alias: resourceUrlWhitelist(value)
			StartLine: 16339
			EndLine: 16344
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $sceDelegateProvider#resourceUrlWhitelist&#A;   * @kind function&#A;   *&#A;   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value&#A;   *     provided.  This must be an array or null.  A snapshot of this array is used so further&#A;   *     changes to the array are ignored.&#A;   *&#A;   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items&#A;   *     allowed in this array.&#A;   *&#A;   *     Note: **an empty whitelist array will block all URLs**!&#A;   *&#A;   * @return {Array} the currently set whitelist array.&#A;   *&#A;   * The **default value** when no whitelist has been explicitly set is `[&#39;self&#39;]` allowing only&#A;   * same origin resource requests.&#A;   *&#A;   * @description&#A;   * Sets/Gets the whitelist of trusted resource URLs.

			Alias: resourceUrlBlacklist(value)
			StartLine: 16373
			EndLine: 16378
			NodeType: Function

			Alias: ?($injector)
			StartLine: 16380
			EndLine: 16555
			NodeType: AnonymousFunction

				Alias: htmlSanitizer(html)
				StartLine: 16382
				EndLine: 16384
				NodeType: Function

				Alias: matchUrl(matcher,parsedUrl)
				StartLine: 16391
				EndLine: 16398
				NodeType: Function

				Alias: isResourceUrlAllowedByPolicy(url)
				StartLine: 16400
				EndLine: 16420
				NodeType: Function

				Alias: generateHolderType(Base)
				StartLine: 16422
				EndLine: 16438
				NodeType: Function

					Alias: TrustedValueHolderType(trustedValue)
					StartLine: 16423
					EndLine: 16427
					NodeType: Function

						Alias: $$unwrapTrustedValue()
						StartLine: 16424
						EndLine: 16426
						NodeType: Function

					Alias: sceValueOf()
					StartLine: 16431
					EndLine: 16433
					NodeType: Function

					Alias: sceToString()
					StartLine: 16434
					EndLine: 16436
					NodeType: Function

				Alias: trustAs(type,trustedValue)
				StartLine: 16466
				EndLine: 16484
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $sceDelegate#trustAs&#A;     *&#A;     * @description&#A;     * Returns an object that is trusted by angular for use in specified strict&#A;     * contextual escaping contexts (such as ng-bind-html, ng-include, any src&#A;     * attribute interpolation, any dom event binding attribute interpolation&#A;     * such as for onclick,  etc.) that uses the provided value.&#A;     * See {@link ng.$sce $sce} for enabling strict contextual escaping.&#A;     *&#A;     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,&#A;     *   resourceUrl, html, js and css.&#A;     * @param {*} value The value that that should be considered trusted/safe.&#A;     * @returns {*} A value that can be used to stand in for the provided `value` in places&#A;     * where Angular expects a $sce.trustAs() return value.

				Alias: valueOf(maybeTrusted)
				StartLine: 16504
				EndLine: 16510
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $sceDelegate#valueOf&#A;     *&#A;     * @description&#A;     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs&#A;     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link&#A;     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.&#A;     *&#A;     * If the passed parameter is not a value that had been returned by {@link&#A;     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.&#A;     *&#A;     * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}&#A;     *      call or anything else.&#A;     * @returns {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs&#A;     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns&#A;     *     `value` unchanged.

				Alias: getTrusted(type,maybeTrusted)
				StartLine: 16527
				EndLine: 16550
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $sceDelegate#getTrusted&#A;     *&#A;     * @description&#A;     * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and&#A;     * returns the originally supplied value if the queried context type is a supertype of the&#A;     * created type.  If this condition isn&#39;t satisfied, throws an exception.&#A;     *&#A;     * @param {string} type The kind of context in which this value is to be used.&#A;     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs&#A;     *     `$sceDelegate.trustAs`} call.&#A;     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs&#A;     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.

				Alias: ?
				StartLine: 16552
				EndLine: 16554
				NodeType: Object

		Alias: $SceProvider()
		StartLine: 16840
		EndLine: 17236
		NodeType: Function

			Alias: enabled(value)
			StartLine: 16854
			EndLine: 16859
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $sceProvider#enabled&#A;   * @kind function&#A;   *&#A;   * @param {boolean=} value If provided, then enables/disables SCE.&#A;   * @return {boolean} true if SCE is enabled, false otherwise.&#A;   *&#A;   * @description&#A;   * Enables/disables SCE and returns the current value.

			Alias: ?($parse,$sceDelegate)
			StartLine: 16908
			EndLine: 17235
			NodeType: AnonymousFunction

				Alias: isEnabled()
				StartLine: 16932
				EndLine: 16934
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $sce#isEnabled&#A;     * @kind function&#A;     *&#A;     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you&#A;     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.&#A;     *&#A;     * @description&#A;     * Returns a boolean indicating if SCE is enabled.

				Alias: getTrusted.trustAs(type,value)
				StartLine: 16940
				EndLine: 16940
				NodeType: Function

				Alias: sceParseAs(type,expr)
				StartLine: 16963
				EndLine: 16972
				NodeType: Function
				Comment: *&#A;     * @ngdoc method&#A;     * @name $sce#parseAs&#A;     *&#A;     * @description&#A;     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link&#A;     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it&#A;     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,&#A;     * *result*)}&#A;     *&#A;     * @param {string} type The kind of SCE context in which this result will be used.&#A;     * @param {string} expression String expression to compile.&#A;     * @returns {function(context, locals)} a function which represents the compiled expression:&#A;     *&#A;     *    * `context` – `{object}` – an object against which any expressions embedded in the strings&#A;     *      are evaluated against (typically a scope object).&#A;     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in&#A;     *      `context`.

					Alias: $parse&gt;?(value)
					StartLine: 16968
					EndLine: 16970
					NodeType: AnonymousFunction

				Alias: forEach&gt;?(enumValue,name)
				StartLine: 17221
				EndLine: 17232
				NodeType: AnonymousFunction

					Alias: camelCase(expr)
					StartLine: 17223
					EndLine: 17225
					NodeType: Function

					Alias: camelCase(value)
					StartLine: 17226
					EndLine: 17228
					NodeType: Function

					Alias: camelCase(value)
					StartLine: 17229
					EndLine: 17231
					NodeType: Function

		Alias: $SnifferProvider()
		StartLine: 17252
		EndLine: 17323
		NodeType: Function
		Comment: *&#A; * !!! This is an undocumented &quot;private&quot; service !!!&#A; *&#A; * @name $sniffer&#A; * @requires $window&#A; * @requires $document&#A; *&#A; * @property {boolean} history Does the browser support html5 history api ?&#A; * @property {boolean} transitions Does the browser support CSS transition events ?&#A; * @property {boolean} animations Does the browser support CSS animation events ?&#A; *&#A; * @description&#A; * This is very simple implementation of testing browser&#39;s features.

			Alias: ?($window,$document)
			StartLine: 17253
			EndLine: 17322
			NodeType: AnonymousFunction

				Alias: ?
				StartLine: 17289
				EndLine: 17321
				NodeType: Object
				Comment: Android has history.pushState, but it does not update location correctly&#D;&#A; so let&#39;s not use the history API at all.&#D;&#A; http://code.google.com/p/android/issues/detail?id=17471&#D;&#A; https://github.com/angular/angular.js/issues/904

					Alias: hasEvent(event)
					StartLine: 17301
					EndLine: 17315
					NodeType: Function
					Comment: jshint +W018&#D;&#A; IE9 implements &#39;input&#39; event it&#39;s so fubared that we rather pretend that it doesn&#39;t have&#D;&#A; it. In particular the event is not fired when backspace or delete key are pressed or&#D;&#A; when cut operation is performed.&#D;&#A; IE10+ implements &#39;input&#39; event but it erroneously fires under various situations,&#D;&#A; e.g. when placeholder changes, or a form is focused.

		Alias: $TemplateRequestProvider()
		StartLine: 17344
		EndLine: 17386
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $templateRequest&#A; *&#A; * @description&#A; * The `$templateRequest` service downloads the provided template using `$http` and, upon success,&#A; * stores the contents inside of `$templateCache`. If the HTTP request fails or the response data&#A; * of the HTTP request is empty, a `$compile` error will be thrown (the exception can be thwarted&#A; * by setting the 2nd parameter of the function to true).&#A; *&#A; * @param {string} tpl The HTTP request template URL&#A; * @param {boolean=} ignoreRequestError Whether or not to ignore the exception when the request fails or the template is empty&#A; *&#A; * @return {Promise} a promise for the HTTP response data of the given URL.&#A; *&#A; * @property {number} totalPendingRequests total amount of pending template requests being downloaded.

			Alias: ?($templateCache,$http,$q)
			StartLine: 17345
			EndLine: 17385
			NodeType: AnonymousFunction

				Alias: handleRequestFn(tpl,ignoreRequestError)
				StartLine: 17346
				EndLine: 17380
				NodeType: Function

					Alias: filter.transformResponse&gt;?(transformer)
					StartLine: 17352
					EndLine: 17354
					NodeType: AnonymousFunction

					Alias: httpOptions
					StartLine: 17359
					EndLine: 17362
					NodeType: Object

					Alias: &#39;finally&#39;&gt;?()
					StartLine: 17365
					EndLine: 17367
					NodeType: AnonymousFunction

					Alias: then&gt;?(response)
					StartLine: 17368
					EndLine: 17371
					NodeType: AnonymousFunction

					Alias: handleError(resp)
					StartLine: 17373
					EndLine: 17379
					NodeType: Function

		Alias: $$TestabilityProvider()
		StartLine: 17388
		EndLine: 17501
		NodeType: Function

			Alias: ?($rootScope,$brow…location)
			StartLine: 17390
			EndLine: 17500
			NodeType: AnonymousFunction

				Alias: findBindings(element,expressi…actMatch)
				StartLine: 17413
				EndLine: 17434
				NodeType: Function
				Comment: *&#A;     * @name $$testability#findBindings&#A;     *&#A;     * @description&#A;     * Returns an array of elements that are bound (via ng-bind or {{}})&#A;     * to expressions matching the input.&#A;     *&#A;     * @param {Element} element The element root to search from.&#A;     * @param {string} expression The binding expression to match.&#A;     * @param {boolean} opt_exactMatch If true, only returns exact matches&#A;     *     for the expression. Filters and whitespace are ignored.

					Alias: forEach&gt;?(binding)
					StartLine: 17416
					EndLine: 17432
					NodeType: AnonymousFunction

						Alias: forEach&gt;?(bindingName)
						StartLine: 17419
						EndLine: 17430
						NodeType: AnonymousFunction

				Alias: findModels(element,expressi…actMatch)
				StartLine: 17448
				EndLine: 17458
				NodeType: Function
				Comment: *&#A;     * @name $$testability#findModels&#A;     *&#A;     * @description&#A;     * Returns an array of elements that are two-way found via ng-model to&#A;     * expressions matching the input.&#A;     *&#A;     * @param {Element} element The element root to search from.&#A;     * @param {string} expression The model expression to match.&#A;     * @param {boolean} opt_exactMatch If true, only returns exact matches&#A;     *     for the expression.

				Alias: getLocation()
				StartLine: 17467
				EndLine: 17469
				NodeType: Function
				Comment: *&#A;     * @name $$testability#getLocation&#A;     *&#A;     * @description&#A;     * Shortcut for getting the location in a browser agnostic way. Returns&#A;     *     the path, search, and hash. (e.g. /path?a=b#hash)

				Alias: setLocation(url)
				StartLine: 17480
				EndLine: 17485
				NodeType: Function
				Comment: *&#A;     * @name $$testability#setLocation&#A;     *&#A;     * @description&#A;     * Shortcut for navigating to a location without doing a full page reload.&#A;     *&#A;     * @param {string} url The location url (path, search and hash,&#A;     *     e.g. /path?a=b#hash) to go to.

				Alias: whenStable(callback)
				StartLine: 17495
				EndLine: 17497
				NodeType: Function
				Comment: *&#A;     * @name $$testability#whenStable&#A;     *&#A;     * @description&#A;     * Calls the callback when $timeout and $http requests are completed.&#A;     *&#A;     * @param {function} callback

		Alias: $TimeoutProvider()
		StartLine: 17503
		EndLine: 17596
		NodeType: Function

			Alias: ?($rootScope,$brow…nHandler)
			StartLine: 17505
			EndLine: 17595
			NodeType: AnonymousFunction

				Alias: timeout(fn,delay,invokeApply)
				StartLine: 17539
				EndLine: 17570
				NodeType: Function
				Comment: *&#A;      * @ngdoc service&#A;      * @name $timeout&#A;      *&#A;      * @description&#A;      * Angular&#39;s wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch&#A;      * block and delegates any exceptions to&#A;      * {@link ng.$exceptionHandler $exceptionHandler} service.&#A;      *&#A;      * The return value of calling `$timeout` is a promise, which will be resolved when&#A;      * the delay has passed and the timeout function, if provided, is executed.&#A;      *&#A;      * To cancel a timeout request, call `$timeout.cancel(promise)`.&#A;      *&#A;      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to&#A;      * synchronously flush the queue of deferred functions.&#A;      *&#A;      * If you only want a promise that will be resolved after some specified delay&#A;      * then you can call `$timeout` without the `fn` function.&#A;      *&#A;      * @param {function()=} fn A function, whose execution should be delayed.&#A;      * @param {number=} [delay=0] Delay in milliseconds.&#A;      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise&#A;      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.&#A;      * @param {...*=} Pass additional parameters to the executed function.&#A;      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this&#A;      *   promise will be resolved with is the return value of the `fn` function.&#A;      *

					Alias: defer.timeoutId&gt;?()
					StartLine: 17552
					EndLine: 17564
					NodeType: AnonymousFunction

				Alias: cancel(promise)
				StartLine: 17585
				EndLine: 17592
				NodeType: Function
				Comment: *&#A;      * @ngdoc method&#A;      * @name $timeout#cancel&#A;      *&#A;      * @description&#A;      * Cancels a task associated with the `promise`. As a result of this, the promise will be&#A;      * resolved with a rejection.&#A;      *&#A;      * @param {Promise=} promise Promise returned by the `$timeout` function.&#A;      * @returns {boolean} Returns `true` if the task hasn&#39;t executed yet and was successfully&#A;      *   canceled.

		Alias: urlResolve(url)
		StartLine: 17661
		EndLine: 17686
		NodeType: Function
		Comment: *&#A; *&#A; * Implementation Notes for non-IE browsers&#A; * ----------------------------------------&#A; * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,&#A; * results both in the normalizing and parsing of the URL.  Normalizing means that a relative&#A; * URL will be resolved into an absolute URL in the context of the application document.&#A; * Parsing means that the anchor node&#39;s host, hostname, protocol, port, pathname and related&#A; * properties are all populated to reflect the normalized URL.  This approach has wide&#A; * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See&#A; * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html&#A; *&#A; * Implementation Notes for IE&#A; * ---------------------------&#A; * IE &gt;= 8 and &lt;= 10 normalizes the URL when assigned to the anchor node similar to the other&#A; * browsers.  However, the parsed components will not be set if the URL assigned did not specify&#A; * them.  (e.g. if you assign a.href = &quot;foo&quot;, then a.protocol, a.host, etc. will be empty.)  We&#A; * work around that by performing the parsing in a 2nd step by taking a previously normalized&#A; * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the&#A; * properties such as protocol, hostname, port, etc.&#A; *&#A; * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one&#A; * uses the inner HTML approach to assign the URL as part of an HTML snippet -&#A; * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.&#A; * Unfortunately, setting img[src] to something like &quot;javascript:foo&quot; on IE throws an exception.&#A; * Since the primary usage for normalizing URLs is to sanitize such URLs, we can&#39;t use that&#A; * method and IE &lt; 8 is unsupported.&#A; *&#A; * References:&#A; *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement&#A; *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html&#A; *   http://url.spec.whatwg.org/#urlutils&#A; *   https://github.com/angular/angular.js/pull/2902&#A; *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/&#A; *&#A; * @kind function&#A; * @param {string} url The URL to be parsed.&#A; * @description Normalizes and parses a URL.&#A; * @returns {object} Returns the normalized URL as a dictionary.&#A; *&#A; *   | member name   | Description    |&#A; *   |---------------|----------------|&#A; *   | href          | A normalized version of the provided URL if it was not an absolute URL |&#A; *   | protocol      | The protocol including the trailing colon                              |&#A; *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |&#A; *   | search        | The search params, minus the question mark                             |&#A; *   | hash          | The hash string, minus the hash symbol&#A; *   | hostname      | The hostname&#A; *   | port          | The port, without &quot;:&quot;&#A; *   | pathname      | The pathname, beginning with &quot;/&quot;&#A; *

			Alias: ?
			StartLine: 17674
			EndLine: 17685
			NodeType: Object
			Comment: urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

		Alias: urlIsSameOrigin(requestUrl)
		StartLine: 17695
		EndLine: 17699
		NodeType: Function
		Comment: *&#A; * Parse a request URL and determine whether this is a same-origin request as the application document.&#A; *&#A; * @param {string|object} requestUrl The url of the request as a string that will be resolved&#A; * or a parsed URL object.&#A; * @returns {boolean} Whether the request is for the same origin as the application document.

		Alias: $WindowProvider()
		StartLine: 17742
		EndLine: 17744
		NodeType: Function
		Comment: *&#A; * @ngdoc service&#A; * @name $window&#A; *&#A; * @description&#A; * A reference to the browser&#39;s `window` object. While `window`&#A; * is globally available in JavaScript, it causes testability problems, because&#A; * it is a global variable. In angular we always refer to it through the&#A; * `$window` service, so it may be overridden, removed or mocked for testing.&#A; *&#A; * Expressions, like the one defined for the `ngClick` directive in the example&#A; * below, are evaluated with respect to the current scope.  Therefore, there is&#A; * no risk of inadvertently coding in a dependency on a global value in such an&#A; * expression.&#A; *&#A; * @example&#A;   &lt;example module=&quot;windowExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;         angular.module(&#39;windowExample&#39;, [])&#A;           .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, &#39;$window&#39;, function($scope, $window) {&#A;             $scope.greeting = &#39;Hello, World!&#39;;&#A;             $scope.doGreeting = function(greeting) {&#A;               $window.alert(greeting);&#A;             };&#A;           }]);&#A;       &lt;/script&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;input type=&quot;text&quot; ng-model=&quot;greeting&quot; aria-label=&quot;greeting&quot; /&gt;&#A;         &lt;button ng-click=&quot;doGreeting(greeting)&quot;&gt;ALERT&lt;/button&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      it(&#39;should display the greeting in the input box&#39;, function() {&#A;       element(by.model(&#39;greeting&#39;)).sendKeys(&#39;Hello, E2E Tests&#39;);&#A;       // If we click the button it will block the test runner&#A;       // element(&#39;:button&#39;).click();&#A;      });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

		Alias: $$CookieReader($document)
		StartLine: 17755
		EndLine: 17793
		NodeType: Function
		Comment: *&#A; * @name $$cookieReader&#A; * @requires $document&#A; *&#A; * @description&#A; * This is a private service for reading cookies used by $http and ngCookies&#A; *&#A; * @return {Object} a key/value map of the current cookies

			Alias: safeDecodeURIComponent(str)
			StartLine: 17760
			EndLine: 17766
			NodeType: Function

			Alias: ?()
			StartLine: 17768
			EndLine: 17792
			NodeType: AnonymousFunction

		Alias: $$CookieReaderProvider()
		StartLine: 17797
		EndLine: 17799
		NodeType: Function

		Alias: $FilterProvider($provide)
		StartLine: 17901
		EndLine: 17961
		NodeType: Function

			Alias: register(name,factory)
			StartLine: 17919
			EndLine: 17929
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name $filterProvider#register&#A;   * @param {string|Object} name Name of the filter function, or an object map of filters where&#A;   *    the keys are the filter names and the values are the filter factories.&#A;   *&#A;   *    &lt;div class=&quot;alert alert-warning&quot;&gt;&#A;   *    **Note:** Filter names must be valid angular {@link expression} identifiers, such as `uppercase` or `orderBy`.&#A;   *    Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace&#A;   *    your filters, then you can use capitalization (`myappSubsectionFilterx`) or underscores&#A;   *    (`myapp_subsection_filterx`).&#A;   *    &lt;/div&gt;&#A;   * @returns {Object} Registered filter instance, or if a map of filters was provided then a map&#A;   *    of the registered filter instances.

				Alias: forEach&gt;?(filter,key)
				StartLine: 17922
				EndLine: 17924
				NodeType: AnonymousFunction

			Alias: ?($injector)
			StartLine: 17932
			EndLine: 17936
			NodeType: AnonymousFunction

				Alias: ?(name)
				StartLine: 17933
				EndLine: 17935
				NodeType: AnonymousFunction

		Alias: filterFilter()
		StartLine: 18088
		EndLine: 18122
		NodeType: Function
		Comment: *&#A; * @ngdoc filter&#A; * @name filter&#A; * @kind function&#A; *&#A; * @description&#A; * Selects a subset of items from `array` and returns it as a new array.&#A; *&#A; * @param {Array} array The source array.&#A; * @param {string|Object|function()} expression The predicate to be used for selecting items from&#A; *   `array`.&#A; *&#A; *   Can be one of:&#A; *&#A; *   - `string`: The string is used for matching against the contents of the `array`. All strings or&#A; *     objects with string properties in `array` that match this string will be returned. This also&#A; *     applies to nested object properties.&#A; *     The predicate can be negated by prefixing the string with `!`.&#A; *&#A; *   - `Object`: A pattern object can be used to filter specific properties on objects contained&#A; *     by `array`. For example `{name:&quot;M&quot;, phone:&quot;1&quot;}` predicate will return an array of items&#A; *     which have property `name` containing &quot;M&quot; and property `phone` containing &quot;1&quot;. A special&#A; *     property name `$` can be used (as in `{$:&quot;text&quot;}`) to accept a match against any&#A; *     property of the object or its nested object properties. That&#39;s equivalent to the simple&#A; *     substring match with a `string` as described above. The predicate can be negated by prefixing&#A; *     the string with `!`.&#A; *     For example `{name: &quot;!M&quot;}` predicate will return an array of items which have property `name`&#A; *     not containing &quot;M&quot;.&#A; *&#A; *     Note that a named property will match properties on the same level only, while the special&#A; *     `$` property will match properties on the same level or deeper. E.g. an array item like&#A; *     `{name: {first: &#39;John&#39;, last: &#39;Doe&#39;}}` will **not** be matched by `{name: &#39;John&#39;}`, but&#A; *     **will** be matched by `{$: &#39;John&#39;}`.&#A; *&#A; *   - `function(value, index)`: A predicate function can be used to write arbitrary filters. The&#A; *     function is called for each element of `array`. The final result is an array of those&#A; *     elements that the predicate returned true for.&#A; *&#A; * @param {function(actual, expected)|true|undefined} comparator Comparator which is used in&#A; *     determining if the expected value (from the filter expression) and actual value (from&#A; *     the object in the array) should be considered a match.&#A; *&#A; *   Can be one of:&#A; *&#A; *   - `function(actual, expected)`:&#A; *     The function will be given the object value and the predicate value to compare and&#A; *     should return true if both values should be considered equal.&#A; *&#A; *   - `true`: A shorthand for `function(actual, expected) { return angular.equals(actual, expected)}`.&#A; *     This is essentially strict comparison of expected and actual.&#A; *&#A; *   - `false|undefined`: A short hand for a function which will look for a substring match in case&#A; *     insensitive way.&#A; *&#A; *     Primitive values are converted to strings. Objects are not compared against primitives,&#A; *     unless they have a custom `toString` method (e.g. `Date` objects).&#A; *&#A; * @example&#A;   &lt;example&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;div ng-init=&quot;friends = [{name:&#39;John&#39;, phone:&#39;555-1276&#39;},&#A;                                {name:&#39;Mary&#39;, phone:&#39;800-BIG-MARY&#39;},&#A;                                {name:&#39;Mike&#39;, phone:&#39;555-4321&#39;},&#A;                                {name:&#39;Adam&#39;, phone:&#39;555-5678&#39;},&#A;                                {name:&#39;Julie&#39;, phone:&#39;555-8765&#39;},&#A;                                {name:&#39;Juliette&#39;, phone:&#39;555-5678&#39;}]&quot;&gt;&lt;/div&gt;&#A;&#A;       &lt;label&gt;Search: &lt;input ng-model=&quot;searchText&quot;&gt;&lt;/label&gt;&#A;       &lt;table id=&quot;searchTextResults&quot;&gt;&#A;         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;&#A;         &lt;tr ng-repeat=&quot;friend in friends | filter:searchText&quot;&gt;&#A;           &lt;td&gt;{{friend.name}}&lt;/td&gt;&#A;           &lt;td&gt;{{friend.phone}}&lt;/td&gt;&#A;         &lt;/tr&gt;&#A;       &lt;/table&gt;&#A;       &lt;hr&gt;&#A;       &lt;label&gt;Any: &lt;input ng-model=&quot;search.$&quot;&gt;&lt;/label&gt; &lt;br&gt;&#A;       &lt;label&gt;Name only &lt;input ng-model=&quot;search.name&quot;&gt;&lt;/label&gt;&lt;br&gt;&#A;       &lt;label&gt;Phone only &lt;input ng-model=&quot;search.phone&quot;&gt;&lt;/label&gt;&lt;br&gt;&#A;       &lt;label&gt;Equality &lt;input type=&quot;checkbox&quot; ng-model=&quot;strict&quot;&gt;&lt;/label&gt;&lt;br&gt;&#A;       &lt;table id=&quot;searchObjResults&quot;&gt;&#A;         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;&#A;         &lt;tr ng-repeat=&quot;friendObj in friends | filter:search:strict&quot;&gt;&#A;           &lt;td&gt;{{friendObj.name}}&lt;/td&gt;&#A;           &lt;td&gt;{{friendObj.phone}}&lt;/td&gt;&#A;         &lt;/tr&gt;&#A;       &lt;/table&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       var expectFriendNames = function(expectedNames, key) {&#A;         element.all(by.repeater(key + &#39; in friends&#39;).column(key + &#39;.name&#39;)).then(function(arr) {&#A;           arr.forEach(function(wd, i) {&#A;             expect(wd.getText()).toMatch(expectedNames[i]);&#A;           });&#A;         });&#A;       };&#A;&#A;       it(&#39;should search across all fields when filtering with a string&#39;, function() {&#A;         var searchText = element(by.model(&#39;searchText&#39;));&#A;         searchText.clear();&#A;         searchText.sendKeys(&#39;m&#39;);&#A;         expectFriendNames([&#39;Mary&#39;, &#39;Mike&#39;, &#39;Adam&#39;], &#39;friend&#39;);&#A;&#A;         searchText.clear();&#A;         searchText.sendKeys(&#39;76&#39;);&#A;         expectFriendNames([&#39;John&#39;, &#39;Julie&#39;], &#39;friend&#39;);&#A;       });&#A;&#A;       it(&#39;should search in specific fields when filtering with a predicate object&#39;, function() {&#A;         var searchAny = element(by.model(&#39;search.$&#39;));&#A;         searchAny.clear();&#A;         searchAny.sendKeys(&#39;i&#39;);&#A;         expectFriendNames([&#39;Mary&#39;, &#39;Mike&#39;, &#39;Julie&#39;, &#39;Juliette&#39;], &#39;friendObj&#39;);&#A;       });&#A;       it(&#39;should use a equal comparison when comparator is true&#39;, function() {&#A;         var searchName = element(by.model(&#39;search.name&#39;));&#A;         var strict = element(by.model(&#39;strict&#39;));&#A;         searchName.clear();&#A;         searchName.sendKeys(&#39;Julie&#39;);&#A;         strict.click();&#A;         expectFriendNames([&#39;Julie&#39;], &#39;friendObj&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ?(array,expression…mparator)
			StartLine: 18089
			EndLine: 18121
			NodeType: AnonymousFunction

		Alias: hasCustomToString(obj)
		StartLine: 18124
		EndLine: 18126
		NodeType: Function

		Alias: createPredicateFn(expression,compa…tAnyProp)
		StartLine: 18129
		EndLine: 18164
		NodeType: Function
		Comment: Helper functions for `filterFilter`

			Alias: comparator(actual,expected)
			StartLine: 18136
			EndLine: 18153
			NodeType: Function

			Alias: predicateFn(item)
			StartLine: 18156
			EndLine: 18161
			NodeType: Function

		Alias: deepCompare(actual,expected,…leObject)
		StartLine: 18166
		EndLine: 18213
		NodeType: Function

			Alias: some&gt;?(item)
			StartLine: 18175
			EndLine: 18177
			NodeType: AnonymousFunction
			Comment: In case `actual` is an array, consider it a match&#D;&#A; if ANY of it&#39;s items matches `expected`

		Alias: getTypeForFilter(val)
		StartLine: 18216
		EndLine: 18218
		NodeType: Function
		Comment: Used for easily differentiating between `null` and actual `object`

		Alias: currencyFilter($locale)
		StartLine: 18273
		EndLine: 18290
		NodeType: Function

			Alias: ?(amount,currencyS…tionSize)
			StartLine: 18275
			EndLine: 18289
			NodeType: AnonymousFunction

		Alias: numberFilter($locale)
		StartLine: 18346
		EndLine: 18356
		NodeType: Function

			Alias: ?(number,fractionSize)
			StartLine: 18348
			EndLine: 18355
			NodeType: AnonymousFunction

		Alias: formatNumber(number,pattern,g…tionSize)
		StartLine: 18359
		EndLine: 18444
		NodeType: Function

		Alias: padNumber(num,digits,trim)
		StartLine: 18446
		EndLine: 18458
		NodeType: Function

		Alias: dateGetter(name,size,offset,trim)
		StartLine: 18461
		EndLine: 18471
		NodeType: Function

			Alias: ?(date)
			StartLine: 18463
			EndLine: 18470
			NodeType: AnonymousFunction

		Alias: dateStrGetter(name,shortForm)
		StartLine: 18473
		EndLine: 18480
		NodeType: Function

			Alias: ?(date,formats)
			StartLine: 18474
			EndLine: 18479
			NodeType: AnonymousFunction

		Alias: timeZoneGetter(date,formats,offset)
		StartLine: 18482
		EndLine: 18490
		NodeType: Function

		Alias: getFirstThursdayOfYear(year)
		StartLine: 18492
		EndLine: 18498
		NodeType: Function
		Comment: 0 = index of January

		Alias: getThursdayThisWeek(datetime)
		StartLine: 18500
		EndLine: 18504
		NodeType: Function

		Alias: weekGetter(size)
		StartLine: 18506
		EndLine: 18516
		NodeType: Function

			Alias: ?(date)
			StartLine: 18507
			EndLine: 18515
			NodeType: AnonymousFunction

		Alias: ampmGetter(date,formats)
		StartLine: 18518
		EndLine: 18520
		NodeType: Function

		Alias: eraGetter(date,formats)
		StartLine: 18522
		EndLine: 18524
		NodeType: Function

		Alias: longEraGetter(date,formats)
		StartLine: 18526
		EndLine: 18528
		NodeType: Function

		Alias: DATE_FORMATS
		StartLine: 18530
		EndLine: 18561
		NodeType: Object

		Alias: dateFilter($locale)
		StartLine: 18660
		EndLine: 18733
		NodeType: Function

			Alias: jsonStringToDate(string)
			StartLine: 18665
			EndLine: 18687
			NodeType: Function
			Comment: 1        2       3         4          5          6          7          8  9     10      11

			Alias: ?(date,format,timezone)
			StartLine: 18690
			EndLine: 18732
			NodeType: AnonymousFunction

				Alias: forEach&gt;?(value)
				StartLine: 18725
				EndLine: 18729
				NodeType: AnonymousFunction

		Alias: jsonFilter()
		StartLine: 18767
		EndLine: 18774
		NodeType: Function
		Comment: *&#A; * @ngdoc filter&#A; * @name json&#A; * @kind function&#A; *&#A; * @description&#A; *   Allows you to convert a JavaScript object into JSON string.&#A; *&#A; *   This filter is mostly useful for debugging. When using the double curly {{value}} notation&#A; *   the binding is automatically converted to JSON.&#A; *&#A; * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.&#A; * @param {number=} spacing The number of spaces to use per indentation, defaults to 2.&#A; * @returns {string} JSON string.&#A; *&#A; *&#A; * @example&#A;   &lt;example&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;pre id=&quot;default-spacing&quot;&gt;{{ {&#39;name&#39;:&#39;value&#39;} | json }}&lt;/pre&gt;&#A;       &lt;pre id=&quot;custom-spacing&quot;&gt;{{ {&#39;name&#39;:&#39;value&#39;} | json:4 }}&lt;/pre&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should jsonify filtered objects&#39;, function() {&#A;         expect(element(by.id(&#39;default-spacing&#39;)).getText()).toMatch(/\{\n  &quot;name&quot;: ?&quot;value&quot;\n}/);&#A;         expect(element(by.id(&#39;custom-spacing&#39;)).getText()).toMatch(/\{\n    &quot;name&quot;: ?&quot;value&quot;\n}/);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;&#A; *

			Alias: ?(object,spacing)
			StartLine: 18768
			EndLine: 18773
			NodeType: AnonymousFunction

		Alias: limitToFilter()
		StartLine: 18896
		EndLine: 18921
		NodeType: Function
		Comment: *&#A; * @ngdoc filter&#A; * @name limitTo&#A; * @kind function&#A; *&#A; * @description&#A; * Creates a new array or string containing only a specified number of elements. The elements&#A; * are taken from either the beginning or the end of the source array, string or number, as specified by&#A; * the value and sign (positive or negative) of `limit`. If a number is used as input, it is&#A; * converted to a string.&#A; *&#A; * @param {Array|string|number} input Source array, string or number to be limited.&#A; * @param {string|number} limit The length of the returned array or string. If the `limit` number&#A; *     is positive, `limit` number of items from the beginning of the source array/string are copied.&#A; *     If the number is negative, `limit` number  of items from the end of the source array/string&#A; *     are copied. The `limit` will be trimmed if it exceeds `array.length`. If `limit` is undefined,&#A; *     the input will be returned unchanged.&#A; * @param {(string|number)=} begin Index at which to begin limitation. As a negative index, `begin`&#A; *     indicates an offset from the end of `input`. Defaults to `0`.&#A; * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array&#A; *     had less than `limit` elements.&#A; *&#A; * @example&#A;   &lt;example module=&quot;limitToExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;         angular.module(&#39;limitToExample&#39;, [])&#A;           .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;             $scope.numbers = [1,2,3,4,5,6,7,8,9];&#A;             $scope.letters = &quot;abcdefghi&quot;;&#A;             $scope.longNumber = 2345432342;&#A;             $scope.numLimit = 3;&#A;             $scope.letterLimit = 3;&#A;             $scope.longNumberLimit = 3;&#A;           }]);&#A;       &lt;/script&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;label&gt;&#A;            Limit {{numbers}} to:&#A;            &lt;input type=&quot;number&quot; step=&quot;1&quot; ng-model=&quot;numLimit&quot;&gt;&#A;         &lt;/label&gt;&#A;         &lt;p&gt;Output numbers: {{ numbers | limitTo:numLimit }}&lt;/p&gt;&#A;         &lt;label&gt;&#A;            Limit {{letters}} to:&#A;            &lt;input type=&quot;number&quot; step=&quot;1&quot; ng-model=&quot;letterLimit&quot;&gt;&#A;         &lt;/label&gt;&#A;         &lt;p&gt;Output letters: {{ letters | limitTo:letterLimit }}&lt;/p&gt;&#A;         &lt;label&gt;&#A;            Limit {{longNumber}} to:&#A;            &lt;input type=&quot;number&quot; step=&quot;1&quot; ng-model=&quot;longNumberLimit&quot;&gt;&#A;         &lt;/label&gt;&#A;         &lt;p&gt;Output long number: {{ longNumber | limitTo:longNumberLimit }}&lt;/p&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       var numLimitInput = element(by.model(&#39;numLimit&#39;));&#A;       var letterLimitInput = element(by.model(&#39;letterLimit&#39;));&#A;       var longNumberLimitInput = element(by.model(&#39;longNumberLimit&#39;));&#A;       var limitedNumbers = element(by.binding(&#39;numbers | limitTo:numLimit&#39;));&#A;       var limitedLetters = element(by.binding(&#39;letters | limitTo:letterLimit&#39;));&#A;       var limitedLongNumber = element(by.binding(&#39;longNumber | limitTo:longNumberLimit&#39;));&#A;&#A;       it(&#39;should limit the number array to first three items&#39;, function() {&#A;         expect(numLimitInput.getAttribute(&#39;value&#39;)).toBe(&#39;3&#39;);&#A;         expect(letterLimitInput.getAttribute(&#39;value&#39;)).toBe(&#39;3&#39;);&#A;         expect(longNumberLimitInput.getAttribute(&#39;value&#39;)).toBe(&#39;3&#39;);&#A;         expect(limitedNumbers.getText()).toEqual(&#39;Output numbers: [1,2,3]&#39;);&#A;         expect(limitedLetters.getText()).toEqual(&#39;Output letters: abc&#39;);&#A;         expect(limitedLongNumber.getText()).toEqual(&#39;Output long number: 234&#39;);&#A;       });&#A;&#A;       // There is a bug in safari and protractor that doesn&#39;t like the minus key&#A;       // it(&#39;should update the output when -3 is entered&#39;, function() {&#A;       //   numLimitInput.clear();&#A;       //   numLimitInput.sendKeys(&#39;-3&#39;);&#A;       //   letterLimitInput.clear();&#A;       //   letterLimitInput.sendKeys(&#39;-3&#39;);&#A;       //   longNumberLimitInput.clear();&#A;       //   longNumberLimitInput.sendKeys(&#39;-3&#39;);&#A;       //   expect(limitedNumbers.getText()).toEqual(&#39;Output numbers: [7,8,9]&#39;);&#A;       //   expect(limitedLetters.getText()).toEqual(&#39;Output letters: ghi&#39;);&#A;       //   expect(limitedLongNumber.getText()).toEqual(&#39;Output long number: 342&#39;);&#A;       // });&#A;&#A;       it(&#39;should not exceed the maximum size of input array&#39;, function() {&#A;         numLimitInput.clear();&#A;         numLimitInput.sendKeys(&#39;100&#39;);&#A;         letterLimitInput.clear();&#A;         letterLimitInput.sendKeys(&#39;100&#39;);&#A;         longNumberLimitInput.clear();&#A;         longNumberLimitInput.sendKeys(&#39;100&#39;);&#A;         expect(limitedNumbers.getText()).toEqual(&#39;Output numbers: [1,2,3,4,5,6,7,8,9]&#39;);&#A;         expect(limitedLetters.getText()).toEqual(&#39;Output letters: abcdefghi&#39;);&#A;         expect(limitedLongNumber.getText()).toEqual(&#39;Output long number: 2345432342&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ?(input,limit,begin)
			StartLine: 18897
			EndLine: 18920
			NodeType: AnonymousFunction

		Alias: orderByFilter($parse)
		StartLine: 19076
		EndLine: 19162
		NodeType: Function

			Alias: ?(array,sortPredic…rseOrder)
			StartLine: 19077
			EndLine: 19161
			NodeType: AnonymousFunction

				Alias: map.sortPredicate&gt;?(predicate)
				StartLine: 19081
				EndLine: 19103
				NodeType: AnonymousFunction

					Alias: reverseComparator&gt;?(a,b)
					StartLine: 19095
					EndLine: 19097
					NodeType: AnonymousFunction

					Alias: reverseComparator&gt;?(a,b)
					StartLine: 19100
					EndLine: 19102
					NodeType: AnonymousFunction

				Alias: comparator(o1,o2)
				StartLine: 19106
				EndLine: 19112
				NodeType: Function

				Alias: reverseComparator(comp,descending)
				StartLine: 19113
				EndLine: 19117
				NodeType: Function

				Alias: isPrimitive(value)
				StartLine: 19119
				EndLine: 19128
				NodeType: Function

				Alias: objectToString(value)
				StartLine: 19130
				EndLine: 19141
				NodeType: Function

				Alias: compare(v1,v2)
				StartLine: 19143
				EndLine: 19160
				NodeType: Function

		Alias: ngDirective(directive)
		StartLine: 19164
		EndLine: 19172
		NodeType: Function

			Alias: directive
			StartLine: 19166
			EndLine: 19168
			NodeType: Object

		Alias: valueFn.htmlAnchorDirective&gt;?
		StartLine: 19187
		EndLine: 19207
		NodeType: Object
		Comment: *&#A; * @ngdoc directive&#A; * @name a&#A; * @restrict E&#A; *&#A; * @description&#A; * Modifies the default behavior of the html A tag so that the default action is prevented when&#A; * the href attribute is empty.&#A; *&#A; * This change permits the easy creation of action links with the `ngClick` directive&#A; * without changing the location or causing page reloads, e.g.:&#A; * `&lt;a href=&quot;&quot; ng-click=&quot;list.addItem()&quot;&gt;Add Item&lt;/a&gt;`

			Alias: compile(element,attr)
			StartLine: 19189
			EndLine: 19206
			NodeType: Function

				Alias: ?(scope,element)
				StartLine: 19191
				EndLine: 19204
				NodeType: AnonymousFunction
				Comment: If the linked element is not an anchor tag anymore, do nothing

					Alias: on&gt;?(event)
					StartLine: 19198
					EndLine: 19203
					NodeType: AnonymousFunction
					Comment: if we have no href url, then don&#39;t navigate anywhere.

		Alias: forEach&gt;?(propName,attrName)
		StartLine: 19555
		EndLine: 19584
		NodeType: AnonymousFunction
		Comment: boolean attrs are evaluated&#D;&#A; binding to multiple is not supported

			Alias: defaultLinkFn(scope,element,attr)
			StartLine: 19559
			EndLine: 19563
			NodeType: Function

				Alias: ngBooleanAttrWatchAction(value)
				StartLine: 19560
				EndLine: 19562
				NodeType: Function

			Alias: linkFn(scope,element,attr)
			StartLine: 19569
			EndLine: 19574
			NodeType: Function
			Comment: ensuring ngChecked doesn&#39;t interfere with ngModel when both are set on the same input

			Alias: normalized()
			StartLine: 19577
			EndLine: 19583
			NodeType: Function

				Alias: ?
				StartLine: 19578
				EndLine: 19582
				NodeType: Object

		Alias: forEach&gt;?(htmlAttr,ngAttr)
		StartLine: 19587
		EndLine: 19608
		NodeType: AnonymousFunction
		Comment: aliased input attrs are evaluated

			Alias: ngAttr()
			StartLine: 19588
			EndLine: 19607
			NodeType: Function

				Alias: ?
				StartLine: 19589
				EndLine: 19606
				NodeType: Object

					Alias: link(scope,element,attr)
					StartLine: 19591
					EndLine: 19605
					NodeType: Function
					Comment: special case ngPattern when a literal regular expression value&#D;&#A;is used as the expression (this way we don&#39;t have to watch anything).

						Alias: ngAttrAliasWatchAction(value)
						StartLine: 19602
						EndLine: 19604
						NodeType: Function

		Alias: forEach&gt;?(attrName)
		StartLine: 19611
		EndLine: 19646
		NodeType: AnonymousFunction
		Comment: ng-src, ng-srcset, ng-href are interpolated

			Alias: normalized()
			StartLine: 19613
			EndLine: 19645
			NodeType: Function

				Alias: ?
				StartLine: 19614
				EndLine: 19644
				NodeType: Object
				Comment: it needs to run after the attributes are interpolated

					Alias: link(scope,element,attr)
					StartLine: 19616
					EndLine: 19643
					NodeType: Function

						Alias: $observe&gt;?(value)
						StartLine: 19627
						EndLine: 19642
						NodeType: AnonymousFunction

		Alias: nullFormCtrl
		StartLine: 19650
		EndLine: 19658
		NodeType: Object
		Comment: global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true

		Alias: nullFormRenameControl(control,name)
		StartLine: 19661
		EndLine: 19663
		NodeType: Function

		Alias: FormController(element,attrs,$s…erpolate)
		StartLine: 19708
		EndLine: 19929
		NodeType: Function

			Alias: $rollbackViewValue()
			StartLine: 19738
			EndLine: 19742
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$rollbackViewValue&#A;   *&#A;   * @description&#A;   * Rollback all form controls pending updates to the `$modelValue`.&#A;   *&#A;   * Updates may be pending by a debounced event or because the input is waiting for a some future&#A;   * event defined in `ng-model-options`. This method is typically needed by the reset button of&#A;   * a form that uses `ng-model-options` to pend updates.

				Alias: forEach&gt;?(control)
				StartLine: 19739
				EndLine: 19741
				NodeType: AnonymousFunction

			Alias: $commitViewValue()
			StartLine: 19755
			EndLine: 19759
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$commitViewValue&#A;   *&#A;   * @description&#A;   * Commit all form controls pending updates to the `$modelValue`.&#A;   *&#A;   * Updates may be pending by a debounced event or because the input is waiting for a some future&#A;   * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`&#A;   * usually handles calling this in response to input events.

				Alias: forEach&gt;?(control)
				StartLine: 19756
				EndLine: 19758
				NodeType: AnonymousFunction

			Alias: $addControl(control)
			StartLine: 19770
			EndLine: 19779
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$addControl&#A;   *&#A;   * @description&#A;   * Register a control with the form.&#A;   *&#A;   * Input elements using ngModelController do this automatically when they are linked.&#A;   &#D;&#A; Breaking change - before, inputs whose name was &quot;hasOwnProperty&quot; were quietly ignored&#D;&#A; and not added to the scope.  Now we throw an error.

			Alias: $$renameControl(control,newName)
			StartLine: 19782
			EndLine: 19790
			NodeType: Function
			Comment: Private API: rename a form control

			Alias: $removeControl(control)
			StartLine: 19801
			EndLine: 19816
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$removeControl&#A;   *&#A;   * @description&#A;   * Deregister a control from the form.&#A;   *&#A;   * Input elements using ngModelController do this automatically when they are destroyed.

				Alias: forEach&gt;?(value,name)
				StartLine: 19805
				EndLine: 19807
				NodeType: AnonymousFunction

				Alias: forEach&gt;?(value,name)
				StartLine: 19808
				EndLine: 19810
				NodeType: AnonymousFunction

				Alias: forEach&gt;?(value,name)
				StartLine: 19811
				EndLine: 19813
				NodeType: AnonymousFunction

			Alias: addSetValidityMethod&gt;?
			StartLine: 19828
			EndLine: 19854
			NodeType: Object
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$setValidity&#A;   *&#A;   * @description&#A;   * Sets the validity of a form control.&#A;   *&#A;   * This method will also propagate to parent forms.

				Alias: set(object,property,…ntroller)
				StartLine: 19831
				EndLine: 19841
				NodeType: Function

				Alias: unset(object,property,…ntroller)
				StartLine: 19842
				EndLine: 19851
				NodeType: Function

			Alias: $setDirty()
			StartLine: 19866
			EndLine: 19872
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$setDirty&#A;   *&#A;   * @description&#A;   * Sets the form to a dirty state.&#A;   *&#A;   * This method can be called to add the &#39;ng-dirty&#39; class and set the form to a dirty&#A;   * state (ng-dirty class). This method will also propagate to parent forms.

			Alias: $setPristine()
			StartLine: 19888
			EndLine: 19896
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$setPristine&#A;   *&#A;   * @description&#A;   * Sets the form to its pristine state.&#A;   *&#A;   * This method can be called to remove the &#39;ng-dirty&#39; class and set the form to its pristine&#A;   * state (ng-pristine class). This method will also propagate to all the controls contained&#A;   * in this form.&#A;   *&#A;   * Setting a form back to a pristine state is often useful when we want to &#39;reuse&#39; a form after&#A;   * saving or resetting it.

				Alias: forEach&gt;?(control)
				StartLine: 19893
				EndLine: 19895
				NodeType: AnonymousFunction

			Alias: $setUntouched()
			StartLine: 19911
			EndLine: 19915
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$setUntouched&#A;   *&#A;   * @description&#A;   * Sets the form to its untouched state.&#A;   *&#A;   * This method can be called to remove the &#39;ng-touched&#39; class and set the form controls to their&#A;   * untouched state (ng-untouched class).&#A;   *&#A;   * Setting a form controls back to their untouched state is often useful when setting the form&#A;   * back to its pristine state.

				Alias: forEach&gt;?(control)
				StartLine: 19912
				EndLine: 19914
				NodeType: AnonymousFunction

			Alias: $setSubmitted()
			StartLine: 19924
			EndLine: 19928
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name form.FormController#$setSubmitted&#A;   *&#A;   * @description&#A;   * Sets the form to its submitted state.

		Alias: formDirectiveFactory(isNgForm)
		StartLine: 20096
		EndLine: 20163
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @name form&#A; * @restrict E&#A; *&#A; * @description&#A; * Directive that instantiates&#A; * {@link form.FormController FormController}.&#A; *&#A; * If the `name` attribute is specified, the form controller is published onto the current scope under&#A; * this name.&#A; *&#A; * # Alias: {@link ng.directive:ngForm `ngForm`}&#A; *&#A; * In Angular, forms can be nested. This means that the outer form is valid when all of the child&#A; * forms are valid as well. However, browsers do not allow nesting of `&lt;form&gt;` elements, so&#A; * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to&#A; * `&lt;form&gt;` but can be nested.  This allows you to have nested forms, which is very useful when&#A; * using Angular validation directives in forms that are dynamically generated using the&#A; * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`&#A; * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an&#A; * `ngForm` directive and nest these in an outer `form` element.&#A; *&#A; *&#A; * # CSS classes&#A; *  - `ng-valid` is set if the form is valid.&#A; *  - `ng-invalid` is set if the form is invalid.&#A; *  - `ng-pristine` is set if the form is pristine.&#A; *  - `ng-dirty` is set if the form is dirty.&#A; *  - `ng-submitted` is set if the form was submitted.&#A; *&#A; * Keep in mind that ngAnimate can detect each of these classes when added and removed.&#A; *&#A; *&#A; * # Submitting a form and preventing the default action&#A; *&#A; * Since the role of forms in client-side Angular applications is different than in classical&#A; * roundtrip apps, it is desirable for the browser not to translate the form submission into a full&#A; * page reload that sends the data to the server. Instead some javascript logic should be triggered&#A; * to handle the form submission in an application-specific way.&#A; *&#A; * For this reason, Angular prevents the default action (form submission to the server) unless the&#A; * `&lt;form&gt;` element has an `action` attribute specified.&#A; *&#A; * You can use one of the following two ways to specify what javascript method should be called when&#A; * a form is submitted:&#A; *&#A; * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element&#A; * - {@link ng.directive:ngClick ngClick} directive on the first&#A;  *  button or input field of type submit (input[type=submit])&#A; *&#A; * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}&#A; * or {@link ng.directive:ngClick ngClick} directives.&#A; * This is because of the following form submission rules in the HTML specification:&#A; *&#A; * - If a form has only one input field then hitting enter in this field triggers form submit&#A; * (`ngSubmit`)&#A; * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter&#A; * doesn&#39;t trigger submit&#A; * - if a form has one or more input fields and one or more buttons or input[type=submit] then&#A; * hitting enter in any of the input fields will trigger the click handler on the *first* button or&#A; * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)&#A; *&#A; * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is&#A; * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`&#A; * to have access to the updated model.&#A; *&#A; * ## Animation Hooks&#A; *&#A; * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.&#A; * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any&#A; * other validations that are performed within the form. Animations in ngForm are similar to how&#A; * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well&#A; * as JS animations.&#A; *&#A; * The following example shows a simple way to utilize CSS transitions to style a form element&#A; * that has been rendered as invalid after it has been validated:&#A; *&#A; * &lt;pre&gt;&#A; * //be sure to include ngAnimate as a module to hook into more&#A; * //advanced animations&#A; * .my-form {&#A; *   transition:0.5s linear all;&#A; *   background: white;&#A; * }&#A; * .my-form.ng-invalid {&#A; *   background: red;&#A; *   color:white;&#A; * }&#A; * &lt;/pre&gt;&#A; *&#A; * @example&#A;    &lt;example deps=&quot;angular-animate.js&quot; animations=&quot;true&quot; fixBase=&quot;true&quot; module=&quot;formExample&quot;&gt;&#A;      &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;         angular.module(&#39;formExample&#39;, [])&#A;           .controller(&#39;FormController&#39;, [&#39;$scope&#39;, function($scope) {&#A;             $scope.userType = &#39;guest&#39;;&#A;           }]);&#A;       &lt;/script&gt;&#A;       &lt;style&gt;&#A;        .my-form {&#A;          -webkit-transition:all linear 0.5s;&#A;          transition:all linear 0.5s;&#A;          background: transparent;&#A;        }&#A;        .my-form.ng-invalid {&#A;          background: red;&#A;        }&#A;       &lt;/style&gt;&#A;       &lt;form name=&quot;myForm&quot; ng-controller=&quot;FormController&quot; class=&quot;my-form&quot;&gt;&#A;         userType: &lt;input name=&quot;input&quot; ng-model=&quot;userType&quot; required&gt;&#A;         &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;Required!&lt;/span&gt;&lt;br&gt;&#A;         &lt;code&gt;userType = {{userType}}&lt;/code&gt;&lt;br&gt;&#A;         &lt;code&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/code&gt;&lt;br&gt;&#A;         &lt;code&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/code&gt;&lt;br&gt;&#A;         &lt;code&gt;myForm.$valid = {{myForm.$valid}}&lt;/code&gt;&lt;br&gt;&#A;         &lt;code&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/code&gt;&lt;br&gt;&#A;        &lt;/form&gt;&#A;      &lt;/file&gt;&#A;      &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;        it(&#39;should initialize to model&#39;, function() {&#A;          var userType = element(by.binding(&#39;userType&#39;));&#A;          var valid = element(by.binding(&#39;myForm.input.$valid&#39;));&#A;&#A;          expect(userType.getText()).toContain(&#39;guest&#39;);&#A;          expect(valid.getText()).toContain(&#39;true&#39;);&#A;        });&#A;&#A;        it(&#39;should be invalid if empty&#39;, function() {&#A;          var userType = element(by.binding(&#39;userType&#39;));&#A;          var valid = element(by.binding(&#39;myForm.input.$valid&#39;));&#A;          var userInput = element(by.model(&#39;userType&#39;));&#A;&#A;          userInput.clear();&#A;          userInput.sendKeys(&#39;&#39;);&#A;&#A;          expect(userType.getText()).toEqual(&#39;userType =&#39;);&#A;          expect(valid.getText()).toContain(&#39;false&#39;);&#A;        });&#A;      &lt;/file&gt;&#A;    &lt;/example&gt;&#A; *&#A; * @param {string=} name Name of the form. If specified, the form controller will be published into&#A; *                       related scope, under this name.

			Alias: ?($timeout)
			StartLine: 20097
			EndLine: 20162
			NodeType: AnonymousFunction

				Alias: formDirective
				StartLine: 20098
				EndLine: 20159
				NodeType: Object

					Alias: ngFormCompile(formElement,attr)
					StartLine: 20102
					EndLine: 20158
					NodeType: Function
					Comment: Setup initial state of the control

						Alias: ?
						StartLine: 20108
						EndLine: 20157
						NodeType: Object

							Alias: ngFormPreLink(scope,formElemen…ntroller)
							StartLine: 20109
							EndLine: 20156
							NodeType: Function
							Comment: if `action` attr is not present on the form, prevent the default action (submission)

								Alias: handleFormSubmission(event)
								StartLine: 20118
								EndLine: 20125
								NodeType: Function
								Comment: we can&#39;t use jq events because if a form is destroyed during submission the default&#D;&#A; action is not prevented. see #1238&#D;&#A;&#D;&#A; IE 9 is not affected because it doesn&#39;t fire a submit event and try to do a full&#D;&#A; page reload if the form was destroyed by submission of the form via a click handler&#D;&#A; on a button in the form. Looks like an IE9 specific bug.

									Alias: $apply&gt;?()
									StartLine: 20119
									EndLine: 20122
									NodeType: AnonymousFunction

								Alias: on&gt;?()
								StartLine: 20131
								EndLine: 20135
								NodeType: AnonymousFunction
								Comment: unregister the preventDefault listener so that we don&#39;t not leak memory but in a&#D;&#A; way that will achieve the prevention of the default action.

									Alias: $timeout&gt;?()
									StartLine: 20132
									EndLine: 20134
									NodeType: AnonymousFunction

								Alias: $observe&gt;?(newValue)
								StartLine: 20142
								EndLine: 20147
								NodeType: AnonymousFunction

								Alias: on&gt;?()
								StartLine: 20149
								EndLine: 20155
								NodeType: AnonymousFunction

		Alias: inputType
		StartLine: 20188
		EndLine: 21172
		NodeType: Object

		Alias: stringBasedInputType(ctrl)
		StartLine: 21174
		EndLine: 21178
		NodeType: Function

			Alias: push&gt;?(value)
			StartLine: 21175
			EndLine: 21177
			NodeType: AnonymousFunction

		Alias: textInputType(scope,element,at…$browser)
		StartLine: 21180
		EndLine: 21183
		NodeType: Function

		Alias: baseInputType(scope,element,at…$browser)
		StartLine: 21185
		EndLine: 21269
		NodeType: Function

			Alias: on&gt;?(data)
			StartLine: 21194
			EndLine: 21196
			NodeType: AnonymousFunction

			Alias: on&gt;?()
			StartLine: 21198
			EndLine: 21201
			NodeType: AnonymousFunction

			Alias: listener(ev)
			StartLine: 21204
			EndLine: 21226
			NodeType: Function

			Alias: deferListener(ev,input,origValue)
			StartLine: 21235
			EndLine: 21244
			NodeType: Function

				Alias: defer.timeout&gt;?()
				StartLine: 21237
				EndLine: 21242
				NodeType: AnonymousFunction

			Alias: on&gt;?(event)
			StartLine: 21246
			EndLine: 21254
			NodeType: AnonymousFunction

			Alias: $render()
			StartLine: 21266
			EndLine: 21268
			NodeType: Function

		Alias: weekParser(isoWeek,existingDate)
		StartLine: 21271
		EndLine: 21301
		NodeType: Function

		Alias: createDateParser(regexp,mapping)
		StartLine: 21303
		EndLine: 21351
		NodeType: Function

			Alias: ?(iso,date)
			StartLine: 21304
			EndLine: 21350
			NodeType: AnonymousFunction

				Alias: map
				StartLine: 21327
				EndLine: 21335
				NodeType: Object

				Alias: map
				StartLine: 21337
				EndLine: 21337
				NodeType: Object

				Alias: forEach&gt;?(part,index)
				StartLine: 21340
				EndLine: 21344
				NodeType: AnonymousFunction

		Alias: createDateInputType(type,regexp,pars…e,format)
		StartLine: 21353
		EndLine: 21423
		NodeType: Function

			Alias: dynamicDateInputType(scope,element,at…,$filter)
			StartLine: 21354
			EndLine: 21422
			NodeType: Function

				Alias: push&gt;?(value)
				StartLine: 21361
				EndLine: 21374
				NodeType: AnonymousFunction

				Alias: push&gt;?(value)
				StartLine: 21376
				EndLine: 21390
				NodeType: AnonymousFunction

				Alias: min(value)
				StartLine: 21394
				EndLine: 21396
				NodeType: Function

				Alias: $observe&gt;?(val)
				StartLine: 21397
				EndLine: 21400
				NodeType: AnonymousFunction

				Alias: max(value)
				StartLine: 21405
				EndLine: 21407
				NodeType: Function

				Alias: $observe&gt;?(val)
				StartLine: 21408
				EndLine: 21411
				NodeType: AnonymousFunction

				Alias: isValidDate(value)
				StartLine: 21414
				EndLine: 21417
				NodeType: Function
				Comment: Invalid Date: getTime() returns NaN

				Alias: parseObservedDateValue(val)
				StartLine: 21419
				EndLine: 21421
				NodeType: Function

		Alias: badInputChecker(scope,element,attr,ctrl)
		StartLine: 21425
		EndLine: 21438
		NodeType: Function

			Alias: push&gt;?(value)
			StartLine: 21429
			EndLine: 21436
			NodeType: AnonymousFunction

		Alias: numberInputType(scope,element,at…$browser)
		StartLine: 21440
		EndLine: 21492
		NodeType: Function

			Alias: push&gt;?(value)
			StartLine: 21445
			EndLine: 21449
			NodeType: AnonymousFunction

			Alias: push&gt;?(value)
			StartLine: 21451
			EndLine: 21459
			NodeType: AnonymousFunction

			Alias: min(value)
			StartLine: 21463
			EndLine: 21465
			NodeType: Function

			Alias: $observe&gt;?(val)
			StartLine: 21467
			EndLine: 21474
			NodeType: AnonymousFunction

			Alias: max(value)
			StartLine: 21479
			EndLine: 21481
			NodeType: Function

			Alias: $observe&gt;?(val)
			StartLine: 21483
			EndLine: 21490
			NodeType: AnonymousFunction

		Alias: urlInputType(scope,element,at…$browser)
		StartLine: 21494
		EndLine: 21505
		NodeType: Function
		Comment: Note: no badInputChecker here by purpose as `url` is only a validation&#D;&#A; in browsers, i.e. we can always read out input.value even if it is not valid!

			Alias: url(modelValue,viewValue)
			StartLine: 21501
			EndLine: 21504
			NodeType: Function

		Alias: emailInputType(scope,element,at…$browser)
		StartLine: 21507
		EndLine: 21518
		NodeType: Function
		Comment: Note: no badInputChecker here by purpose as `url` is only a validation&#D;&#A; in browsers, i.e. we can always read out input.value even if it is not valid!

			Alias: email(modelValue,viewValue)
			StartLine: 21514
			EndLine: 21517
			NodeType: Function

		Alias: radioInputType(scope,element,attr,ctrl)
		StartLine: 21520
		EndLine: 21540
		NodeType: Function
		Comment: make the name unique, if not defined

			Alias: listener(ev)
			StartLine: 21526
			EndLine: 21530
			NodeType: Function

			Alias: $render()
			StartLine: 21534
			EndLine: 21537
			NodeType: Function

		Alias: parseConstantExpr($parse,context,n…fallback)
		StartLine: 21542
		EndLine: 21553
		NodeType: Function

		Alias: checkboxInputType(scope,element,at…r,$parse)
		StartLine: 21555
		EndLine: 21583
		NodeType: Function

			Alias: listener(ev)
			StartLine: 21559
			EndLine: 21561
			NodeType: Function

			Alias: $render()
			StartLine: 21565
			EndLine: 21567
			NodeType: Function

			Alias: $isEmpty(value)
			StartLine: 21572
			EndLine: 21574
			NodeType: Function
			Comment: Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`&#D;&#A; This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert&#D;&#A; it to a boolean.

			Alias: push&gt;?(value)
			StartLine: 21576
			EndLine: 21578
			NodeType: AnonymousFunction

			Alias: push&gt;?(value)
			StartLine: 21580
			EndLine: 21582
			NodeType: AnonymousFunction

		Alias: ?($browser,$sniffe…r,$parse)
		StartLine: 21748
		EndLine: 21761
		NodeType: AnonymousFunction

			Alias: ?
			StartLine: 21749
			EndLine: 21760
			NodeType: Object

				Alias: link
				StartLine: 21752
				EndLine: 21759
				NodeType: Object

					Alias: pre(scope,element,attr,ctrls)
					StartLine: 21753
					EndLine: 21758
					NodeType: Function

		Alias: ngValueDirective()
		StartLine: 21823
		EndLine: 21841
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @name ngValue&#A; *&#A; * @description&#A; * Binds the given expression to the value of `&lt;option&gt;` or {@link input[radio] `input[radio]`},&#A; * so that when the element is selected, the {@link ngModel `ngModel`} of that element is set to&#A; * the bound value.&#A; *&#A; * `ngValue` is useful when dynamically generating lists of radio buttons using&#A; * {@link ngRepeat `ngRepeat`}, as shown below.&#A; *&#A; * Likewise, `ngValue` can be used to generate `&lt;option&gt;` elements for&#A; * the {@link select `select`} element. In that case however, only strings are supported&#A; * for the `value `attribute, so the resulting `ngModel` will always be a string.&#A; * Support for `select` models with non-string values is available via `ngOptions`.&#A; *&#A; * @element input&#A; * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute&#A; *   of the `input` element&#A; *&#A; * @example&#A;    &lt;example name=&quot;ngValue-directive&quot; module=&quot;valueExample&quot;&gt;&#A;      &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;          angular.module(&#39;valueExample&#39;, [])&#A;            .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;              $scope.names = [&#39;pizza&#39;, &#39;unicorns&#39;, &#39;robots&#39;];&#A;              $scope.my = { favorite: &#39;unicorns&#39; };&#A;            }]);&#A;       &lt;/script&gt;&#A;        &lt;form ng-controller=&quot;ExampleController&quot;&gt;&#A;          &lt;h2&gt;Which is your favorite?&lt;/h2&gt;&#A;            &lt;label ng-repeat=&quot;name in names&quot; for=&quot;{{name}}&quot;&gt;&#A;              {{name}}&#A;              &lt;input type=&quot;radio&quot;&#A;                     ng-model=&quot;my.favorite&quot;&#A;                     ng-value=&quot;name&quot;&#A;                     id=&quot;{{name}}&quot;&#A;                     name=&quot;favorite&quot;&gt;&#A;            &lt;/label&gt;&#A;          &lt;div&gt;You chose {{my.favorite}}&lt;/div&gt;&#A;        &lt;/form&gt;&#A;      &lt;/file&gt;&#A;      &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;        var favorite = element(by.binding(&#39;my.favorite&#39;));&#A;&#A;        it(&#39;should initialize to model&#39;, function() {&#A;          expect(favorite.getText()).toContain(&#39;unicorns&#39;);&#A;        });&#A;        it(&#39;should bind the values to the inputs&#39;, function() {&#A;          element.all(by.model(&#39;my.favorite&#39;)).get(0).click();&#A;          expect(favorite.getText()).toContain(&#39;pizza&#39;);&#A;        });&#A;      &lt;/file&gt;&#A;    &lt;/example&gt;

			Alias: ?
			StartLine: 21824
			EndLine: 21840
			NodeType: Object

				Alias: compile(tpl,tplAttr)
				StartLine: 21827
				EndLine: 21839
				NodeType: Function

					Alias: ngValueConstantLink(scope,elm,attr)
					StartLine: 21829
					EndLine: 21831
					NodeType: Function

					Alias: ngValueLink(scope,elm,attr)
					StartLine: 21833
					EndLine: 21837
					NodeType: Function

						Alias: valueWatchAction(value)
						StartLine: 21834
						EndLine: 21836
						NodeType: Function

		Alias: ?($compile)
		StartLine: 21894
		EndLine: 21908
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngBind&#A; * @restrict AC&#A; *&#A; * @description&#A; * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element&#A; * with the value of a given expression, and to update the text content when the value of that&#A; * expression changes.&#A; *&#A; * Typically, you don&#39;t use `ngBind` directly, but instead you use the double curly markup like&#A; * `{{ expression }}` which is similar but less verbose.&#A; *&#A; * It is preferable to use `ngBind` instead of `{{ expression }}` if a template is momentarily&#A; * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an&#A; * element attribute, it makes the bindings invisible to the user while the page is loading.&#A; *&#A; * An alternative solution to this problem would be using the&#A; * {@link ng.directive:ngCloak ngCloak} directive.&#A; *&#A; *&#A; * @element ANY&#A; * @param {expression} ngBind {@link guide/expression Expression} to evaluate.&#A; *&#A; * @example&#A; * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.&#A;   &lt;example module=&quot;bindExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;         angular.module(&#39;bindExample&#39;, [])&#A;           .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;             $scope.name = &#39;Whirled&#39;;&#A;           }]);&#A;       &lt;/script&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;label&gt;Enter name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/label&gt;&lt;br&gt;&#A;         Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;!&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should check ng-bind&#39;, function() {&#A;         var nameInput = element(by.model(&#39;name&#39;));&#A;&#A;         expect(element(by.binding(&#39;name&#39;)).getText()).toBe(&#39;Whirled&#39;);&#A;         nameInput.clear();&#A;         nameInput.sendKeys(&#39;world&#39;);&#A;         expect(element(by.binding(&#39;name&#39;)).getText()).toBe(&#39;world&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ?
			StartLine: 21895
			EndLine: 21907
			NodeType: Object

				Alias: ngBindCompile(templateElement)
				StartLine: 21897
				EndLine: 21906
				NodeType: Function

					Alias: ngBindLink(scope,element,attr)
					StartLine: 21899
					EndLine: 21905
					NodeType: Function

						Alias: ngBindWatchAction(value)
						StartLine: 21902
						EndLine: 21904
						NodeType: Function

		Alias: ?($interpolate,$compile)
		StartLine: 21962
		EndLine: 21976
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngBindTemplate&#A; *&#A; * @description&#A; * The `ngBindTemplate` directive specifies that the element&#A; * text content should be replaced with the interpolation of the template&#A; * in the `ngBindTemplate` attribute.&#A; * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`&#A; * expressions. This directive is needed since some HTML elements&#A; * (such as TITLE and OPTION) cannot contain SPAN elements.&#A; *&#A; * @element ANY&#A; * @param {string} ngBindTemplate template of form&#A; *   &lt;tt&gt;{{&lt;/tt&gt; &lt;tt&gt;expression&lt;/tt&gt; &lt;tt&gt;}}&lt;/tt&gt; to eval.&#A; *&#A; * @example&#A; * Try it here: enter text in text box and watch the greeting change.&#A;   &lt;example module=&quot;bindExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;         angular.module(&#39;bindExample&#39;, [])&#A;           .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;             $scope.salutation = &#39;Hello&#39;;&#A;             $scope.name = &#39;World&#39;;&#A;           }]);&#A;       &lt;/script&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;        &lt;label&gt;Salutation: &lt;input type=&quot;text&quot; ng-model=&quot;salutation&quot;&gt;&lt;/label&gt;&lt;br&gt;&#A;        &lt;label&gt;Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/label&gt;&lt;br&gt;&#A;        &lt;pre ng-bind-template=&quot;{{salutation}} {{name}}!&quot;&gt;&lt;/pre&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should check ng-bind&#39;, function() {&#A;         var salutationElem = element(by.binding(&#39;salutation&#39;));&#A;         var salutationInput = element(by.model(&#39;salutation&#39;));&#A;         var nameInput = element(by.model(&#39;name&#39;));&#A;&#A;         expect(salutationElem.getText()).toBe(&#39;Hello World!&#39;);&#A;&#A;         salutationInput.clear();&#A;         salutationInput.sendKeys(&#39;Greetings&#39;);&#A;         nameInput.clear();&#A;         nameInput.sendKeys(&#39;user&#39;);&#A;&#A;         expect(salutationElem.getText()).toBe(&#39;Greetings user!&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ?
			StartLine: 21963
			EndLine: 21975
			NodeType: Object

				Alias: ngBindTemplateCompile(templateElement)
				StartLine: 21964
				EndLine: 21974
				NodeType: Function

					Alias: ngBindTemplateLink(scope,element,attr)
					StartLine: 21966
					EndLine: 21973
					NodeType: Function

						Alias: $observe&gt;?(value)
						StartLine: 21970
						EndLine: 21972
						NodeType: AnonymousFunction

		Alias: ?($sce,$parse,$compile)
		StartLine: 22026
		EndLine: 22047
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngBindHtml&#A; *&#A; * @description&#A; * Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default,&#A; * the resulting HTML content will be sanitized using the {@link ngSanitize.$sanitize $sanitize} service.&#A; * To utilize this functionality, ensure that `$sanitize` is available, for example, by including {@link&#A; * ngSanitize} in your module&#39;s dependencies (not in core Angular). In order to use {@link ngSanitize}&#A; * in your module&#39;s dependencies, you need to include &quot;angular-sanitize.js&quot; in your application.&#A; *&#A; * You may also bypass sanitization for values you know are safe. To do so, bind to&#A; * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example&#A; * under {@link ng.$sce#show-me-an-example-using-sce- Strict Contextual Escaping (SCE)}.&#A; *&#A; * Note: If a `$sanitize` service is unavailable and the bound value isn&#39;t explicitly trusted, you&#A; * will have an exception (instead of an exploit.)&#A; *&#A; * @element ANY&#A; * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.&#A; *&#A; * @example&#A;&#A;   &lt;example module=&quot;bindHtmlExample&quot; deps=&quot;angular-sanitize.js&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;        &lt;p ng-bind-html=&quot;myHTML&quot;&gt;&lt;/p&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;&#A;     &lt;file name=&quot;script.js&quot;&gt;&#A;       angular.module(&#39;bindHtmlExample&#39;, [&#39;ngSanitize&#39;])&#A;         .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;           $scope.myHTML =&#A;              &#39;I am an &lt;code&gt;HTML&lt;/code&gt;string with &#39; +&#A;              &#39;&lt;a href=&quot;#&quot;&gt;links!&lt;/a&gt; and other &lt;em&gt;stuff&lt;/em&gt;&#39;;&#A;         }]);&#A;     &lt;/file&gt;&#A;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should check ng-bind-html&#39;, function() {&#A;         expect(element(by.binding(&#39;myHTML&#39;)).getText()).toBe(&#A;             &#39;I am an HTMLstring with links! and other stuff&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ?
			StartLine: 22027
			EndLine: 22046
			NodeType: Object

				Alias: ngBindHtmlCompile(tElement,tAttrs)
				StartLine: 22029
				EndLine: 22045
				NodeType: Function

					Alias: getStringValue(value)
					StartLine: 22031
					EndLine: 22033
					NodeType: Function

					Alias: ngBindHtmlLink(scope,element,attr)
					StartLine: 22036
					EndLine: 22044
					NodeType: Function

						Alias: ngBindHtmlWatchAction()
						StartLine: 22039
						EndLine: 22043
						NodeType: Function
						Comment: we re-evaluate the expr because we want a TrustedValueHolderType&#D;&#A; for $sce, not a string

		Alias: valueFn.ngChangeDirective&gt;?
		StartLine: 22116
		EndLine: 22124
		NodeType: Object
		Comment: *&#A; * @ngdoc directive&#A; * @name ngChange&#A; *&#A; * @description&#A; * Evaluate the given expression when the user changes the input.&#A; * The expression is evaluated immediately, unlike the JavaScript onchange event&#A; * which only triggers at the end of a change (usually, when the user leaves the&#A; * form element or presses the return key).&#A; *&#A; * The `ngChange` expression is only evaluated when a change in the input value causes&#A; * a new value to be committed to the model.&#A; *&#A; * It will not be evaluated:&#A; * * if the value returned from the `$parsers` transformation pipeline has not changed&#A; * * if the input has continued to be invalid since the model will stay `null`&#A; * * if the model is changed programmatically and not by a change to the input value&#A; *&#A; *&#A; * Note, this directive requires `ngModel` to be present.&#A; *&#A; * @element input&#A; * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change&#A; * in input value.&#A; *&#A; * @example&#A; * &lt;example name=&quot;ngChange-directive&quot; module=&quot;changeExample&quot;&gt;&#A; *   &lt;file name=&quot;index.html&quot;&gt;&#A; *     &lt;script&gt;&#A; *       angular.module(&#39;changeExample&#39;, [])&#A; *         .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A; *           $scope.counter = 0;&#A; *           $scope.change = function() {&#A; *             $scope.counter++;&#A; *           };&#A; *         }]);&#A; *     &lt;/script&gt;&#A; *     &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A; *       &lt;input type=&quot;checkbox&quot; ng-model=&quot;confirmed&quot; ng-change=&quot;change()&quot; id=&quot;ng-change-example1&quot; /&gt;&#A; *       &lt;input type=&quot;checkbox&quot; ng-model=&quot;confirmed&quot; id=&quot;ng-change-example2&quot; /&gt;&#A; *       &lt;label for=&quot;ng-change-example2&quot;&gt;Confirmed&lt;/label&gt;&lt;br /&gt;&#A; *       &lt;tt&gt;debug = {{confirmed}}&lt;/tt&gt;&lt;br/&gt;&#A; *       &lt;tt&gt;counter = {{counter}}&lt;/tt&gt;&lt;br/&gt;&#A; *     &lt;/div&gt;&#A; *   &lt;/file&gt;&#A; *   &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A; *     var counter = element(by.binding(&#39;counter&#39;));&#A; *     var debug = element(by.binding(&#39;confirmed&#39;));&#A; *&#A; *     it(&#39;should evaluate the expression if changing from view&#39;, function() {&#A; *       expect(counter.getText()).toContain(&#39;0&#39;);&#A; *&#A; *       element(by.id(&#39;ng-change-example1&#39;)).click();&#A; *&#A; *       expect(counter.getText()).toContain(&#39;1&#39;);&#A; *       expect(debug.getText()).toContain(&#39;true&#39;);&#A; *     });&#A; *&#A; *     it(&#39;should not evaluate the expression if changing from model&#39;, function() {&#A; *       element(by.id(&#39;ng-change-example2&#39;)).click();&#A;&#A; *       expect(counter.getText()).toContain(&#39;0&#39;);&#A; *       expect(debug.getText()).toContain(&#39;true&#39;);&#A; *     });&#A; *   &lt;/file&gt;&#A; * &lt;/example&gt;

			Alias: link(scope,element,attr,ctrl)
			StartLine: 22119
			EndLine: 22123
			NodeType: Function

				Alias: push&gt;?()
				StartLine: 22120
				EndLine: 22122
				NodeType: AnonymousFunction

		Alias: classDirective(name,selector)
		StartLine: 22126
		EndLine: 22243
		NodeType: Function

			Alias: ?($animate)
			StartLine: 22128
			EndLine: 22242
			NodeType: AnonymousFunction

				Alias: ?
				StartLine: 22129
				EndLine: 22207
				NodeType: Object

					Alias: link(scope,element,attr)
					StartLine: 22131
					EndLine: 22206
					NodeType: Function

						Alias: $observe&gt;?(value)
						StartLine: 22136
						EndLine: 22138
						NodeType: AnonymousFunction

						Alias: $watch&gt;?($index,old$index)
						StartLine: 22142
						EndLine: 22151
						NodeType: AnonymousFunction
						Comment: jshint bitwise: false

						Alias: addClasses(classes)
						StartLine: 22154
						EndLine: 22157
						NodeType: Function

						Alias: removeClasses(classes)
						StartLine: 22159
						EndLine: 22162
						NodeType: Function

						Alias: digestClassCounts(classes,count)
						StartLine: 22164
						EndLine: 22179
						NodeType: Function
						Comment: Use createMap() to prevent class assumptions involving property&#D;&#A; names in Object.prototype

							Alias: forEach&gt;?(className)
							StartLine: 22169
							EndLine: 22176
							NodeType: AnonymousFunction

						Alias: updateClasses(oldClasses,newClasses)
						StartLine: 22181
						EndLine: 22192
						NodeType: Function

						Alias: ngClassWatchAction(newVal)
						StartLine: 22194
						EndLine: 22205
						NodeType: Function

				Alias: arrayDifference(tokens1,tokens2)
				StartLine: 22209
				EndLine: 22221
				NodeType: Function

				Alias: arrayClasses(classVal)
				StartLine: 22223
				EndLine: 22241
				NodeType: Function

					Alias: forEach&gt;?(v)
					StartLine: 22226
					EndLine: 22228
					NodeType: AnonymousFunction

					Alias: forEach&gt;?(v,k)
					StartLine: 22233
					EndLine: 22237
					NodeType: AnonymousFunction

		Alias: ngDirective.ngCloakDirective&gt;?
		StartLine: 22569
		EndLine: 22574
		NodeType: Object
		Comment: *&#A; * @ngdoc directive&#A; * @name ngCloak&#A; * @restrict AC&#A; *&#A; * @description&#A; * The `ngCloak` directive is used to prevent the Angular html template from being briefly&#A; * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this&#A; * directive to avoid the undesirable flicker effect caused by the html template display.&#A; *&#A; * The directive can be applied to the `&lt;body&gt;` element, but the preferred usage is to apply&#A; * multiple `ngCloak` directives to small portions of the page to permit progressive rendering&#A; * of the browser view.&#A; *&#A; * `ngCloak` works in cooperation with the following css rule embedded within `angular.js` and&#A; * `angular.min.js`.&#A; * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).&#A; *&#A; * ```css&#A; * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {&#A; *   display: none !important;&#A; * }&#A; * ```&#A; *&#A; * When this css rule is loaded by the browser, all html elements (including their children) that&#A; * are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive&#A; * during the compilation of the template it deletes the `ngCloak` element attribute, making&#A; * the compiled element visible.&#A; *&#A; * For the best result, the `angular.js` script must be loaded in the head section of the html&#A; * document; alternatively, the css rule above must be included in the external stylesheet of the&#A; * application.&#A; *&#A; * @element ANY&#A; *&#A; * @example&#A;   &lt;example&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;        &lt;div id=&quot;template1&quot; ng-cloak&gt;{{ &#39;hello&#39; }}&lt;/div&gt;&#A;        &lt;div id=&quot;template2&quot; class=&quot;ng-cloak&quot;&gt;{{ &#39;world&#39; }}&lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should remove the template directive and css class&#39;, function() {&#A;         expect($(&#39;#template1&#39;).getAttribute(&#39;ng-cloak&#39;)).&#A;           toBeNull();&#A;         expect($(&#39;#template2&#39;).getAttribute(&#39;ng-cloak&#39;)).&#A;           toBeNull();&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;&#A; *

			Alias: compile(element,attr)
			StartLine: 22570
			EndLine: 22573
			NodeType: Function

		Alias: ?()
		StartLine: 22802
		EndLine: 22809
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngController&#A; *&#A; * @description&#A; * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular&#A; * supports the principles behind the Model-View-Controller design pattern.&#A; *&#A; * MVC components in angular:&#A; *&#A; * * Model — Models are the properties of a scope; scopes are attached to the DOM where scope properties&#A; *   are accessed through bindings.&#A; * * View — The template (HTML with data bindings) that is rendered into the View.&#A; * * Controller — The `ngController` directive specifies a Controller class; the class contains business&#A; *   logic behind the application to decorate the scope with functions and values&#A; *&#A; * Note that you can also attach controllers to the DOM by declaring it in a route definition&#A; * via the {@link ngRoute.$route $route} service. A common mistake is to declare the controller&#A; * again using `ng-controller` in the template itself.  This will cause the controller to be attached&#A; * and executed twice.&#A; *&#A; * @element ANY&#A; * @scope&#A; * @priority 500&#A; * @param {expression} ngController Name of a constructor function registered with the current&#A; * {@link ng.$controllerProvider $controllerProvider} or an {@link guide/expression expression}&#A; * that on the current scope evaluates to a constructor function.&#A; *&#A; * The controller instance can be published into a scope property by specifying&#A; * `ng-controller=&quot;as propertyName&quot;`.&#A; *&#A; * If the current `$controllerProvider` is configured to use globals (via&#A; * {@link ng.$controllerProvider#allowGlobals `$controllerProvider.allowGlobals()` }), this may&#A; * also be the name of a globally accessible constructor function (not recommended).&#A; *&#A; * @example&#A; * Here is a simple form for editing user contact information. Adding, removing, clearing, and&#A; * greeting are methods declared on the controller (see source tab). These methods can&#A; * easily be called from the angular markup. Any changes to the data are automatically reflected&#A; * in the View without the need for a manual update.&#A; *&#A; * Two different declaration styles are included below:&#A; *&#A; * * one binds methods and properties directly onto the controller using `this`:&#A; * `ng-controller=&quot;SettingsController1 as settings&quot;`&#A; * * one injects `$scope` into the controller:&#A; * `ng-controller=&quot;SettingsController2&quot;`&#A; *&#A; * The second option is more common in the Angular community, and is generally used in boilerplates&#A; * and in this guide. However, there are advantages to binding properties directly to the controller&#A; * and avoiding scope.&#A; *&#A; * * Using `controller as` makes it obvious which controller you are accessing in the template when&#A; * multiple controllers apply to an element.&#A; * * If you are writing your controllers as classes you have easier access to the properties and&#A; * methods, which will appear on the scope, from inside the controller code.&#A; * * Since there is always a `.` in the bindings, you don&#39;t have to worry about prototypal&#A; * inheritance masking primitives.&#A; *&#A; * This example demonstrates the `controller as` syntax.&#A; *&#A; * &lt;example name=&quot;ngControllerAs&quot; module=&quot;controllerAsExample&quot;&gt;&#A; *   &lt;file name=&quot;index.html&quot;&gt;&#A; *    &lt;div id=&quot;ctrl-as-exmpl&quot; ng-controller=&quot;SettingsController1 as settings&quot;&gt;&#A; *      &lt;label&gt;Name: &lt;input type=&quot;text&quot; ng-model=&quot;settings.name&quot;/&gt;&lt;/label&gt;&#A; *      &lt;button ng-click=&quot;settings.greet()&quot;&gt;greet&lt;/button&gt;&lt;br/&gt;&#A; *      Contact:&#A; *      &lt;ul&gt;&#A; *        &lt;li ng-repeat=&quot;contact in settings.contacts&quot;&gt;&#A; *          &lt;select ng-model=&quot;contact.type&quot; aria-label=&quot;Contact method&quot; id=&quot;select_{{$index}}&quot;&gt;&#A; *             &lt;option&gt;phone&lt;/option&gt;&#A; *             &lt;option&gt;email&lt;/option&gt;&#A; *          &lt;/select&gt;&#A; *          &lt;input type=&quot;text&quot; ng-model=&quot;contact.value&quot; aria-labelledby=&quot;select_{{$index}}&quot; /&gt;&#A; *          &lt;button ng-click=&quot;settings.clearContact(contact)&quot;&gt;clear&lt;/button&gt;&#A; *          &lt;button ng-click=&quot;settings.removeContact(contact)&quot; aria-label=&quot;Remove&quot;&gt;X&lt;/button&gt;&#A; *        &lt;/li&gt;&#A; *        &lt;li&gt;&lt;button ng-click=&quot;settings.addContact()&quot;&gt;add&lt;/button&gt;&lt;/li&gt;&#A; *     &lt;/ul&gt;&#A; *    &lt;/div&gt;&#A; *   &lt;/file&gt;&#A; *   &lt;file name=&quot;app.js&quot;&gt;&#A; *    angular.module(&#39;controllerAsExample&#39;, [])&#A; *      .controller(&#39;SettingsController1&#39;, SettingsController1);&#A; *&#A; *    function SettingsController1() {&#A; *      this.name = &quot;John Smith&quot;;&#A; *      this.contacts = [&#A; *        {type: &#39;phone&#39;, value: &#39;408 555 1212&#39;},&#A; *        {type: &#39;email&#39;, value: &#39;john.smith@example.org&#39;} ];&#A; *    }&#A; *&#A; *    SettingsController1.prototype.greet = function() {&#A; *      alert(this.name);&#A; *    };&#A; *&#A; *    SettingsController1.prototype.addContact = function() {&#A; *      this.contacts.push({type: &#39;email&#39;, value: &#39;yourname@example.org&#39;});&#A; *    };&#A; *&#A; *    SettingsController1.prototype.removeContact = function(contactToRemove) {&#A; *     var index = this.contacts.indexOf(contactToRemove);&#A; *      this.contacts.splice(index, 1);&#A; *    };&#A; *&#A; *    SettingsController1.prototype.clearContact = function(contact) {&#A; *      contact.type = &#39;phone&#39;;&#A; *      contact.value = &#39;&#39;;&#A; *    };&#A; *   &lt;/file&gt;&#A; *   &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A; *     it(&#39;should check controller as&#39;, function() {&#A; *       var container = element(by.id(&#39;ctrl-as-exmpl&#39;));&#A; *         expect(container.element(by.model(&#39;settings.name&#39;))&#A; *           .getAttribute(&#39;value&#39;)).toBe(&#39;John Smith&#39;);&#A; *&#A; *       var firstRepeat =&#A; *           container.element(by.repeater(&#39;contact in settings.contacts&#39;).row(0));&#A; *       var secondRepeat =&#A; *           container.element(by.repeater(&#39;contact in settings.contacts&#39;).row(1));&#A; *&#A; *       expect(firstRepeat.element(by.model(&#39;contact.value&#39;)).getAttribute(&#39;value&#39;))&#A; *           .toBe(&#39;408 555 1212&#39;);&#A; *&#A; *       expect(secondRepeat.element(by.model(&#39;contact.value&#39;)).getAttribute(&#39;value&#39;))&#A; *           .toBe(&#39;john.smith@example.org&#39;);&#A; *&#A; *       firstRepeat.element(by.buttonText(&#39;clear&#39;)).click();&#A; *&#A; *       expect(firstRepeat.element(by.model(&#39;contact.value&#39;)).getAttribute(&#39;value&#39;))&#A; *           .toBe(&#39;&#39;);&#A; *&#A; *       container.element(by.buttonText(&#39;add&#39;)).click();&#A; *&#A; *       expect(container.element(by.repeater(&#39;contact in settings.contacts&#39;).row(2))&#A; *           .element(by.model(&#39;contact.value&#39;))&#A; *           .getAttribute(&#39;value&#39;))&#A; *           .toBe(&#39;yourname@example.org&#39;);&#A; *     });&#A; *   &lt;/file&gt;&#A; * &lt;/example&gt;&#A; *&#A; * This example demonstrates the &quot;attach to `$scope`&quot; style of controller.&#A; *&#A; * &lt;example name=&quot;ngController&quot; module=&quot;controllerExample&quot;&gt;&#A; *  &lt;file name=&quot;index.html&quot;&gt;&#A; *   &lt;div id=&quot;ctrl-exmpl&quot; ng-controller=&quot;SettingsController2&quot;&gt;&#A; *     &lt;label&gt;Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt;&lt;/label&gt;&#A; *     &lt;button ng-click=&quot;greet()&quot;&gt;greet&lt;/button&gt;&lt;br/&gt;&#A; *     Contact:&#A; *     &lt;ul&gt;&#A; *       &lt;li ng-repeat=&quot;contact in contacts&quot;&gt;&#A; *         &lt;select ng-model=&quot;contact.type&quot; id=&quot;select_{{$index}}&quot;&gt;&#A; *            &lt;option&gt;phone&lt;/option&gt;&#A; *            &lt;option&gt;email&lt;/option&gt;&#A; *         &lt;/select&gt;&#A; *         &lt;input type=&quot;text&quot; ng-model=&quot;contact.value&quot; aria-labelledby=&quot;select_{{$index}}&quot; /&gt;&#A; *         &lt;button ng-click=&quot;clearContact(contact)&quot;&gt;clear&lt;/button&gt;&#A; *         &lt;button ng-click=&quot;removeContact(contact)&quot;&gt;X&lt;/button&gt;&#A; *       &lt;/li&gt;&#A; *       &lt;li&gt;[ &lt;button ng-click=&quot;addContact()&quot;&gt;add&lt;/button&gt; ]&lt;/li&gt;&#A; *    &lt;/ul&gt;&#A; *   &lt;/div&gt;&#A; *  &lt;/file&gt;&#A; *  &lt;file name=&quot;app.js&quot;&gt;&#A; *   angular.module(&#39;controllerExample&#39;, [])&#A; *     .controller(&#39;SettingsController2&#39;, [&#39;$scope&#39;, SettingsController2]);&#A; *&#A; *   function SettingsController2($scope) {&#A; *     $scope.name = &quot;John Smith&quot;;&#A; *     $scope.contacts = [&#A; *       {type:&#39;phone&#39;, value:&#39;408 555 1212&#39;},&#A; *       {type:&#39;email&#39;, value:&#39;john.smith@example.org&#39;} ];&#A; *&#A; *     $scope.greet = function() {&#A; *       alert($scope.name);&#A; *     };&#A; *&#A; *     $scope.addContact = function() {&#A; *       $scope.contacts.push({type:&#39;email&#39;, value:&#39;yourname@example.org&#39;});&#A; *     };&#A; *&#A; *     $scope.removeContact = function(contactToRemove) {&#A; *       var index = $scope.contacts.indexOf(contactToRemove);&#A; *       $scope.contacts.splice(index, 1);&#A; *     };&#A; *&#A; *     $scope.clearContact = function(contact) {&#A; *       contact.type = &#39;phone&#39;;&#A; *       contact.value = &#39;&#39;;&#A; *     };&#A; *   }&#A; *  &lt;/file&gt;&#A; *  &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A; *    it(&#39;should check controller&#39;, function() {&#A; *      var container = element(by.id(&#39;ctrl-exmpl&#39;));&#A; *&#A; *      expect(container.element(by.model(&#39;name&#39;))&#A; *          .getAttribute(&#39;value&#39;)).toBe(&#39;John Smith&#39;);&#A; *&#A; *      var firstRepeat =&#A; *          container.element(by.repeater(&#39;contact in contacts&#39;).row(0));&#A; *      var secondRepeat =&#A; *          container.element(by.repeater(&#39;contact in contacts&#39;).row(1));&#A; *&#A; *      expect(firstRepeat.element(by.model(&#39;contact.value&#39;)).getAttribute(&#39;value&#39;))&#A; *          .toBe(&#39;408 555 1212&#39;);&#A; *      expect(secondRepeat.element(by.model(&#39;contact.value&#39;)).getAttribute(&#39;value&#39;))&#A; *          .toBe(&#39;john.smith@example.org&#39;);&#A; *&#A; *      firstRepeat.element(by.buttonText(&#39;clear&#39;)).click();&#A; *&#A; *      expect(firstRepeat.element(by.model(&#39;contact.value&#39;)).getAttribute(&#39;value&#39;))&#A; *          .toBe(&#39;&#39;);&#A; *&#A; *      container.element(by.buttonText(&#39;add&#39;)).click();&#A; *&#A; *      expect(container.element(by.repeater(&#39;contact in contacts&#39;).row(2))&#A; *          .element(by.model(&#39;contact.value&#39;))&#A; *          .getAttribute(&#39;value&#39;))&#A; *          .toBe(&#39;yourname@example.org&#39;);&#A; *    });&#A; *  &lt;/file&gt;&#A; *&lt;/example&gt;

			Alias: ?
			StartLine: 22803
			EndLine: 22808
			NodeType: Object

		Alias: forceAsyncEvents
		StartLine: 23025
		EndLine: 23028
		NodeType: Object
		Comment: For events that might fire synchronously during DOM manipulation&#D;&#A; we need to execute their event handlers asynchronously using $evalAsync,&#D;&#A; so that they are not executed in an inconsistent state.

		Alias: forEach&gt;?(eventName)
		StartLine: 23031
		EndLine: 23057
		NodeType: AnonymousFunction

			Alias: ?($parse,$rootScope)
			StartLine: 23033
			EndLine: 23056
			NodeType: AnonymousFunction

				Alias: ?
				StartLine: 23034
				EndLine: 23055
				NodeType: Object

					Alias: compile($element,attr)
					StartLine: 23036
					EndLine: 23054
					NodeType: Function
					Comment: We expose the powerful $event object on the scope that provides access to the Window,&#D;&#A; etc. that isn&#39;t protected by the fast paths in $parse.  We explicitly request better&#D;&#A; checks at the cost of speed since event handler expressions are not executed as&#D;&#A; frequently as regular change detection.&#D;&#A; interceptorFn

						Alias: ngEventHandler(scope,element)
						StartLine: 23042
						EndLine: 23053
						NodeType: Function
						Comment: expensiveChecks

							Alias: on&gt;?(event)
							StartLine: 23043
							EndLine: 23052
							NodeType: AnonymousFunction

								Alias: callback()
								StartLine: 23044
								EndLine: 23046
								NodeType: Function

									Alias: fn&gt;?
									StartLine: 23045
									EndLine: 23045
									NodeType: Object

		Alias: ?($animate)
		StartLine: 23544
		EndLine: 23590
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngIf&#A; * @restrict A&#A; *&#A; * @description&#A; * The `ngIf` directive removes or recreates a portion of the DOM tree based on an&#A; * {expression}. If the expression assigned to `ngIf` evaluates to a false&#A; * value then the element is removed from the DOM, otherwise a clone of the&#A; * element is reinserted into the DOM.&#A; *&#A; * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the&#A; * element in the DOM rather than changing its visibility via the `display` css property.  A common&#A; * case when this difference is significant is when using css selectors that rely on an element&#39;s&#A; * position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.&#A; *&#A; * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope&#A; * is created when the element is restored.  The scope created within `ngIf` inherits from&#A; * its parent scope using&#A; * [prototypal inheritance](https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance).&#A; * An important implication of this is if `ngModel` is used within `ngIf` to bind to&#A; * a javascript primitive defined in the parent scope. In this case any modifications made to the&#A; * variable within the child scope will override (hide) the value in the parent scope.&#A; *&#A; * Also, `ngIf` recreates elements using their compiled state. An example of this behavior&#A; * is if an element&#39;s class attribute is directly modified after it&#39;s compiled, using something like&#A; * jQuery&#39;s `.addClass()` method, and the element is later removed. When `ngIf` recreates the element&#A; * the added class will be lost because the original compiled state is used to regenerate the element.&#A; *&#A; * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`&#A; * and `leave` effects.&#A; *&#A; * @animations&#A; * enter - happens just after the `ngIf` contents change and a new DOM element is created and injected into the `ngIf` container&#A; * leave - happens just before the `ngIf` contents are removed from the DOM&#A; *&#A; * @element ANY&#A; * @scope&#A; * @priority 600&#A; * @param {expression} ngIf If the {@link guide/expression expression} is falsy then&#A; *     the element is removed from the DOM tree. If it is truthy a copy of the compiled&#A; *     element is added to the DOM tree.&#A; *&#A; * @example&#A;  &lt;example module=&quot;ngAnimate&quot; deps=&quot;angular-animate.js&quot; animations=&quot;true&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;label&gt;Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot; ng-init=&quot;checked=true&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#A;      Show when checked:&#A;      &lt;span ng-if=&quot;checked&quot; class=&quot;animate-if&quot;&gt;&#A;        This is removed when the checkbox is unchecked.&#A;      &lt;/span&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;animations.css&quot;&gt;&#A;      .animate-if {&#A;        background:white;&#A;        border:1px solid black;&#A;        padding:10px;&#A;      }&#A;&#A;      .animate-if.ng-enter, .animate-if.ng-leave {&#A;        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;&#A;        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;&#A;      }&#A;&#A;      .animate-if.ng-enter,&#A;      .animate-if.ng-leave.ng-leave-active {&#A;        opacity:0;&#A;      }&#A;&#A;      .animate-if.ng-leave,&#A;      .animate-if.ng-enter.ng-enter-active {&#A;        opacity:1;&#A;      }&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;

			Alias: ?
			StartLine: 23545
			EndLine: 23589
			NodeType: Object

				Alias: link($scope,$element,…ansclude)
				StartLine: 23552
				EndLine: 23588
				NodeType: Function

					Alias: ngIfWatchAction(value)
					StartLine: 23554
					EndLine: 23587
					NodeType: Function

						Alias: $transclude&gt;?(clone,newScope)
						StartLine: 23558
						EndLine: 23568
						NodeType: AnonymousFunction

							Alias: block
							StartLine: 23564
							EndLine: 23566
							NodeType: Object
							Comment: Note: We only need the first/last node of the cloned nodes.&#D;&#A; However, we need to keep the reference to the jqlite wrapper as it might be changed later&#D;&#A; by a directive with templateUrl when its template arrives.

						Alias: then&gt;?()
						StartLine: 23581
						EndLine: 23583
						NodeType: AnonymousFunction

		Alias: ?($templateRequest…ate,$sce)
		StartLine: 23771
		EndLine: 23854
		NodeType: AnonymousFunction

			Alias: ?
			StartLine: 23772
			EndLine: 23853
			NodeType: Object

				Alias: compile(element,attr)
				StartLine: 23778
				EndLine: 23852
				NodeType: Function

					Alias: ?(scope,$element,$…ansclude)
					StartLine: 23783
					EndLine: 23851
					NodeType: AnonymousFunction

						Alias: cleanupLastIncludeContent()
						StartLine: 23789
						EndLine: 23805
						NodeType: Function

							Alias: then&gt;?()
							StartLine: 23799
							EndLine: 23801
							NodeType: AnonymousFunction

						Alias: ngIncludeWatchAction(src)
						StartLine: 23807
						EndLine: 23850
						NodeType: Function

							Alias: afterAnimation()
							StartLine: 23808
							EndLine: 23812
							NodeType: Function

							Alias: then&gt;?(response)
							StartLine: 23818
							EndLine: 23839
							NodeType: AnonymousFunction
							Comment: set the 2nd param to true to ignore the template request error so that the inner&#D;&#A;contents and scope can be cleaned up.

								Alias: $transclude.clone&gt;?(clone)
								StartLine: 23829
								EndLine: 23832
								NodeType: AnonymousFunction
								Comment: Note: This will also link all children of ng-include that were contained in the original&#D;&#A; html. If that content contains controllers, ... they could pollute/change the scope.&#D;&#A; However, using ng-include on an element with additional content does not make sense...&#D;&#A; Note: We can&#39;t remove them in the cloneAttchFn of $transclude as that&#D;&#A; function is called before linking the content, which would apply child&#D;&#A; directives to non existing elements.

							Alias: then&gt;?()
							StartLine: 23839
							EndLine: 23844
							NodeType: AnonymousFunction

		Alias: ?($compile)
		StartLine: 23862
		EndLine: 23884
		NodeType: AnonymousFunction

			Alias: ?
			StartLine: 23863
			EndLine: 23883
			NodeType: Object

				Alias: link(scope,$element,$attr,ctrl)
				StartLine: 23867
				EndLine: 23882
				NodeType: Function

					Alias: namespaceAdaptedClone(clone)
					StartLine: 23874
					EndLine: 23876
					NodeType: Function

					Alias: $compile&gt;?
					StartLine: 23876
					EndLine: 23876
					NodeType: Object

		Alias: ngDirective.ngInitDirective&gt;?
		StartLine: 23942
		EndLine: 23951
		NodeType: Object
		Comment: *&#A; * @ngdoc directive&#A; * @name ngInit&#A; * @restrict AC&#A; *&#A; * @description&#A; * The `ngInit` directive allows you to evaluate an expression in the&#A; * current scope.&#A; *&#A; * &lt;div class=&quot;alert alert-danger&quot;&gt;&#A; * The only appropriate use of `ngInit` is for aliasing special properties of&#A; * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. Besides this case, you&#A; * should use {@link guide/controller controllers} rather than `ngInit`&#A; * to initialize values on a scope.&#A; * &lt;/div&gt;&#A; * &lt;div class=&quot;alert alert-warning&quot;&gt;&#A; * **Note**: If you have assignment in `ngInit` along with {@link ng.$filter `$filter`}, make&#A; * sure you have parenthesis for correct precedence:&#A; * &lt;pre class=&quot;prettyprint&quot;&gt;&#A; * `&lt;div ng-init=&quot;test1 = (data | orderBy:&#39;name&#39;)&quot;&gt;&lt;/div&gt;`&#A; * &lt;/pre&gt;&#A; * &lt;/div&gt;&#A; *&#A; * @priority 450&#A; *&#A; * @element ANY&#A; * @param {expression} ngInit {@link guide/expression Expression} to eval.&#A; *&#A; * @example&#A;   &lt;example module=&quot;initExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;   &lt;script&gt;&#A;     angular.module(&#39;initExample&#39;, [])&#A;       .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;         $scope.list = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]];&#A;       }]);&#A;   &lt;/script&gt;&#A;   &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;     &lt;div ng-repeat=&quot;innerList in list&quot; ng-init=&quot;outerIndex = $index&quot;&gt;&#A;       &lt;div ng-repeat=&quot;value in innerList&quot; ng-init=&quot;innerIndex = $index&quot;&gt;&#A;          &lt;span class=&quot;example-init&quot;&gt;list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};&lt;/span&gt;&#A;       &lt;/div&gt;&#A;     &lt;/div&gt;&#A;   &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should alias index positions&#39;, function() {&#A;         var elements = element.all(by.css(&#39;.example-init&#39;));&#A;         expect(elements.get(0).getText()).toBe(&#39;list[ 0 ][ 0 ] = a;&#39;);&#A;         expect(elements.get(1).getText()).toBe(&#39;list[ 0 ][ 1 ] = b;&#39;);&#A;         expect(elements.get(2).getText()).toBe(&#39;list[ 1 ][ 0 ] = c;&#39;);&#A;         expect(elements.get(3).getText()).toBe(&#39;list[ 1 ][ 1 ] = d;&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: compile()
			StartLine: 23944
			EndLine: 23950
			NodeType: Function

				Alias: ?
				StartLine: 23945
				EndLine: 23949
				NodeType: Object

					Alias: pre(scope,element,attrs)
					StartLine: 23946
					EndLine: 23948
					NodeType: Function

		Alias: ngListDirective()
		StartLine: 24037
		EndLine: 24079
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @name ngList&#A; *&#A; * @description&#A; * Text input that converts between a delimited string and an array of strings. The default&#A; * delimiter is a comma followed by a space - equivalent to `ng-list=&quot;, &quot;`. You can specify a custom&#A; * delimiter as the value of the `ngList` attribute - for example, `ng-list=&quot; | &quot;`.&#A; *&#A; * The behaviour of the directive is affected by the use of the `ngTrim` attribute.&#A; * * If `ngTrim` is set to `&quot;false&quot;` then whitespace around both the separator and each&#A; *   list item is respected. This implies that the user of the directive is responsible for&#A; *   dealing with whitespace but also allows you to use whitespace as a delimiter, such as a&#A; *   tab or newline character.&#A; * * Otherwise whitespace around the delimiter is ignored when splitting (although it is respected&#A; *   when joining the list items back together) and whitespace around each list item is stripped&#A; *   before it is added to the model.&#A; *&#A; * ### Example with Validation&#A; *&#A; * &lt;example name=&quot;ngList-directive&quot; module=&quot;listExample&quot;&gt;&#A; *   &lt;file name=&quot;app.js&quot;&gt;&#A; *      angular.module(&#39;listExample&#39;, [])&#A; *        .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A; *          $scope.names = [&#39;morpheus&#39;, &#39;neo&#39;, &#39;trinity&#39;];&#A; *        }]);&#A; *   &lt;/file&gt;&#A; *   &lt;file name=&quot;index.html&quot;&gt;&#A; *    &lt;form name=&quot;myForm&quot; ng-controller=&quot;ExampleController&quot;&gt;&#A; *      &lt;label&gt;List: &lt;input name=&quot;namesInput&quot; ng-model=&quot;names&quot; ng-list required&gt;&lt;/label&gt;&#A; *      &lt;span role=&quot;alert&quot;&gt;&#A; *        &lt;span class=&quot;error&quot; ng-show=&quot;myForm.namesInput.$error.required&quot;&gt;&#A; *        Required!&lt;/span&gt;&#A; *      &lt;/span&gt;&#A; *      &lt;br&gt;&#A; *      &lt;tt&gt;names = {{names}}&lt;/tt&gt;&lt;br/&gt;&#A; *      &lt;tt&gt;myForm.namesInput.$valid = {{myForm.namesInput.$valid}}&lt;/tt&gt;&lt;br/&gt;&#A; *      &lt;tt&gt;myForm.namesInput.$error = {{myForm.namesInput.$error}}&lt;/tt&gt;&lt;br/&gt;&#A; *      &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;&#A; *      &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;&#A; *     &lt;/form&gt;&#A; *   &lt;/file&gt;&#A; *   &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A; *     var listInput = element(by.model(&#39;names&#39;));&#A; *     var names = element(by.exactBinding(&#39;names&#39;));&#A; *     var valid = element(by.binding(&#39;myForm.namesInput.$valid&#39;));&#A; *     var error = element(by.css(&#39;span.error&#39;));&#A; *&#A; *     it(&#39;should initialize to model&#39;, function() {&#A; *       expect(names.getText()).toContain(&#39;[&quot;morpheus&quot;,&quot;neo&quot;,&quot;trinity&quot;]&#39;);&#A; *       expect(valid.getText()).toContain(&#39;true&#39;);&#A; *       expect(error.getCssValue(&#39;display&#39;)).toBe(&#39;none&#39;);&#A; *     });&#A; *&#A; *     it(&#39;should be invalid if empty&#39;, function() {&#A; *       listInput.clear();&#A; *       listInput.sendKeys(&#39;&#39;);&#A; *&#A; *       expect(names.getText()).toContain(&#39;&#39;);&#A; *       expect(valid.getText()).toContain(&#39;false&#39;);&#A; *       expect(error.getCssValue(&#39;display&#39;)).not.toBe(&#39;none&#39;);&#A; *     });&#A; *   &lt;/file&gt;&#A; * &lt;/example&gt;&#A; *&#A; * ### Example - splitting on whitespace&#A; * &lt;example name=&quot;ngList-directive-newlines&quot;&gt;&#A; *   &lt;file name=&quot;index.html&quot;&gt;&#A; *    &lt;textarea ng-model=&quot;list&quot; ng-list=&quot;&amp;#10;&quot; ng-trim=&quot;false&quot;&gt;&lt;/textarea&gt;&#A; *    &lt;pre&gt;{{ list | json }}&lt;/pre&gt;&#A; *   &lt;/file&gt;&#A; *   &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A; *     it(&quot;should split the text by newlines&quot;, function() {&#A; *       var listInput = element(by.model(&#39;list&#39;));&#A; *       var output = element(by.binding(&#39;list | json&#39;));&#A; *       listInput.sendKeys(&#39;abc\ndef\nghi&#39;);&#A; *       expect(output.getText()).toContain(&#39;[\n  &quot;abc&quot;,\n  &quot;def&quot;,\n  &quot;ghi&quot;\n]&#39;);&#A; *     });&#A; *   &lt;/file&gt;&#A; * &lt;/example&gt;&#A; *&#A; * @element input&#A; * @param {string=} ngList optional delimiter that should be used to split the value.

			Alias: ?
			StartLine: 24038
			EndLine: 24078
			NodeType: Object

				Alias: link(scope,element,attr,ctrl)
				StartLine: 24042
				EndLine: 24077
				NodeType: Function
				Comment: We want to control whitespace trimming so we use this convoluted approach&#D;&#A; to access the ngList attribute, which doesn&#39;t pre-trim the attribute

					Alias: parse(viewValue)
					StartLine: 24049
					EndLine: 24062
					NodeType: Function
					Comment: If the viewValue is invalid (say required but empty) it will be `undefined`

						Alias: forEach&gt;?(value)
						StartLine: 24056
						EndLine: 24058
						NodeType: AnonymousFunction

					Alias: push&gt;?(value)
					StartLine: 24065
					EndLine: 24071
					NodeType: AnonymousFunction

					Alias: $isEmpty(value)
					StartLine: 24074
					EndLine: 24076
					NodeType: Function
					Comment: Override the standard $isEmpty because an empty array means the input is empty.

		Alias: ?($scope,$exceptio…erpolate)
		StartLine: 24299
		EndLine: 24917
		NodeType: AnonymousFunction

			Alias: $$setOptions(options)
			StartLine: 24328
			EndLine: 24352
			NodeType: Function

				Alias: ngModelGet($scope)
				StartLine: 24334
				EndLine: 24340
				NodeType: Function

				Alias: ngModelSet($scope,newValue)
				StartLine: 24341
				EndLine: 24347
				NodeType: Function

					Alias: invokeModelSetter&gt;?
					StartLine: 24343
					EndLine: 24343
					NodeType: Object

			Alias: $isEmpty(value)
			StartLine: 24394
			EndLine: 24396
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$isEmpty&#A;   *&#A;   * @description&#A;   * This is called when we need to determine if the value of an input is empty.&#A;   *&#A;   * For instance, the required directive does this to work out if the input has data or not.&#A;   *&#A;   * The default `$isEmpty` function checks whether the value is `undefined`, `&#39;&#39;`, `null` or `NaN`.&#A;   *&#A;   * You can override this for input directives whose concept of being empty is different from the&#A;   * default. The `checkboxInputType` directive does this because in its case a value of `false`&#A;   * implies empty.&#A;   *&#A;   * @param {*} value The value of the input to check for emptiness.&#A;   * @returns {boolean} True if `value` is &quot;empty&quot;.

			Alias: addSetValidityMethod&gt;?
			StartLine: 24423
			EndLine: 24434
			NodeType: Object
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$setValidity&#A;   *&#A;   * @description&#A;   * Change the validity state, and notify the form.&#A;   *&#A;   * This method can be called within $parsers/$formatters or a custom validation implementation.&#A;   * However, in most cases it should be sufficient to use the `ngModel.$validators` and&#A;   * `ngModel.$asyncValidators` collections which will call `$setValidity` automatically.&#A;   *&#A;   * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be assigned&#A;   *        to either `$error[validationErrorKey]` or `$pending[validationErrorKey]`&#A;   *        (for unfulfilled `$asyncValidators`), so that it is available for data-binding.&#A;   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case&#A;   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`&#A;   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .&#A;   * @param {boolean} isValid Whether the current state is valid (true), invalid (false), pending (undefined),&#A;   *                          or skipped (null). Pending is used for unfulfilled `$asyncValidators`.&#A;   *                          Skipped is used by Angular when validators do not run because of parse errors and&#A;   *                          when `$asyncValidators` do not run because any of the `$validators` failed.

				Alias: set(object,property)
				StartLine: 24426
				EndLine: 24428
				NodeType: Function

				Alias: unset(object,property)
				StartLine: 24429
				EndLine: 24431
				NodeType: Function

			Alias: $setPristine()
			StartLine: 24447
			EndLine: 24452
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$setPristine&#A;   *&#A;   * @description&#A;   * Sets the control to its pristine state.&#A;   *&#A;   * This method can be called to remove the `ng-dirty` class and set the control to its pristine&#A;   * state (`ng-pristine` class). A model is considered to be pristine when the control&#A;   * has not been changed from when first compiled.

			Alias: $setDirty()
			StartLine: 24465
			EndLine: 24471
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$setDirty&#A;   *&#A;   * @description&#A;   * Sets the control to its dirty state.&#A;   *&#A;   * This method can be called to remove the `ng-pristine` class and set the control to its dirty&#A;   * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed&#A;   * from when first compiled.

			Alias: $setUntouched()
			StartLine: 24485
			EndLine: 24489
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$setUntouched&#A;   *&#A;   * @description&#A;   * Sets the control to its untouched state.&#A;   *&#A;   * This method can be called to remove the `ng-touched` class and set the control to its&#A;   * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched&#A;   * by default, however this function can be used to restore that state if the model has&#A;   * already been touched by the user.

			Alias: $setTouched()
			StartLine: 24502
			EndLine: 24506
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$setTouched&#A;   *&#A;   * @description&#A;   * Sets the control to its touched state.&#A;   *&#A;   * This method can be called to remove the `ng-untouched` class and set the control to its&#A;   * touched state (`ng-touched` class). A model is considered to be touched when the user has&#A;   * first focused the control element and then shifted focus away from the control (blur event).

			Alias: $rollbackViewValue()
			StartLine: 24569
			EndLine: 24573
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$rollbackViewValue&#A;   *&#A;   * @description&#A;   * Cancel an update and reset the input element&#39;s value to prevent an update to the `$modelValue`,&#A;   * which may be caused by a pending debounced event or because the input is waiting for a some&#A;   * future event.&#A;   *&#A;   * If you have an input that uses `ng-model-options` to set up debounced events or events such&#A;   * as blur you can have a situation where there is a period when the `$viewValue`&#A;   * is out of synch with the ngModel&#39;s `$modelValue`.&#A;   *&#A;   * In this case, you can run into difficulties if you try to update the ngModel&#39;s `$modelValue`&#A;   * programmatically before these debounced/future events have resolved/occurred, because Angular&#39;s&#A;   * dirty checking mechanism is not able to tell whether the model has actually changed or not.&#A;   *&#A;   * The `$rollbackViewValue()` method should be called before programmatically changing the model of an&#A;   * input which may have such events pending. This is important in order to make sure that the&#A;   * input field will be updated with the new model value and any pending operations are cancelled.&#A;   *&#A;   * &lt;example name=&quot;ng-model-cancel-update&quot; module=&quot;cancel-update-example&quot;&gt;&#A;   *   &lt;file name=&quot;app.js&quot;&gt;&#A;   *     angular.module(&#39;cancel-update-example&#39;, [])&#A;   *&#A;   *     .controller(&#39;CancelUpdateController&#39;, [&#39;$scope&#39;, function($scope) {&#A;   *       $scope.resetWithCancel = function(e) {&#A;   *         if (e.keyCode == 27) {&#A;   *           $scope.myForm.myInput1.$rollbackViewValue();&#A;   *           $scope.myValue = &#39;&#39;;&#A;   *         }&#A;   *       };&#A;   *       $scope.resetWithoutCancel = function(e) {&#A;   *         if (e.keyCode == 27) {&#A;   *           $scope.myValue = &#39;&#39;;&#A;   *         }&#A;   *       };&#A;   *     }]);&#A;   *   &lt;/file&gt;&#A;   *   &lt;file name=&quot;index.html&quot;&gt;&#A;   *     &lt;div ng-controller=&quot;CancelUpdateController&quot;&gt;&#A;   *       &lt;p&gt;Try typing something in each input.  See that the model only updates when you&#A;   *          blur off the input.&#A;   *        &lt;/p&gt;&#A;   *        &lt;p&gt;Now see what happens if you start typing then press the Escape key&lt;/p&gt;&#A;   *&#A;   *       &lt;form name=&quot;myForm&quot; ng-model-options=&quot;{ updateOn: &#39;blur&#39; }&quot;&gt;&#A;   *         &lt;p id=&quot;inputDescription1&quot;&gt;With $rollbackViewValue()&lt;/p&gt;&#A;   *         &lt;input name=&quot;myInput1&quot; aria-describedby=&quot;inputDescription1&quot; ng-model=&quot;myValue&quot;&#A;   *                ng-keydown=&quot;resetWithCancel($event)&quot;&gt;&lt;br/&gt;&#A;   *         myValue: &quot;{{ myValue }}&quot;&#A;   *&#A;   *         &lt;p id=&quot;inputDescription2&quot;&gt;Without $rollbackViewValue()&lt;/p&gt;&#A;   *         &lt;input name=&quot;myInput2&quot; aria-describedby=&quot;inputDescription2&quot; ng-model=&quot;myValue&quot;&#A;   *                ng-keydown=&quot;resetWithoutCancel($event)&quot;&gt;&lt;br/&gt;&#A;   *         myValue: &quot;{{ myValue }}&quot;&#A;   *       &lt;/form&gt;&#A;   *     &lt;/div&gt;&#A;   *   &lt;/file&gt;&#A;   * &lt;/example&gt;

			Alias: $validate()
			StartLine: 24587
			EndLine: 24621
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$validate&#A;   *&#A;   * @description&#A;   * Runs each of the registered validators (first synchronous validators and then&#A;   * asynchronous validators).&#A;   * If the validity changes to invalid, the model will be set to `undefined`,&#A;   * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.&#A;   * If the validity changes to valid, it will set the model to the last available valid&#A;   * `$modelValue`, i.e. either the last parsed value or the last value set from the scope.&#A;   &#D;&#A; ignore $validate before model is initialized

				Alias: $$runValidators&gt;?(allValid)
				StartLine: 24605
				EndLine: 24619
				NodeType: AnonymousFunction
				Comment: If there was no change in validity, don&#39;t update the model&#D;&#A; This prevents changing an invalid modelValue to undefined

			Alias: $$runValidators(modelValue,viewV…Callback)
			StartLine: 24623
			EndLine: 24712
			NodeType: Function

				Alias: processParseErrors()
				StartLine: 24638
				EndLine: 24656
				NodeType: Function

					Alias: forEach&gt;?(v,name)
					StartLine: 24644
					EndLine: 24646
					NodeType: AnonymousFunction

					Alias: forEach&gt;?(v,name)
					StartLine: 24647
					EndLine: 24649
					NodeType: AnonymousFunction

				Alias: processSyncValidators()
				StartLine: 24658
				EndLine: 24672
				NodeType: Function

					Alias: forEach&gt;?(validator,name)
					StartLine: 24660
					EndLine: 24664
					NodeType: AnonymousFunction

					Alias: forEach&gt;?(v,name)
					StartLine: 24666
					EndLine: 24668
					NodeType: AnonymousFunction

				Alias: processAsyncValidators()
				StartLine: 24674
				EndLine: 24698
				NodeType: Function

					Alias: forEach&gt;?(validator,name)
					StartLine: 24677
					EndLine: 24690
					NodeType: AnonymousFunction

						Alias: then.push&gt;?&gt;?()
						StartLine: 24684
						EndLine: 24686
						NodeType: AnonymousFunction

						Alias: then.push&gt;?&gt;?(error)
						StartLine: 24686
						EndLine: 24689
						NodeType: AnonymousFunction

					Alias: then&gt;?()
					StartLine: 24694
					EndLine: 24696
					NodeType: AnonymousFunction

				Alias: setValidity(name,isValid)
				StartLine: 24700
				EndLine: 24704
				NodeType: Function

				Alias: validationDone(allValid)
				StartLine: 24706
				EndLine: 24711
				NodeType: Function

			Alias: $commitViewValue()
			StartLine: 24725
			EndLine: 24743
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$commitViewValue&#A;   *&#A;   * @description&#A;   * Commit a pending update to the `$modelValue`.&#A;   *&#A;   * Updates may be pending by a debounced event or because the input is waiting for a some future&#A;   * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`&#A;   * usually handles calling this in response to input events.

			Alias: $$parseAndValidate()
			StartLine: 24745
			EndLine: 24790
			NodeType: Function

				Alias: $$runValidators&gt;?(allValid)
				StartLine: 24774
				EndLine: 24783
				NodeType: AnonymousFunction
				Comment: Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.&#D;&#A; This can happen if e.g. $setViewValue is called from inside a parser

				Alias: writeToModelIfNeeded()
				StartLine: 24785
				EndLine: 24789
				NodeType: Function

			Alias: $$writeModelToScope()
			StartLine: 24792
			EndLine: 24801
			NodeType: Function

				Alias: forEach&gt;?(listener)
				StartLine: 24794
				EndLine: 24800
				NodeType: AnonymousFunction

			Alias: $setViewValue(value,trigger)
			StartLine: 24843
			EndLine: 24848
			NodeType: Function
			Comment: *&#A;   * @ngdoc method&#A;   * @name ngModel.NgModelController#$setViewValue&#A;   *&#A;   * @description&#A;   * Update the view value.&#A;   *&#A;   * This method should be called when an input directive want to change the view value; typically,&#A;   * this is done from within a DOM event handler.&#A;   *&#A;   * For example {@link ng.directive:input input} calls it when the value of the input changes and&#A;   * {@link ng.directive:select select} calls it when an option is selected.&#A;   *&#A;   * If the new `value` is an object (rather than a string or a number), we should make a copy of the&#A;   * object before passing it to `$setViewValue`.  This is because `ngModel` does not perform a deep&#A;   * watch of objects, it only looks for a change of identity. If you only change the property of&#A;   * the object then ngModel will not realise that the object has changed and will not invoke the&#A;   * `$parsers` and `$validators` pipelines.&#A;   *&#A;   * For this reason, you should not change properties of the copy once it has been passed to&#A;   * `$setViewValue`. Otherwise you may cause the model value on the scope to change incorrectly.&#A;   *&#A;   * When this method is called, the new `value` will be staged for committing through the `$parsers`&#A;   * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged&#A;   * value sent directly for processing, finally to be applied to `$modelValue` and then the&#A;   * **expression** specified in the `ng-model` attribute.&#A;   *&#A;   * Lastly, all the registered change listeners, in the `$viewChangeListeners` list, are called.&#A;   *&#A;   * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`&#A;   * and the `default` trigger is not listed, all those actions will remain pending until one of the&#A;   * `updateOn` events is triggered on the DOM element.&#A;   * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}&#A;   * directive is used with a custom debounce for this particular event.&#A;   *&#A;   * Note that calling this function does not trigger a `$digest`.&#A;   *&#A;   * @param {string} value Value from the view.&#A;   * @param {string} trigger Event that triggered the update.

			Alias: $$debounceViewValueCommit(trigger)
			StartLine: 24850
			EndLine: 24878
			NodeType: Function

				Alias: $timeout.pendingDebounce&gt;?()
				StartLine: 24868
				EndLine: 24870
				NodeType: AnonymousFunction

				Alias: $apply&gt;?()
				StartLine: 24874
				EndLine: 24876
				NodeType: AnonymousFunction

			Alias: ngModelWatch()
			StartLine: 24888
			EndLine: 24916
			NodeType: Function
			Comment: model -&gt; value&#D;&#A; Note: we cannot use a normal scope.$watch as we want to detect the following:&#D;&#A; 1. scope value is &#39;a&#39;&#D;&#A; 2. user enters &#39;b&#39;&#D;&#A; 3. ng-change kicks in and reverts scope value to &#39;a&#39;&#D;&#A;    -&gt; scope value did not change since the last digest as&#D;&#A;       ng-change executes in apply phase&#D;&#A; 4. view should be changed back to &#39;a&#39;

		Alias: ?($rootScope)
		StartLine: 25088
		EndLine: 25142
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngModel&#A; *&#A; * @element input&#A; * @priority 1&#A; *&#A; * @description&#A; * The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a&#A; * property on the scope using {@link ngModel.NgModelController NgModelController},&#A; * which is created and exposed by this directive.&#A; *&#A; * `ngModel` is responsible for:&#A; *&#A; * - Binding the view into the model, which other directives such as `input`, `textarea` or `select`&#A; *   require.&#A; * - Providing validation behavior (i.e. required, number, email, url).&#A; * - Keeping the state of the control (valid/invalid, dirty/pristine, touched/untouched, validation errors).&#A; * - Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`, `ng-touched`, `ng-untouched`) including animations.&#A; * - Registering the control with its parent {@link ng.directive:form form}.&#A; *&#A; * Note: `ngModel` will try to bind to the property given by evaluating the expression on the&#A; * current scope. If the property doesn&#39;t already exist on this scope, it will be created&#A; * implicitly and added to the scope.&#A; *&#A; * For best practices on using `ngModel`, see:&#A; *&#A; *  - [Understanding Scopes](https://github.com/angular/angular.js/wiki/Understanding-Scopes)&#A; *&#A; * For basic examples, how to use `ngModel`, see:&#A; *&#A; *  - {@link ng.directive:input input}&#A; *    - {@link input[text] text}&#A; *    - {@link input[checkbox] checkbox}&#A; *    - {@link input[radio] radio}&#A; *    - {@link input[number] number}&#A; *    - {@link input[email] email}&#A; *    - {@link input[url] url}&#A; *    - {@link input[date] date}&#A; *    - {@link input[datetime-local] datetime-local}&#A; *    - {@link input[time] time}&#A; *    - {@link input[month] month}&#A; *    - {@link input[week] week}&#A; *  - {@link ng.directive:select select}&#A; *  - {@link ng.directive:textarea textarea}&#A; *&#A; * # CSS classes&#A; * The following CSS classes are added and removed on the associated input/select/textarea element&#A; * depending on the validity of the model.&#A; *&#A; *  - `ng-valid`: the model is valid&#A; *  - `ng-invalid`: the model is invalid&#A; *  - `ng-valid-[key]`: for each valid key added by `$setValidity`&#A; *  - `ng-invalid-[key]`: for each invalid key added by `$setValidity`&#A; *  - `ng-pristine`: the control hasn&#39;t been interacted with yet&#A; *  - `ng-dirty`: the control has been interacted with&#A; *  - `ng-touched`: the control has been blurred&#A; *  - `ng-untouched`: the control hasn&#39;t been blurred&#A; *  - `ng-pending`: any `$asyncValidators` are unfulfilled&#A; *&#A; * Keep in mind that ngAnimate can detect each of these classes when added and removed.&#A; *&#A; * ## Animation Hooks&#A; *&#A; * Animations within models are triggered when any of the associated CSS classes are added and removed&#A; * on the input element which is attached to the model. These classes are: `.ng-pristine`, `.ng-dirty`,&#A; * `.ng-invalid` and `.ng-valid` as well as any other validations that are performed on the model itself.&#A; * The animations that are triggered within ngModel are similar to how they work in ngClass and&#A; * animations can be hooked into using CSS transitions, keyframes as well as JS animations.&#A; *&#A; * The following example shows a simple way to utilize CSS transitions to style an input element&#A; * that has been rendered as invalid after it has been validated:&#A; *&#A; * &lt;pre&gt;&#A; * //be sure to include ngAnimate as a module to hook into more&#A; * //advanced animations&#A; * .my-input {&#A; *   transition:0.5s linear all;&#A; *   background: white;&#A; * }&#A; * .my-input.ng-invalid {&#A; *   background: red;&#A; *   color:white;&#A; * }&#A; * &lt;/pre&gt;&#A; *&#A; * @example&#A; * &lt;example deps=&quot;angular-animate.js&quot; animations=&quot;true&quot; fixBase=&quot;true&quot; module=&quot;inputExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;        angular.module(&#39;inputExample&#39;, [])&#A;          .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;            $scope.val = &#39;1&#39;;&#A;          }]);&#A;       &lt;/script&gt;&#A;       &lt;style&gt;&#A;         .my-input {&#A;           -webkit-transition:all linear 0.5s;&#A;           transition:all linear 0.5s;&#A;           background: transparent;&#A;         }&#A;         .my-input.ng-invalid {&#A;           color:white;&#A;           background: red;&#A;         }&#A;       &lt;/style&gt;&#A;       &lt;p id=&quot;inputDescription&quot;&gt;&#A;        Update input to see transitions when valid/invalid.&#A;        Integer is a valid value.&#A;       &lt;/p&gt;&#A;       &lt;form name=&quot;testForm&quot; ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;input ng-model=&quot;val&quot; ng-pattern=&quot;/^\d+$/&quot; name=&quot;anim&quot; class=&quot;my-input&quot;&#A;                aria-describedby=&quot;inputDescription&quot; /&gt;&#A;       &lt;/form&gt;&#A;     &lt;/file&gt;&#A; * &lt;/example&gt;&#A; *&#A; * ## Binding to a getter/setter&#A; *&#A; * Sometimes it&#39;s helpful to bind `ngModel` to a getter/setter function.  A getter/setter is a&#A; * function that returns a representation of the model when called with zero arguments, and sets&#A; * the internal state of a model when called with an argument. It&#39;s sometimes useful to use this&#A; * for models that have an internal representation that&#39;s different from what the model exposes&#A; * to the view.&#A; *&#A; * &lt;div class=&quot;alert alert-success&quot;&gt;&#A; * **Best Practice:** It&#39;s best to keep getters fast because Angular is likely to call them more&#A; * frequently than other parts of your code.&#A; * &lt;/div&gt;&#A; *&#A; * You use this behavior by adding `ng-model-options=&quot;{ getterSetter: true }&quot;` to an element that&#A; * has `ng-model` attached to it. You can also add `ng-model-options=&quot;{ getterSetter: true }&quot;` to&#A; * a `&lt;form&gt;`, which will enable this behavior for all `&lt;input&gt;`s within it. See&#A; * {@link ng.directive:ngModelOptions `ngModelOptions`} for more.&#A; *&#A; * The following example shows how to use `ngModel` with a getter/setter:&#A; *&#A; * @example&#A; * &lt;example name=&quot;ngModel-getter-setter&quot; module=&quot;getterSetterExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;form name=&quot;userForm&quot;&gt;&#A;           &lt;label&gt;Name:&#A;             &lt;input type=&quot;text&quot; name=&quot;userName&quot;&#A;                    ng-model=&quot;user.name&quot;&#A;                    ng-model-options=&quot;{ getterSetter: true }&quot; /&gt;&#A;           &lt;/label&gt;&#A;         &lt;/form&gt;&#A;         &lt;pre&gt;user.name = &lt;span ng-bind=&quot;user.name()&quot;&gt;&lt;/span&gt;&lt;/pre&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;app.js&quot;&gt;&#A;       angular.module(&#39;getterSetterExample&#39;, [])&#A;         .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;           var _name = &#39;Brian&#39;;&#A;           $scope.user = {&#A;             name: function(newName) {&#A;              // Note that newName can be undefined for two reasons:&#A;              // 1. Because it is called as a getter and thus called with no arguments&#A;              // 2. Because the property should actually be set to undefined. This happens e.g. if the&#A;              //    input is invalid&#A;              return arguments.length ? (_name = newName) : _name;&#A;             }&#A;           };&#A;         }]);&#A;     &lt;/file&gt;&#A; * &lt;/example&gt;

			Alias: ?
			StartLine: 25089
			EndLine: 25141
			NodeType: Object

				Alias: ngModelCompile(element)
				StartLine: 25097
				EndLine: 25140
				NodeType: Function
				Comment: Setup initial state of the control

					Alias: ?
					StartLine: 25101
					EndLine: 25139
					NodeType: Object

						Alias: ngModelPreLink(scope,element,attr,ctrls)
						StartLine: 25102
						EndLine: 25120
						NodeType: Function

							Alias: $observe&gt;?(newValue)
							StartLine: 25111
							EndLine: 25115
							NodeType: AnonymousFunction

							Alias: $on&gt;?()
							StartLine: 25117
							EndLine: 25119
							NodeType: AnonymousFunction

						Alias: ngModelPostLink(scope,element,attr,ctrls)
						StartLine: 25121
						EndLine: 25138
						NodeType: Function

							Alias: on&gt;?(ev)
							StartLine: 25124
							EndLine: 25126
							NodeType: AnonymousFunction

							Alias: on&gt;?(ev)
							StartLine: 25129
							EndLine: 25137
							NodeType: AnonymousFunction

		Alias: ngModelOptionsDirective()
		StartLine: 25306
		EndLine: 25325
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @name ngModelOptions&#A; *&#A; * @description&#A; * Allows tuning how model updates are done. Using `ngModelOptions` you can specify a custom list of&#A; * events that will trigger a model update and/or a debouncing delay so that the actual update only&#A; * takes place when a timer expires; this timer will be reset after another change takes place.&#A; *&#A; * Given the nature of `ngModelOptions`, the value displayed inside input fields in the view might&#A; * be different from the value in the actual model. This means that if you update the model you&#A; * should also invoke {@link ngModel.NgModelController `$rollbackViewValue`} on the relevant input field in&#A; * order to make sure it is synchronized with the model and that any debounced action is canceled.&#A; *&#A; * The easiest way to reference the control&#39;s {@link ngModel.NgModelController `$rollbackViewValue`}&#A; * method is by making sure the input is placed inside a form that has a `name` attribute. This is&#A; * important because `form` controllers are published to the related scope under the name in their&#A; * `name` attribute.&#A; *&#A; * Any pending changes will take place immediately when an enclosing form is submitted via the&#A; * `submit` event. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`&#A; * to have access to the updated model.&#A; *&#A; * `ngModelOptions` has an effect on the element it&#39;s declared on and its descendants.&#A; *&#A; * @param {Object} ngModelOptions options to apply to the current model. Valid keys are:&#A; *   - `updateOn`: string specifying which event should the input be bound to. You can set several&#A; *     events using an space delimited list. There is a special event called `default` that&#A; *     matches the default events belonging of the control.&#A; *   - `debounce`: integer value which contains the debounce model update value in milliseconds. A&#A; *     value of 0 triggers an immediate update. If an object is supplied instead, you can specify a&#A; *     custom value for each event. For example:&#A; *     `ng-model-options=&quot;{ updateOn: &#39;default blur&#39;, debounce: {&#39;default&#39;: 500, &#39;blur&#39;: 0} }&quot;`&#A; *   - `allowInvalid`: boolean value which indicates that the model can be set with values that did&#A; *     not validate correctly instead of the default behavior of setting the model to undefined.&#A; *   - `getterSetter`: boolean value which determines whether or not to treat functions bound to&#A;       `ngModel` as getters/setters.&#A; *   - `timezone`: Defines the timezone to be used to read/write the `Date` instance in the model for&#A; *     `&lt;input type=&quot;date&quot;&gt;`, `&lt;input type=&quot;time&quot;&gt;`, ... . It understands UTC/GMT and the&#A; *     continental US time zone abbreviations, but for general use, use a time zone offset, for&#A; *     example, `&#39;+0430&#39;` (4 hours, 30 minutes east of the Greenwich meridian)&#A; *     If not specified, the timezone of the browser will be used.&#A; *&#A; * @example&#A;&#A;  The following example shows how to override immediate updates. Changes on the inputs within the&#A;  form will update the model only when the control loses focus (blur event). If `escape` key is&#A;  pressed while the input field is focused, the value is reset to the value in the current model.&#A;&#A;  &lt;example name=&quot;ngModelOptions-directive-blur&quot; module=&quot;optionsExample&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;        &lt;form name=&quot;userForm&quot;&gt;&#A;          &lt;label&gt;Name:&#A;            &lt;input type=&quot;text&quot; name=&quot;userName&quot;&#A;                   ng-model=&quot;user.name&quot;&#A;                   ng-model-options=&quot;{ updateOn: &#39;blur&#39; }&quot;&#A;                   ng-keyup=&quot;cancel($event)&quot; /&gt;&#A;          &lt;/label&gt;&lt;br /&gt;&#A;          &lt;label&gt;Other data:&#A;            &lt;input type=&quot;text&quot; ng-model=&quot;user.data&quot; /&gt;&#A;          &lt;/label&gt;&lt;br /&gt;&#A;        &lt;/form&gt;&#A;        &lt;pre&gt;user.name = &lt;span ng-bind=&quot;user.name&quot;&gt;&lt;/span&gt;&lt;/pre&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;app.js&quot;&gt;&#A;      angular.module(&#39;optionsExample&#39;, [])&#A;        .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;          $scope.user = { name: &#39;say&#39;, data: &#39;&#39; };&#A;&#A;          $scope.cancel = function(e) {&#A;            if (e.keyCode == 27) {&#A;              $scope.userForm.userName.$rollbackViewValue();&#A;            }&#A;          };&#A;        }]);&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      var model = element(by.binding(&#39;user.name&#39;));&#A;      var input = element(by.model(&#39;user.name&#39;));&#A;      var other = element(by.model(&#39;user.data&#39;));&#A;&#A;      it(&#39;should allow custom events&#39;, function() {&#A;        input.sendKeys(&#39; hello&#39;);&#A;        input.click();&#A;        expect(model.getText()).toEqual(&#39;say&#39;);&#A;        other.click();&#A;        expect(model.getText()).toEqual(&#39;say hello&#39;);&#A;      });&#A;&#A;      it(&#39;should $rollbackViewValue when model changes&#39;, function() {&#A;        input.sendKeys(&#39; hello&#39;);&#A;        expect(input.getAttribute(&#39;value&#39;)).toEqual(&#39;say hello&#39;);&#A;        input.sendKeys(protractor.Key.ESCAPE);&#A;        expect(input.getAttribute(&#39;value&#39;)).toEqual(&#39;say&#39;);&#A;        other.click();&#A;        expect(model.getText()).toEqual(&#39;say&#39;);&#A;      });&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;&#A;&#A;  This one shows how to debounce model changes. Model will be updated only 1 sec after last change.&#A;  If the `Clear` button is pressed, any debounced action is canceled and the value becomes empty.&#A;&#A;  &lt;example name=&quot;ngModelOptions-directive-debounce&quot; module=&quot;optionsExample&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;        &lt;form name=&quot;userForm&quot;&gt;&#A;          &lt;label&gt;Name:&#A;            &lt;input type=&quot;text&quot; name=&quot;userName&quot;&#A;                   ng-model=&quot;user.name&quot;&#A;                   ng-model-options=&quot;{ debounce: 1000 }&quot; /&gt;&#A;          &lt;/label&gt;&#A;          &lt;button ng-click=&quot;userForm.userName.$rollbackViewValue(); user.name=&#39;&#39;&quot;&gt;Clear&lt;/button&gt;&#A;          &lt;br /&gt;&#A;        &lt;/form&gt;&#A;        &lt;pre&gt;user.name = &lt;span ng-bind=&quot;user.name&quot;&gt;&lt;/span&gt;&lt;/pre&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;app.js&quot;&gt;&#A;      angular.module(&#39;optionsExample&#39;, [])&#A;        .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;          $scope.user = { name: &#39;say&#39; };&#A;        }]);&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;&#A;&#A;  This one shows how to bind to getter/setters:&#A;&#A;  &lt;example name=&quot;ngModelOptions-directive-getter-setter&quot; module=&quot;getterSetterExample&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;        &lt;form name=&quot;userForm&quot;&gt;&#A;          &lt;label&gt;Name:&#A;            &lt;input type=&quot;text&quot; name=&quot;userName&quot;&#A;                   ng-model=&quot;user.name&quot;&#A;                   ng-model-options=&quot;{ getterSetter: true }&quot; /&gt;&#A;          &lt;/label&gt;&#A;        &lt;/form&gt;&#A;        &lt;pre&gt;user.name = &lt;span ng-bind=&quot;user.name()&quot;&gt;&lt;/span&gt;&lt;/pre&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;app.js&quot;&gt;&#A;      angular.module(&#39;getterSetterExample&#39;, [])&#A;        .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;          var _name = &#39;Brian&#39;;&#A;          $scope.user = {&#A;            name: function(newName) {&#A;              // Note that newName can be undefined for two reasons:&#A;              // 1. Because it is called as a getter and thus called with no arguments&#A;              // 2. Because the property should actually be set to undefined. This happens e.g. if the&#A;              //    input is invalid&#A;              return arguments.length ? (_name = newName) : _name;&#A;            }&#A;          };&#A;        }]);&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;

			Alias: ?
			StartLine: 25307
			EndLine: 25324
			NodeType: Object

				Alias: ?($scope,$attrs)
				StartLine: 25309
				EndLine: 25323
				NodeType: AnonymousFunction

					Alias: replace.trim.updateOn&gt;?&gt;?()
					StartLine: 25316
					EndLine: 25319
					NodeType: AnonymousFunction
					Comment: extract &quot;default&quot; pseudo-event from list of events that can trigger a model update

		Alias: addSetValidityMethod(context)
		StartLine: 25330
		EndLine: 25423
		NodeType: Function
		Comment: helper methods

			Alias: setValidity(validationErrorK…ntroller)
			StartLine: 25343
			EndLine: 25389
			NodeType: Function

			Alias: createAndSet(name,value,controller)
			StartLine: 25391
			EndLine: 25396
			NodeType: Function

			Alias: unsetAndCleanup(name,value,controller)
			StartLine: 25398
			EndLine: 25405
			NodeType: Function

			Alias: cachedToggleClass(className,switchValue)
			StartLine: 25407
			EndLine: 25415
			NodeType: Function

			Alias: toggleValidationCss(validationErrorK…,isValid)
			StartLine: 25417
			EndLine: 25422
			NodeType: Function

		Alias: isObjectEmpty(obj)
		StartLine: 25425
		EndLine: 25432
		NodeType: Function

		Alias: ngDirective.ngNonBindableDirective&gt;?
		StartLine: 25466
		EndLine: 25466
		NodeType: Object
		Comment: *&#A; * @ngdoc directive&#A; * @name ngNonBindable&#A; * @restrict AC&#A; * @priority 1000&#A; *&#A; * @description&#A; * The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current&#A; * DOM element. This is useful if the element contains what appears to be Angular directives and&#A; * bindings but which should be ignored by Angular. This could be the case if you have a site that&#A; * displays snippets of code, for instance.&#A; *&#A; * @element ANY&#A; *&#A; * @example&#A; * In this example there are two locations where a simple interpolation binding (`{{}}`) is present,&#A; * but the one wrapped in `ngNonBindable` is left alone.&#A; *&#A; * @example&#A;    &lt;example&gt;&#A;      &lt;file name=&quot;index.html&quot;&gt;&#A;        &lt;div&gt;Normal: {{1 + 2}}&lt;/div&gt;&#A;        &lt;div ng-non-bindable&gt;Ignored: {{1 + 2}}&lt;/div&gt;&#A;      &lt;/file&gt;&#A;      &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       it(&#39;should check ng-non-bindable&#39;, function() {&#A;         expect(element(by.binding(&#39;1 + 2&#39;)).getText()).toContain(&#39;3&#39;);&#A;         expect(element.all(by.css(&#39;div&#39;)).last().getText()).toMatch(/1 \+ 2/);&#A;       });&#A;      &lt;/file&gt;&#A;    &lt;/example&gt;

		Alias: ?($compile,$parse)
		StartLine: 25696
		EndLine: 26185
		NodeType: AnonymousFunction

			Alias: parseOptionsExpression(optionsExp,selec…nt,scope)
			StartLine: 25698
			EndLine: 25844
			NodeType: Function

				Alias: getTrackByValue(value,key)
				StartLine: 25732
				EndLine: 25734
				NodeType: Function

				Alias: Option(selectValue,view…disabled)
				StartLine: 25752
				EndLine: 25758
				NodeType: Function

				Alias: ?
				StartLine: 25760
				EndLine: 25843
				NodeType: Object

					Alias: $parse.getWatchables&gt;?(values)
					StartLine: 25763
					EndLine: 25788
					NodeType: AnonymousFunction
					Comment: Create a collection of things that we would like to watch (watchedArray)&#D;&#A; so that they can all be watched using a single $watchCollection&#D;&#A; that only runs the handler once if anything changes

						Alias: getWatchable(key)
						StartLine: 25770
						EndLine: 25786
						NodeType: Function

					Alias: getOptions()
					StartLine: 25790
					EndLine: 25842
					NodeType: Function

						Alias: ?
						StartLine: 25830
						EndLine: 25841
						NodeType: Object

							Alias: getOptionFromViewValue(value)
							StartLine: 25833
							EndLine: 25835
							NodeType: Function

							Alias: getViewValueFromOption(option)
							StartLine: 25836
							EndLine: 25840
							NodeType: Function
							Comment: If the viewValue could be an object that may be mutated by the application,&#D;&#A; we need to make a copy and not return the reference to the value on the option.

			Alias: ?
			StartLine: 25852
			EndLine: 26184
			NodeType: Object

				Alias: link(scope,selectElem…tr,ctrls)
				StartLine: 25856
				EndLine: 26183
				NodeType: Function

					Alias: renderEmptyOption()
					StartLine: 25884
					EndLine: 25891
					NodeType: Function

					Alias: removeEmptyOption()
					StartLine: 25893
					EndLine: 25897
					NodeType: Function

					Alias: renderUnknownOption()
					StartLine: 25900
					EndLine: 25905
					NodeType: Function

					Alias: removeUnknownOption()
					StartLine: 25907
					EndLine: 25909
					NodeType: Function

					Alias: writeNgOptionsValue(value)
					StartLine: 25915
					EndLine: 25936
					NodeType: Function

					Alias: readNgOptionsValue()
					StartLine: 25938
					EndLine: 25948
					NodeType: Function

					Alias: $watch&gt;?()
					StartLine: 25954
					EndLine: 25954
					NodeType: AnonymousFunction

					Alias: $watch&gt;?()
					StartLine: 25955
					EndLine: 25955
					NodeType: AnonymousFunction

					Alias: $isEmpty(value)
					StartLine: 25961
					EndLine: 25963
					NodeType: Function

					Alias: writeNgOptionsMultiple(value)
					StartLine: 25966
					EndLine: 25977
					NodeType: Function

						Alias: forEach&gt;?(option)
						StartLine: 25967
						EndLine: 25969
						NodeType: AnonymousFunction

						Alias: forEach&gt;?(item)
						StartLine: 25972
						EndLine: 25975
						NodeType: AnonymousFunction

					Alias: readNgOptionsMultiple()
					StartLine: 25980
					EndLine: 25990
					NodeType: Function

						Alias: forEach&gt;?(value)
						StartLine: 25984
						EndLine: 25987
						NodeType: AnonymousFunction

					Alias: $watchCollection&gt;?()
					StartLine: 25996
					EndLine: 26002
					NodeType: AnonymousFunction

						Alias: map&gt;?(value)
						StartLine: 25998
						EndLine: 26000
						NodeType: AnonymousFunction

					Alias: $watchCollection&gt;?()
					StartLine: 26002
					EndLine: 26004
					NodeType: AnonymousFunction

					Alias: updateOptionElement(option,element)
					StartLine: 26036
					EndLine: 26044
					NodeType: Function

					Alias: addOrReuseElement(parent,current,t…eElement)
					StartLine: 26046
					EndLine: 26064
					NodeType: Function

					Alias: removeExcessElements(current)
					StartLine: 26067
					EndLine: 26074
					NodeType: Function

					Alias: skipEmptyAndUnknownOptions(current)
					StartLine: 26077
					EndLine: 26089
					NodeType: Function

					Alias: updateOptions()
					StartLine: 26092
					EndLine: 26181
					NodeType: Function

						Alias: updateOption(option)
						StartLine: 26108
						EndLine: 26160
						NodeType: Function

							Alias: group.group
							StartLine: 26133
							EndLine: 26136
							NodeType: Object
							Comment: Store it for use later

						Alias: forEach&gt;?(key)
						StartLine: 26164
						EndLine: 26166
						NodeType: AnonymousFunction
						Comment: Now remove all excess options and group

		Alias: ?($locale,$interpolate,$log)
		StartLine: 26362
		EndLine: 26424
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngPluralize&#A; * @restrict EA&#A; *&#A; * @description&#A; * `ngPluralize` is a directive that displays messages according to en-US localization rules.&#A; * These rules are bundled with angular.js, but can be overridden&#A; * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive&#A; * by specifying the mappings between&#A; * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)&#A; * and the strings to be displayed.&#A; *&#A; * # Plural categories and explicit number rules&#A; * There are two&#A; * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)&#A; * in Angular&#39;s default en-US locale: &quot;one&quot; and &quot;other&quot;.&#A; *&#A; * While a plural category may match many numbers (for example, in en-US locale, &quot;other&quot; can match&#A; * any number that is not 1), an explicit number rule can only match one number. For example, the&#A; * explicit number rule for &quot;3&quot; matches the number 3. There are examples of plural categories&#A; * and explicit number rules throughout the rest of this documentation.&#A; *&#A; * # Configuring ngPluralize&#A; * You configure ngPluralize by providing 2 attributes: `count` and `when`.&#A; * You can also provide an optional attribute, `offset`.&#A; *&#A; * The value of the `count` attribute can be either a string or an {@link guide/expression&#A; * Angular expression}; these are evaluated on the current scope for its bound value.&#A; *&#A; * The `when` attribute specifies the mappings between plural categories and the actual&#A; * string to be displayed. The value of the attribute should be a JSON object.&#A; *&#A; * The following example shows how to configure ngPluralize:&#A; *&#A; * ```html&#A; * &lt;ng-pluralize count=&quot;personCount&quot;&#A;                 when=&quot;{&#39;0&#39;: &#39;Nobody is viewing.&#39;,&#A; *                      &#39;one&#39;: &#39;1 person is viewing.&#39;,&#A; *                      &#39;other&#39;: &#39;{} people are viewing.&#39;}&quot;&gt;&#A; * &lt;/ng-pluralize&gt;&#A; *```&#A; *&#A; * In the example, `&quot;0: Nobody is viewing.&quot;` is an explicit number rule. If you did not&#A; * specify this rule, 0 would be matched to the &quot;other&quot; category and &quot;0 people are viewing&quot;&#A; * would be shown instead of &quot;Nobody is viewing&quot;. You can specify an explicit number rule for&#A; * other numbers, for example 12, so that instead of showing &quot;12 people are viewing&quot;, you can&#A; * show &quot;a dozen people are viewing&quot;.&#A; *&#A; * You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted&#A; * into pluralized strings. In the previous example, Angular will replace `{}` with&#A; * &lt;span ng-non-bindable&gt;`{{personCount}}`&lt;/span&gt;. The closed braces `{}` is a placeholder&#A; * for &lt;span ng-non-bindable&gt;{{numberExpression}}&lt;/span&gt;.&#A; *&#A; * If no rule is defined for a category, then an empty string is displayed and a warning is generated.&#A; * Note that some locales define more categories than `one` and `other`. For example, fr-fr defines `few` and `many`.&#A; *&#A; * # Configuring ngPluralize with offset&#A; * The `offset` attribute allows further customization of pluralized text, which can result in&#A; * a better user experience. For example, instead of the message &quot;4 people are viewing this document&quot;,&#A; * you might display &quot;John, Kate and 2 others are viewing this document&quot;.&#A; * The offset attribute allows you to offset a number by any desired value.&#A; * Let&#39;s take a look at an example:&#A; *&#A; * ```html&#A; * &lt;ng-pluralize count=&quot;personCount&quot; offset=2&#A; *               when=&quot;{&#39;0&#39;: &#39;Nobody is viewing.&#39;,&#A; *                      &#39;1&#39;: &#39;{{person1}} is viewing.&#39;,&#A; *                      &#39;2&#39;: &#39;{{person1}} and {{person2}} are viewing.&#39;,&#A; *                      &#39;one&#39;: &#39;{{person1}}, {{person2}} and one other person are viewing.&#39;,&#A; *                      &#39;other&#39;: &#39;{{person1}}, {{person2}} and {} other people are viewing.&#39;}&quot;&gt;&#A; * &lt;/ng-pluralize&gt;&#A; * ```&#A; *&#A; * Notice that we are still using two plural categories(one, other), but we added&#A; * three explicit number rules 0, 1 and 2.&#A; * When one person, perhaps John, views the document, &quot;John is viewing&quot; will be shown.&#A; * When three people view the document, no explicit number rule is found, so&#A; * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.&#A; * In this case, plural category &#39;one&#39; is matched and &quot;John, Mary and one other person are viewing&quot;&#A; * is shown.&#A; *&#A; * Note that when you specify offsets, you must provide explicit number rules for&#A; * numbers from 0 up to and including the offset. If you use an offset of 3, for example,&#A; * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for&#A; * plural categories &quot;one&quot; and &quot;other&quot;.&#A; *&#A; * @param {string|expression} count The variable to be bound to.&#A; * @param {string} when The mapping between plural category to its corresponding strings.&#A; * @param {number=} offset Offset to deduct from the total number.&#A; *&#A; * @example&#A;    &lt;example module=&quot;pluralizeExample&quot;&gt;&#A;      &lt;file name=&quot;index.html&quot;&gt;&#A;        &lt;script&gt;&#A;          angular.module(&#39;pluralizeExample&#39;, [])&#A;            .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;              $scope.person1 = &#39;Igor&#39;;&#A;              $scope.person2 = &#39;Misko&#39;;&#A;              $scope.personCount = 1;&#A;            }]);&#A;        &lt;/script&gt;&#A;        &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;          &lt;label&gt;Person 1:&lt;input type=&quot;text&quot; ng-model=&quot;person1&quot; value=&quot;Igor&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#A;          &lt;label&gt;Person 2:&lt;input type=&quot;text&quot; ng-model=&quot;person2&quot; value=&quot;Misko&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#A;          &lt;label&gt;Number of People:&lt;input type=&quot;text&quot; ng-model=&quot;personCount&quot; value=&quot;1&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#A;&#A;          &lt;!--- Example with simple pluralization rules for en locale ---&gt;&#A;          Without Offset:&#A;          &lt;ng-pluralize count=&quot;personCount&quot;&#A;                        when=&quot;{&#39;0&#39;: &#39;Nobody is viewing.&#39;,&#A;                               &#39;one&#39;: &#39;1 person is viewing.&#39;,&#A;                               &#39;other&#39;: &#39;{} people are viewing.&#39;}&quot;&gt;&#A;          &lt;/ng-pluralize&gt;&lt;br&gt;&#A;&#A;          &lt;!--- Example with offset ---&gt;&#A;          With Offset(2):&#A;          &lt;ng-pluralize count=&quot;personCount&quot; offset=2&#A;                        when=&quot;{&#39;0&#39;: &#39;Nobody is viewing.&#39;,&#A;                               &#39;1&#39;: &#39;{{person1}} is viewing.&#39;,&#A;                               &#39;2&#39;: &#39;{{person1}} and {{person2}} are viewing.&#39;,&#A;                               &#39;one&#39;: &#39;{{person1}}, {{person2}} and one other person are viewing.&#39;,&#A;                               &#39;other&#39;: &#39;{{person1}}, {{person2}} and {} other people are viewing.&#39;}&quot;&gt;&#A;          &lt;/ng-pluralize&gt;&#A;        &lt;/div&gt;&#A;      &lt;/file&gt;&#A;      &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;        it(&#39;should show correct pluralized string&#39;, function() {&#A;          var withoutOffset = element.all(by.css(&#39;ng-pluralize&#39;)).get(0);&#A;          var withOffset = element.all(by.css(&#39;ng-pluralize&#39;)).get(1);&#A;          var countInput = element(by.model(&#39;personCount&#39;));&#A;&#A;          expect(withoutOffset.getText()).toEqual(&#39;1 person is viewing.&#39;);&#A;          expect(withOffset.getText()).toEqual(&#39;Igor is viewing.&#39;);&#A;&#A;          countInput.clear();&#A;          countInput.sendKeys(&#39;0&#39;);&#A;&#A;          expect(withoutOffset.getText()).toEqual(&#39;Nobody is viewing.&#39;);&#A;          expect(withOffset.getText()).toEqual(&#39;Nobody is viewing.&#39;);&#A;&#A;          countInput.clear();&#A;          countInput.sendKeys(&#39;2&#39;);&#A;&#A;          expect(withoutOffset.getText()).toEqual(&#39;2 people are viewing.&#39;);&#A;          expect(withOffset.getText()).toEqual(&#39;Igor and Misko are viewing.&#39;);&#A;&#A;          countInput.clear();&#A;          countInput.sendKeys(&#39;3&#39;);&#A;&#A;          expect(withoutOffset.getText()).toEqual(&#39;3 people are viewing.&#39;);&#A;          expect(withOffset.getText()).toEqual(&#39;Igor, Misko and one other person are viewing.&#39;);&#A;&#A;          countInput.clear();&#A;          countInput.sendKeys(&#39;4&#39;);&#A;&#A;          expect(withoutOffset.getText()).toEqual(&#39;4 people are viewing.&#39;);&#A;          expect(withOffset.getText()).toEqual(&#39;Igor, Misko and 2 other people are viewing.&#39;);&#A;        });&#A;        it(&#39;should show data-bound names&#39;, function() {&#A;          var withOffset = element.all(by.css(&#39;ng-pluralize&#39;)).get(1);&#A;          var personCount = element(by.model(&#39;personCount&#39;));&#A;          var person1 = element(by.model(&#39;person1&#39;));&#A;          var person2 = element(by.model(&#39;person2&#39;));&#A;          personCount.clear();&#A;          personCount.sendKeys(&#39;4&#39;);&#A;          person1.clear();&#A;          person1.sendKeys(&#39;Di&#39;);&#A;          person2.clear();&#A;          person2.sendKeys(&#39;Vojta&#39;);&#A;          expect(withOffset.getText()).toEqual(&#39;Di, Vojta and 2 other people are viewing.&#39;);&#A;        });&#A;      &lt;/file&gt;&#A;    &lt;/example&gt;

			Alias: ?
			StartLine: 26366
			EndLine: 26423
			NodeType: Object

				Alias: link(scope,element,attr)
				StartLine: 26367
				EndLine: 26422
				NodeType: Function

					Alias: forEach&gt;?(expression,attributeName)
					StartLine: 26379
					EndLine: 26385
					NodeType: AnonymousFunction

					Alias: forEach&gt;?(expression,key)
					StartLine: 26386
					EndLine: 26389
					NodeType: AnonymousFunction

					Alias: ngPluralizeWatchAction(newVal)
					StartLine: 26391
					EndLine: 26417
					NodeType: Function

					Alias: updateElementText(newText)
					StartLine: 26419
					EndLine: 26421
					NodeType: Function

		Alias: ?($parse,$animate)
		StartLine: 26713
		EndLine: 26941
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngRepeat&#A; *&#A; * @description&#A; * The `ngRepeat` directive instantiates a template once per item from a collection. Each template&#A; * instance gets its own scope, where the given loop variable is set to the current collection item,&#A; * and `$index` is set to the item index or key.&#A; *&#A; * Special properties are exposed on the local scope of each template instance, including:&#A; *&#A; * | Variable  | Type            | Details                                                                     |&#A; * |-----------|-----------------|-----------------------------------------------------------------------------|&#A; * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |&#A; * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |&#A; * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |&#A; * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |&#A; * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |&#A; * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |&#A; *&#A; * Creating aliases for these properties is possible with {@link ng.directive:ngInit `ngInit`}.&#A; * This may be useful when, for instance, nesting ngRepeats.&#A; *&#A; *&#A; * # Iterating over object properties&#A; *&#A; * It is possible to get `ngRepeat` to iterate over the properties of an object using the following&#A; * syntax:&#A; *&#A; * ```js&#A; * &lt;div ng-repeat=&quot;(key, value) in myObj&quot;&gt; ... &lt;/div&gt;&#A; * ```&#A; *&#A; * You need to be aware that the JavaScript specification does not define the order of keys&#A; * returned for an object. (To mitigate this in Angular 1.3 the `ngRepeat` directive&#A; * used to sort the keys alphabetically.)&#A; *&#A; * Version 1.4 removed the alphabetic sorting. We now rely on the order returned by the browser&#A; * when running `for key in myObj`. It seems that browsers generally follow the strategy of providing&#A; * keys in the order in which they were defined, although there are exceptions when keys are deleted&#A; * and reinstated. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete#Cross-browser_issues&#A; *&#A; * If this is not desired, the recommended workaround is to convert your object into an array&#A; * that is sorted into the order that you prefer before providing it to `ngRepeat`.  You could&#A; * do this with a filter such as [toArrayFilter](http://ngmodules.org/modules/angular-toArrayFilter)&#A; * or implement a `$watch` on the object yourself.&#A; *&#A; *&#A; * # Tracking and Duplicates&#A; *&#A; * When the contents of the collection change, `ngRepeat` makes the corresponding changes to the DOM:&#A; *&#A; * * When an item is added, a new instance of the template is added to the DOM.&#A; * * When an item is removed, its template instance is removed from the DOM.&#A; * * When items are reordered, their respective templates are reordered in the DOM.&#A; *&#A; * By default, `ngRepeat` does not allow duplicate items in arrays. This is because when&#A; * there are duplicates, it is not possible to maintain a one-to-one mapping between collection&#A; * items and DOM elements.&#A; *&#A; * If you do need to repeat duplicate items, you can substitute the default tracking behavior&#A; * with your own using the `track by` expression.&#A; *&#A; * For example, you may track items by the index of each item in the collection, using the&#A; * special scope property `$index`:&#A; * ```html&#A; *    &lt;div ng-repeat=&quot;n in [42, 42, 43, 43] track by $index&quot;&gt;&#A; *      {{n}}&#A; *    &lt;/div&gt;&#A; * ```&#A; *&#A; * You may use arbitrary expressions in `track by`, including references to custom functions&#A; * on the scope:&#A; * ```html&#A; *    &lt;div ng-repeat=&quot;n in [42, 42, 43, 43] track by myTrackingFunction(n)&quot;&gt;&#A; *      {{n}}&#A; *    &lt;/div&gt;&#A; * ```&#A; *&#A; * If you are working with objects that have an identifier property, you can track&#A; * by the identifier instead of the whole object. Should you reload your data later, `ngRepeat`&#A; * will not have to rebuild the DOM elements for items it has already rendered, even if the&#A; * JavaScript objects in the collection have been substituted for new ones:&#A; * ```html&#A; *    &lt;div ng-repeat=&quot;model in collection track by model.id&quot;&gt;&#A; *      {{model.name}}&#A; *    &lt;/div&gt;&#A; * ```&#A; *&#A; * When no `track by` expression is provided, it is equivalent to tracking by the built-in&#A; * `$id` function, which tracks items by their identity:&#A; * ```html&#A; *    &lt;div ng-repeat=&quot;obj in collection track by $id(obj)&quot;&gt;&#A; *      {{obj.prop}}&#A; *    &lt;/div&gt;&#A; * ```&#A; *&#A; * # Special repeat start and end points&#A; * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending&#A; * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.&#A; * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it&#39;s defined on)&#A; * up to and including the ending HTML tag where **ng-repeat-end** is placed.&#A; *&#A; * The example below makes use of this feature:&#A; * ```html&#A; *   &lt;header ng-repeat-start=&quot;item in items&quot;&gt;&#A; *     Header {{ item }}&#A; *   &lt;/header&gt;&#A; *   &lt;div class=&quot;body&quot;&gt;&#A; *     Body {{ item }}&#A; *   &lt;/div&gt;&#A; *   &lt;footer ng-repeat-end&gt;&#A; *     Footer {{ item }}&#A; *   &lt;/footer&gt;&#A; * ```&#A; *&#A; * And with an input of {@type [&#39;A&#39;,&#39;B&#39;]} for the items variable in the example above, the output will evaluate to:&#A; * ```html&#A; *   &lt;header&gt;&#A; *     Header A&#A; *   &lt;/header&gt;&#A; *   &lt;div class=&quot;body&quot;&gt;&#A; *     Body A&#A; *   &lt;/div&gt;&#A; *   &lt;footer&gt;&#A; *     Footer A&#A; *   &lt;/footer&gt;&#A; *   &lt;header&gt;&#A; *     Header B&#A; *   &lt;/header&gt;&#A; *   &lt;div class=&quot;body&quot;&gt;&#A; *     Body B&#A; *   &lt;/div&gt;&#A; *   &lt;footer&gt;&#A; *     Footer B&#A; *   &lt;/footer&gt;&#A; * ```&#A; *&#A; * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such&#A; * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).&#A; *&#A; * @animations&#A; * **.enter** - when a new item is added to the list or when an item is revealed after a filter&#A; *&#A; * **.leave** - when an item is removed from the list or when an item is filtered out&#A; *&#A; * **.move** - when an adjacent item is filtered out causing a reorder or when the item contents are reordered&#A; *&#A; * @element ANY&#A; * @scope&#A; * @priority 1000&#A; * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These&#A; *   formats are currently supported:&#A; *&#A; *   * `variable in expression` – where variable is the user defined loop variable and `expression`&#A; *     is a scope expression giving the collection to enumerate.&#A; *&#A; *     For example: `album in artist.albums`.&#A; *&#A; *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,&#A; *     and `expression` is the scope expression giving the collection to enumerate.&#A; *&#A; *     For example: `(name, age) in {&#39;adam&#39;:10, &#39;amalie&#39;:12}`.&#A; *&#A; *   * `variable in expression track by tracking_expression` – You can also provide an optional tracking expression&#A; *     which can be used to associate the objects in the collection with the DOM elements. If no tracking expression&#A; *     is specified, ng-repeat associates elements by identity. It is an error to have&#A; *     more than one tracking expression value resolve to the same key. (This would mean that two distinct objects are&#A; *     mapped to the same DOM element, which is not possible.)  If filters are used in the expression, they should be&#A; *     applied before the tracking expression.&#A; *&#A; *     For example: `item in items` is equivalent to `item in items track by $id(item)`. This implies that the DOM elements&#A; *     will be associated by item identity in the array.&#A; *&#A; *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique&#A; *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements&#A; *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM&#A; *     element in the same way in the DOM.&#A; *&#A; *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this&#A; *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`&#A; *     property is same.&#A; *&#A; *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter&#A; *     to items in conjunction with a tracking expression.&#A; *&#A; *   * `variable in expression as alias_expression` – You can also provide an optional alias expression which will then store the&#A; *     intermediate results of the repeater after the filters have been applied. Typically this is used to render a special message&#A; *     when a filter is active on the repeater, but the filtered result set is empty.&#A; *&#A; *     For example: `item in items | filter:x as results` will store the fragment of the repeated items as `results`, but only after&#A; *     the items have been processed through the filter.&#A; *&#A; *     Please note that `as [variable name] is not an operator but rather a part of ngRepeat micro-syntax so it can be used only at the end&#A; *     (and not as operator, inside an expression).&#A; *&#A; *     For example: `item in items | filter : x | orderBy : order | limitTo : limit as results` .&#A; *&#A; * @example&#A; * This example initializes the scope to a list of names and&#A; * then uses `ngRepeat` to display every person:&#A;  &lt;example module=&quot;ngAnimate&quot; deps=&quot;angular-animate.js&quot; animations=&quot;true&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;div ng-init=&quot;friends = [&#A;        {name:&#39;John&#39;, age:25, gender:&#39;boy&#39;},&#A;        {name:&#39;Jessie&#39;, age:30, gender:&#39;girl&#39;},&#A;        {name:&#39;Johanna&#39;, age:28, gender:&#39;girl&#39;},&#A;        {name:&#39;Joy&#39;, age:15, gender:&#39;girl&#39;},&#A;        {name:&#39;Mary&#39;, age:28, gender:&#39;girl&#39;},&#A;        {name:&#39;Peter&#39;, age:95, gender:&#39;boy&#39;},&#A;        {name:&#39;Sebastian&#39;, age:50, gender:&#39;boy&#39;},&#A;        {name:&#39;Erika&#39;, age:27, gender:&#39;girl&#39;},&#A;        {name:&#39;Patrick&#39;, age:40, gender:&#39;boy&#39;},&#A;        {name:&#39;Samantha&#39;, age:60, gender:&#39;girl&#39;}&#A;      ]&quot;&gt;&#A;        I have {{friends.length}} friends. They are:&#A;        &lt;input type=&quot;search&quot; ng-model=&quot;q&quot; placeholder=&quot;filter friends...&quot; aria-label=&quot;filter friends&quot; /&gt;&#A;        &lt;ul class=&quot;example-animate-container&quot;&gt;&#A;          &lt;li class=&quot;animate-repeat&quot; ng-repeat=&quot;friend in friends | filter:q as results&quot;&gt;&#A;            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.&#A;          &lt;/li&gt;&#A;          &lt;li class=&quot;animate-repeat&quot; ng-if=&quot;results.length == 0&quot;&gt;&#A;            &lt;strong&gt;No results found...&lt;/strong&gt;&#A;          &lt;/li&gt;&#A;        &lt;/ul&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;animations.css&quot;&gt;&#A;      .example-animate-container {&#A;        background:white;&#A;        border:1px solid black;&#A;        list-style:none;&#A;        margin:0;&#A;        padding:0 10px;&#A;      }&#A;&#A;      .animate-repeat {&#A;        line-height:40px;&#A;        list-style:none;&#A;        box-sizing:border-box;&#A;      }&#A;&#A;      .animate-repeat.ng-move,&#A;      .animate-repeat.ng-enter,&#A;      .animate-repeat.ng-leave {&#A;        -webkit-transition:all linear 0.5s;&#A;        transition:all linear 0.5s;&#A;      }&#A;&#A;      .animate-repeat.ng-leave.ng-leave-active,&#A;      .animate-repeat.ng-move,&#A;      .animate-repeat.ng-enter {&#A;        opacity:0;&#A;        max-height:0;&#A;      }&#A;&#A;      .animate-repeat.ng-leave,&#A;      .animate-repeat.ng-move.ng-move-active,&#A;      .animate-repeat.ng-enter.ng-enter-active {&#A;        opacity:1;&#A;        max-height:40px;&#A;      }&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      var friends = element.all(by.repeater(&#39;friend in friends&#39;));&#A;&#A;      it(&#39;should render initial data set&#39;, function() {&#A;        expect(friends.count()).toBe(10);&#A;        expect(friends.get(0).getText()).toEqual(&#39;[1] John who is 25 years old.&#39;);&#A;        expect(friends.get(1).getText()).toEqual(&#39;[2] Jessie who is 30 years old.&#39;);&#A;        expect(friends.last().getText()).toEqual(&#39;[10] Samantha who is 60 years old.&#39;);&#A;        expect(element(by.binding(&#39;friends.length&#39;)).getText())&#A;            .toMatch(&quot;I have 10 friends. They are:&quot;);&#A;      });&#A;&#A;       it(&#39;should update repeater when filter predicate changes&#39;, function() {&#A;         expect(friends.count()).toBe(10);&#A;&#A;         element(by.model(&#39;q&#39;)).sendKeys(&#39;ma&#39;);&#A;&#A;         expect(friends.count()).toBe(2);&#A;         expect(friends.get(0).getText()).toEqual(&#39;[1] Mary who is 28 years old.&#39;);&#A;         expect(friends.last().getText()).toEqual(&#39;[2] Samantha who is 60 years old.&#39;);&#A;       });&#A;      &lt;/file&gt;&#A;    &lt;/example&gt;

			Alias: updateScope(scope,index,valu…ayLength)
			StartLine: 26717
			EndLine: 26728
			NodeType: Function
			Comment: TODO(perf): generate setters to shave off ~40ms or 1-1.5%

			Alias: getBlockStart(block)
			StartLine: 26730
			EndLine: 26732
			NodeType: Function

			Alias: getBlockEnd(block)
			StartLine: 26734
			EndLine: 26736
			NodeType: Function

			Alias: ?
			StartLine: 26739
			EndLine: 26940
			NodeType: Object

				Alias: ngRepeatCompile($element,$attr)
				StartLine: 26746
				EndLine: 26939
				NodeType: Function

					Alias: hashFnLocals
					StartLine: 26778
					EndLine: 26778
					NodeType: Object

					Alias: trackByIdArrayFn(key,value)
					StartLine: 26783
					EndLine: 26785
					NodeType: Function

					Alias: trackByIdObjFn(key)
					StartLine: 26786
					EndLine: 26788
					NodeType: Function

					Alias: ngRepeatLink($scope,$element,…ansclude)
					StartLine: 26791
					EndLine: 26938
					NodeType: Function

						Alias: trackByIdExpFn(key,value,index)
						StartLine: 26794
						EndLine: 26800
						NodeType: Function
						Comment: assign key, value, and $index to the locals so that they can be used in hash functions

						Alias: ngRepeatAction(collection)
						StartLine: 26814
						EndLine: 26937
						NodeType: Function
						Comment: watch props

		Alias: ?($animate)
		StartLine: 27101
		EndLine: 27117
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngShow&#A; *&#A; * @description&#A; * The `ngShow` directive shows or hides the given HTML element based on the expression&#A; * provided to the `ngShow` attribute. The element is shown or hidden by removing or adding&#A; * the `.ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined&#A; * in AngularJS and sets the display style to none (using an !important flag).&#A; * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).&#A; *&#A; * ```html&#A; * &lt;!-- when $scope.myValue is truthy (element is visible) --&gt;&#A; * &lt;div ng-show=&quot;myValue&quot;&gt;&lt;/div&gt;&#A; *&#A; * &lt;!-- when $scope.myValue is falsy (element is hidden) --&gt;&#A; * &lt;div ng-show=&quot;myValue&quot; class=&quot;ng-hide&quot;&gt;&lt;/div&gt;&#A; * ```&#A; *&#A; * When the `ngShow` expression evaluates to a falsy value then the `.ng-hide` CSS class is added to the class&#A; * attribute on the element causing it to become hidden. When truthy, the `.ng-hide` CSS class is removed&#A; * from the element causing the element not to appear hidden.&#A; *&#A; * ## Why is !important used?&#A; *&#A; * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector&#A; * can be easily overridden by heavier selectors. For example, something as simple&#A; * as changing the display style on a HTML list item would make hidden elements appear visible.&#A; * This also becomes a bigger issue when dealing with CSS frameworks.&#A; *&#A; * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector&#A; * specificity (when !important isn&#39;t used with any conflicting styles). If a developer chooses to override the&#A; * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.&#A; *&#A; * ### Overriding `.ng-hide`&#A; *&#A; * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change&#A; * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`&#A; * class CSS. Note that the selector that needs to be used is actually `.ng-hide:not(.ng-hide-animate)` to cope&#A; * with extra animation classes that can be added.&#A; *&#A; * ```css&#A; * .ng-hide:not(.ng-hide-animate) {&#A; *   /&amp;#42; this is just another form of hiding an element &amp;#42;/&#A; *   display: block!important;&#A; *   position: absolute;&#A; *   top: -9999px;&#A; *   left: -9999px;&#A; * }&#A; * ```&#A; *&#A; * By default you don&#39;t need to override in CSS anything and the animations will work around the display style.&#A; *&#A; * ## A note about animations with `ngShow`&#A; *&#A; * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression&#A; * is true and false. This system works like the animation system present with ngClass except that&#A; * you must also include the !important flag to override the display property&#A; * so that you can perform an animation when the element is hidden during the time of the animation.&#A; *&#A; * ```css&#A; * //&#A; * //a working example can be found at the bottom of this page&#A; * //&#A; * .my-element.ng-hide-add, .my-element.ng-hide-remove {&#A; *   /&amp;#42; this is required as of 1.3x to properly&#A; *      apply all styling in a show/hide animation &amp;#42;/&#A; *   transition: 0s linear all;&#A; * }&#A; *&#A; * .my-element.ng-hide-add-active,&#A; * .my-element.ng-hide-remove-active {&#A; *   /&amp;#42; the transition is defined in the active class &amp;#42;/&#A; *   transition: 1s linear all;&#A; * }&#A; *&#A; * .my-element.ng-hide-add { ... }&#A; * .my-element.ng-hide-add.ng-hide-add-active { ... }&#A; * .my-element.ng-hide-remove { ... }&#A; * .my-element.ng-hide-remove.ng-hide-remove-active { ... }&#A; * ```&#A; *&#A; * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display&#A; * property to block during animation states--ngAnimate will handle the style toggling automatically for you.&#A; *&#A; * @animations&#A; * addClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a truthy value and the just before contents are set to visible&#A; * removeClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a non truthy value and just before the contents are set to hidden&#A; *&#A; * @element ANY&#A; * @param {expression} ngShow If the {@link guide/expression expression} is truthy&#A; *     then the element is shown or hidden respectively.&#A; *&#A; * @example&#A;  &lt;example module=&quot;ngAnimate&quot; deps=&quot;angular-animate.js&quot; animations=&quot;true&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot; aria-label=&quot;Toggle ngHide&quot;&gt;&lt;br/&gt;&#A;      &lt;div&gt;&#A;        Show:&#A;        &lt;div class=&quot;check-element animate-show&quot; ng-show=&quot;checked&quot;&gt;&#A;          &lt;span class=&quot;glyphicon glyphicon-thumbs-up&quot;&gt;&lt;/span&gt; I show up when your checkbox is checked.&#A;        &lt;/div&gt;&#A;      &lt;/div&gt;&#A;      &lt;div&gt;&#A;        Hide:&#A;        &lt;div class=&quot;check-element animate-show&quot; ng-hide=&quot;checked&quot;&gt;&#A;          &lt;span class=&quot;glyphicon glyphicon-thumbs-down&quot;&gt;&lt;/span&gt; I hide when your checkbox is checked.&#A;        &lt;/div&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;glyphicons.css&quot;&gt;&#A;      @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;animations.css&quot;&gt;&#A;      .animate-show {&#A;        line-height: 20px;&#A;        opacity: 1;&#A;        padding: 10px;&#A;        border: 1px solid black;&#A;        background: white;&#A;      }&#A;&#A;      .animate-show.ng-hide-add.ng-hide-add-active,&#A;      .animate-show.ng-hide-remove.ng-hide-remove-active {&#A;        -webkit-transition: all linear 0.5s;&#A;        transition: all linear 0.5s;&#A;      }&#A;&#A;      .animate-show.ng-hide {&#A;        line-height: 0;&#A;        opacity: 0;&#A;        padding: 0 10px;&#A;      }&#A;&#A;      .check-element {&#A;        padding: 10px;&#A;        border: 1px solid black;&#A;        background: white;&#A;      }&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      var thumbsUp = element(by.css(&#39;span.glyphicon-thumbs-up&#39;));&#A;      var thumbsDown = element(by.css(&#39;span.glyphicon-thumbs-down&#39;));&#A;&#A;      it(&#39;should check ng-show / ng-hide&#39;, function() {&#A;        expect(thumbsUp.isDisplayed()).toBeFalsy();&#A;        expect(thumbsDown.isDisplayed()).toBeTruthy();&#A;&#A;        element(by.model(&#39;checked&#39;)).click();&#A;&#A;        expect(thumbsUp.isDisplayed()).toBeTruthy();&#A;        expect(thumbsDown.isDisplayed()).toBeFalsy();&#A;      });&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;

			Alias: ?
			StartLine: 27102
			EndLine: 27116
			NodeType: Object

				Alias: link(scope,element,attr)
				StartLine: 27105
				EndLine: 27115
				NodeType: Function

					Alias: ngShowWatchAction(value)
					StartLine: 27106
					EndLine: 27114
					NodeType: Function
					Comment: we&#39;re adding a temporary, animation-specific class for ng-hide since this way&#D;&#A; we can control when the element is actually displayed on screen without having&#D;&#A; to have a global/greedy CSS selector that breaks when other animations are run.&#D;&#A; Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845

						Alias: ?
						StartLine: 27111
						EndLine: 27113
						NodeType: Object

		Alias: ?($animate)
		StartLine: 27262
		EndLine: 27276
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngHide&#A; *&#A; * @description&#A; * The `ngHide` directive shows or hides the given HTML element based on the expression&#A; * provided to the `ngHide` attribute. The element is shown or hidden by removing or adding&#A; * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined&#A; * in AngularJS and sets the display style to none (using an !important flag).&#A; * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).&#A; *&#A; * ```html&#A; * &lt;!-- when $scope.myValue is truthy (element is hidden) --&gt;&#A; * &lt;div ng-hide=&quot;myValue&quot; class=&quot;ng-hide&quot;&gt;&lt;/div&gt;&#A; *&#A; * &lt;!-- when $scope.myValue is falsy (element is visible) --&gt;&#A; * &lt;div ng-hide=&quot;myValue&quot;&gt;&lt;/div&gt;&#A; * ```&#A; *&#A; * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added to the class&#A; * attribute on the element causing it to become hidden. When falsy, the `.ng-hide` CSS class is removed&#A; * from the element causing the element not to appear hidden.&#A; *&#A; * ## Why is !important used?&#A; *&#A; * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector&#A; * can be easily overridden by heavier selectors. For example, something as simple&#A; * as changing the display style on a HTML list item would make hidden elements appear visible.&#A; * This also becomes a bigger issue when dealing with CSS frameworks.&#A; *&#A; * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector&#A; * specificity (when !important isn&#39;t used with any conflicting styles). If a developer chooses to override the&#A; * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.&#A; *&#A; * ### Overriding `.ng-hide`&#A; *&#A; * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change&#A; * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`&#A; * class in CSS:&#A; *&#A; * ```css&#A; * .ng-hide {&#A; *   /&amp;#42; this is just another form of hiding an element &amp;#42;/&#A; *   display: block!important;&#A; *   position: absolute;&#A; *   top: -9999px;&#A; *   left: -9999px;&#A; * }&#A; * ```&#A; *&#A; * By default you don&#39;t need to override in CSS anything and the animations will work around the display style.&#A; *&#A; * ## A note about animations with `ngHide`&#A; *&#A; * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression&#A; * is true and false. This system works like the animation system present with ngClass, except that the `.ng-hide`&#A; * CSS class is added and removed for you instead of your own CSS class.&#A; *&#A; * ```css&#A; * //&#A; * //a working example can be found at the bottom of this page&#A; * //&#A; * .my-element.ng-hide-add, .my-element.ng-hide-remove {&#A; *   transition: 0.5s linear all;&#A; * }&#A; *&#A; * .my-element.ng-hide-add { ... }&#A; * .my-element.ng-hide-add.ng-hide-add-active { ... }&#A; * .my-element.ng-hide-remove { ... }&#A; * .my-element.ng-hide-remove.ng-hide-remove-active { ... }&#A; * ```&#A; *&#A; * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display&#A; * property to block during animation states--ngAnimate will handle the style toggling automatically for you.&#A; *&#A; * @animations&#A; * removeClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a truthy value and just before the contents are set to hidden&#A; * addClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a non truthy value and just before the contents are set to visible&#A; *&#A; * @element ANY&#A; * @param {expression} ngHide If the {@link guide/expression expression} is truthy then&#A; *     the element is shown or hidden respectively.&#A; *&#A; * @example&#A;  &lt;example module=&quot;ngAnimate&quot; deps=&quot;angular-animate.js&quot; animations=&quot;true&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot; aria-label=&quot;Toggle ngShow&quot;&gt;&lt;br/&gt;&#A;      &lt;div&gt;&#A;        Show:&#A;        &lt;div class=&quot;check-element animate-hide&quot; ng-show=&quot;checked&quot;&gt;&#A;          &lt;span class=&quot;glyphicon glyphicon-thumbs-up&quot;&gt;&lt;/span&gt; I show up when your checkbox is checked.&#A;        &lt;/div&gt;&#A;      &lt;/div&gt;&#A;      &lt;div&gt;&#A;        Hide:&#A;        &lt;div class=&quot;check-element animate-hide&quot; ng-hide=&quot;checked&quot;&gt;&#A;          &lt;span class=&quot;glyphicon glyphicon-thumbs-down&quot;&gt;&lt;/span&gt; I hide when your checkbox is checked.&#A;        &lt;/div&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;glyphicons.css&quot;&gt;&#A;      @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;animations.css&quot;&gt;&#A;      .animate-hide {&#A;        -webkit-transition: all linear 0.5s;&#A;        transition: all linear 0.5s;&#A;        line-height: 20px;&#A;        opacity: 1;&#A;        padding: 10px;&#A;        border: 1px solid black;&#A;        background: white;&#A;      }&#A;&#A;      .animate-hide.ng-hide {&#A;        line-height: 0;&#A;        opacity: 0;&#A;        padding: 0 10px;&#A;      }&#A;&#A;      .check-element {&#A;        padding: 10px;&#A;        border: 1px solid black;&#A;        background: white;&#A;      }&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      var thumbsUp = element(by.css(&#39;span.glyphicon-thumbs-up&#39;));&#A;      var thumbsDown = element(by.css(&#39;span.glyphicon-thumbs-down&#39;));&#A;&#A;      it(&#39;should check ng-show / ng-hide&#39;, function() {&#A;        expect(thumbsUp.isDisplayed()).toBeFalsy();&#A;        expect(thumbsDown.isDisplayed()).toBeTruthy();&#A;&#A;        element(by.model(&#39;checked&#39;)).click();&#A;&#A;        expect(thumbsUp.isDisplayed()).toBeTruthy();&#A;        expect(thumbsDown.isDisplayed()).toBeFalsy();&#A;      });&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;

			Alias: ?
			StartLine: 27263
			EndLine: 27275
			NodeType: Object

				Alias: link(scope,element,attr)
				StartLine: 27266
				EndLine: 27274
				NodeType: Function

					Alias: ngHideWatchAction(value)
					StartLine: 27267
					EndLine: 27273
					NodeType: Function
					Comment: The comment inside of the ngShowDirective explains why we add and&#D;&#A; remove a temporary class for the show/hide animation

						Alias: ?
						StartLine: 27270
						EndLine: 27272
						NodeType: Object

		Alias: ngDirective.ngStyleDirective&gt;?(scope,element,attr)
		StartLine: 27324
		EndLine: 27331
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngStyle&#A; * @restrict AC&#A; *&#A; * @description&#A; * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.&#A; *&#A; * @element ANY&#A; * @param {expression} ngStyle&#A; *&#A; * {@link guide/expression Expression} which evals to an&#A; * object whose keys are CSS style names and values are corresponding values for those CSS&#A; * keys.&#A; *&#A; * Since some CSS style names are not valid keys for an object, they must be quoted.&#A; * See the &#39;background-color&#39; style in the example below.&#A; *&#A; * @example&#A;   &lt;example&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;        &lt;input type=&quot;button&quot; value=&quot;set color&quot; ng-click=&quot;myStyle={color:&#39;red&#39;}&quot;&gt;&#A;        &lt;input type=&quot;button&quot; value=&quot;set background&quot; ng-click=&quot;myStyle={&#39;background-color&#39;:&#39;blue&#39;}&quot;&gt;&#A;        &lt;input type=&quot;button&quot; value=&quot;clear&quot; ng-click=&quot;myStyle={}&quot;&gt;&#A;        &lt;br/&gt;&#A;        &lt;span ng-style=&quot;myStyle&quot;&gt;Sample Text&lt;/span&gt;&#A;        &lt;pre&gt;myStyle={{myStyle}}&lt;/pre&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;style.css&quot;&gt;&#A;       span {&#A;         color: black;&#A;       }&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;       var colorSpan = element(by.css(&#39;span&#39;));&#A;&#A;       it(&#39;should check ng-style&#39;, function() {&#A;         expect(colorSpan.getCssValue(&#39;color&#39;)).toBe(&#39;rgba(0, 0, 0, 1)&#39;);&#A;         element(by.css(&#39;input[value=\&#39;set color\&#39;]&#39;)).click();&#A;         expect(colorSpan.getCssValue(&#39;color&#39;)).toBe(&#39;rgba(255, 0, 0, 1)&#39;);&#A;         element(by.css(&#39;input[value=clear]&#39;)).click();&#A;         expect(colorSpan.getCssValue(&#39;color&#39;)).toBe(&#39;rgba(0, 0, 0, 1)&#39;);&#A;       });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;

			Alias: ngStyleWatchAction(newStyles,oldStyles)
			StartLine: 27325
			EndLine: 27330
			NodeType: Function

				Alias: forEach&gt;?(val,style)
				StartLine: 27327
				EndLine: 27327
				NodeType: AnonymousFunction

		Alias: ?($animate)
		StartLine: 27461
		EndLine: 27513
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name ngSwitch&#A; * @restrict EA&#A; *&#A; * @description&#A; * The `ngSwitch` directive is used to conditionally swap DOM structure on your template based on a scope expression.&#A; * Elements within `ngSwitch` but without `ngSwitchWhen` or `ngSwitchDefault` directives will be preserved at the location&#A; * as specified in the template.&#A; *&#A; * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it&#A; * from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element&#A; * matches the value obtained from the evaluated expression. In other words, you define a container element&#A; * (where you place the directive), place an expression on the **`on=&quot;...&quot;` attribute**&#A; * (or the **`ng-switch=&quot;...&quot;` attribute**), define any inner elements inside of the directive and place&#A; * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on&#A; * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default&#A; * attribute is displayed.&#A; *&#A; * &lt;div class=&quot;alert alert-info&quot;&gt;&#A; * Be aware that the attribute values to match against cannot be expressions. They are interpreted&#A; * as literal string values to match against.&#A; * For example, **`ng-switch-when=&quot;someVal&quot;`** will match against the string `&quot;someVal&quot;` not against the&#A; * value of the expression `$scope.someVal`.&#A; * &lt;/div&gt;&#A;&#A; * @animations&#A; * enter - happens after the ngSwitch contents change and the matched child element is placed inside the container&#A; * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM&#A; *&#A; * @usage&#A; *&#A; * ```&#A; * &lt;ANY ng-switch=&quot;expression&quot;&gt;&#A; *   &lt;ANY ng-switch-when=&quot;matchValue1&quot;&gt;...&lt;/ANY&gt;&#A; *   &lt;ANY ng-switch-when=&quot;matchValue2&quot;&gt;...&lt;/ANY&gt;&#A; *   &lt;ANY ng-switch-default&gt;...&lt;/ANY&gt;&#A; * &lt;/ANY&gt;&#A; * ```&#A; *&#A; *&#A; * @scope&#A; * @priority 1200&#A; * @param {*} ngSwitch|on expression to match against &lt;code&gt;ng-switch-when&lt;/code&gt;.&#A; * On child elements add:&#A; *&#A; * * `ngSwitchWhen`: the case statement to match against. If match then this&#A; *   case will be displayed. If the same match appears multiple times, all the&#A; *   elements will be displayed.&#A; * * `ngSwitchDefault`: the default case when no other case match. If there&#A; *   are multiple default cases, all of them will be displayed when no other&#A; *   case match.&#A; *&#A; *&#A; * @example&#A;  &lt;example module=&quot;switchExample&quot; deps=&quot;angular-animate.js&quot; animations=&quot;true&quot;&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;        &lt;select ng-model=&quot;selection&quot; ng-options=&quot;item for item in items&quot;&gt;&#A;        &lt;/select&gt;&#A;        &lt;code&gt;selection={{selection}}&lt;/code&gt;&#A;        &lt;hr/&gt;&#A;        &lt;div class=&quot;animate-switch-container&quot;&#A;          ng-switch on=&quot;selection&quot;&gt;&#A;            &lt;div class=&quot;animate-switch&quot; ng-switch-when=&quot;settings&quot;&gt;Settings Div&lt;/div&gt;&#A;            &lt;div class=&quot;animate-switch&quot; ng-switch-when=&quot;home&quot;&gt;Home Span&lt;/div&gt;&#A;            &lt;div class=&quot;animate-switch&quot; ng-switch-default&gt;default&lt;/div&gt;&#A;        &lt;/div&gt;&#A;      &lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;script.js&quot;&gt;&#A;      angular.module(&#39;switchExample&#39;, [&#39;ngAnimate&#39;])&#A;        .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;          $scope.items = [&#39;settings&#39;, &#39;home&#39;, &#39;other&#39;];&#A;          $scope.selection = $scope.items[0];&#A;        }]);&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;animations.css&quot;&gt;&#A;      .animate-switch-container {&#A;        position:relative;&#A;        background:white;&#A;        border:1px solid black;&#A;        height:40px;&#A;        overflow:hidden;&#A;      }&#A;&#A;      .animate-switch {&#A;        padding:10px;&#A;      }&#A;&#A;      .animate-switch.ng-animate {&#A;        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;&#A;        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;&#A;&#A;        position:absolute;&#A;        top:0;&#A;        left:0;&#A;        right:0;&#A;        bottom:0;&#A;      }&#A;&#A;      .animate-switch.ng-leave.ng-leave-active,&#A;      .animate-switch.ng-enter {&#A;        top:-50px;&#A;      }&#A;      .animate-switch.ng-leave,&#A;      .animate-switch.ng-enter.ng-enter-active {&#A;        top:0;&#A;      }&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      var switchElem = element(by.css(&#39;[ng-switch]&#39;));&#A;      var select = element(by.model(&#39;selection&#39;));&#A;&#A;      it(&#39;should start in settings&#39;, function() {&#A;        expect(switchElem.getText()).toMatch(/Settings Div/);&#A;      });&#A;      it(&#39;should change to home&#39;, function() {&#A;        select.all(by.css(&#39;option&#39;)).get(1).click();&#A;        expect(switchElem.getText()).toMatch(/Home Span/);&#A;      });&#A;      it(&#39;should select default&#39;, function() {&#A;        select.all(by.css(&#39;option&#39;)).get(2).click();&#A;        expect(switchElem.getText()).toMatch(/default/);&#A;      });&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;

			Alias: ?
			StartLine: 27462
			EndLine: 27512
			NodeType: Object

				Alias: ngSwitchController()
				StartLine: 27466
				EndLine: 27468
				NodeType: Function
				Comment: asks for $scope to fool the BC controller module

				Alias: link(scope,element,at…ntroller)
				StartLine: 27469
				EndLine: 27511
				NodeType: Function

					Alias: spliceFactory(array,index)
					StartLine: 27476
					EndLine: 27478
					NodeType: Function

						Alias: ?()
						StartLine: 27477
						EndLine: 27477
						NodeType: AnonymousFunction

					Alias: ngSwitchWatchAction(value)
					StartLine: 27480
					EndLine: 27510
					NodeType: Function

						Alias: forEach&gt;?(selectedTransclude)
						StartLine: 27498
						EndLine: 27508
						NodeType: AnonymousFunction

							Alias: transclude&gt;?(caseElement,selectedScope)
							StartLine: 27499
							EndLine: 27507
							NodeType: AnonymousFunction

								Alias: block
								StartLine: 27503
								EndLine: 27503
								NodeType: Object

		Alias: ngDirective.ngSwitchWhenDirective&gt;?
		StartLine: 27515
		EndLine: 27524
		NodeType: Object

			Alias: link(scope,element,at…ansclude)
			StartLine: 27520
			EndLine: 27523
			NodeType: Function

				Alias: push&gt;?
				StartLine: 27522
				EndLine: 27522
				NodeType: Object

		Alias: ngDirective.ngSwitchDefaultDirective&gt;?
		StartLine: 27526
		EndLine: 27535
		NodeType: Object

			Alias: link(scope,element,at…ansclude)
			StartLine: 27531
			EndLine: 27534
			NodeType: Function

				Alias: push&gt;?
				StartLine: 27533
				EndLine: 27533
				NodeType: Object

		Alias: ngDirective.ngTranscludeDirective&gt;?
		StartLine: 27591
		EndLine: 27607
		NodeType: Object
		Comment: *&#A; * @ngdoc directive&#A; * @name ngTransclude&#A; * @restrict EAC&#A; *&#A; * @description&#A; * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.&#A; *&#A; * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.&#A; *&#A; * @element ANY&#A; *&#A; * @example&#A;   &lt;example module=&quot;transcludeExample&quot;&gt;&#A;     &lt;file name=&quot;index.html&quot;&gt;&#A;       &lt;script&gt;&#A;         angular.module(&#39;transcludeExample&#39;, [])&#A;          .directive(&#39;pane&#39;, function(){&#A;             return {&#A;               restrict: &#39;E&#39;,&#A;               transclude: true,&#A;               scope: { title:&#39;@&#39; },&#A;               template: &#39;&lt;div style=&quot;border: 1px solid black;&quot;&gt;&#39; +&#A;                           &#39;&lt;div style=&quot;background-color: gray&quot;&gt;{{title}}&lt;/div&gt;&#39; +&#A;                           &#39;&lt;ng-transclude&gt;&lt;/ng-transclude&gt;&#39; +&#A;                         &#39;&lt;/div&gt;&#39;&#A;             };&#A;         })&#A;         .controller(&#39;ExampleController&#39;, [&#39;$scope&#39;, function($scope) {&#A;           $scope.title = &#39;Lorem Ipsum&#39;;&#A;           $scope.text = &#39;Neque porro quisquam est qui dolorem ipsum quia dolor...&#39;;&#A;         }]);&#A;       &lt;/script&gt;&#A;       &lt;div ng-controller=&quot;ExampleController&quot;&gt;&#A;         &lt;input ng-model=&quot;title&quot; aria-label=&quot;title&quot;&gt; &lt;br/&gt;&#A;         &lt;textarea ng-model=&quot;text&quot; aria-label=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&#A;         &lt;pane title=&quot;{{title}}&quot;&gt;{{text}}&lt;/pane&gt;&#A;       &lt;/div&gt;&#A;     &lt;/file&gt;&#A;     &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;        it(&#39;should have transcluded&#39;, function() {&#A;          var titleElement = element(by.model(&#39;title&#39;));&#A;          titleElement.clear();&#A;          titleElement.sendKeys(&#39;TITLE&#39;);&#A;          var textElement = element(by.model(&#39;text&#39;));&#A;          textElement.clear();&#A;          textElement.sendKeys(&#39;TEXT&#39;);&#A;          expect(element(by.binding(&#39;title&#39;)).getText()).toEqual(&#39;TITLE&#39;);&#A;          expect(element(by.binding(&#39;text&#39;)).getText()).toEqual(&#39;TEXT&#39;);&#A;        });&#A;     &lt;/file&gt;&#A;   &lt;/example&gt;&#A; *

			Alias: link($scope,$element,…ansclude)
			StartLine: 27593
			EndLine: 27606
			NodeType: Function

				Alias: $transclude&gt;?(clone)
				StartLine: 27602
				EndLine: 27605
				NodeType: AnonymousFunction

		Alias: ?($templateCache)
		StartLine: 27642
		EndLine: 27655
		NodeType: AnonymousFunction
		Comment: *&#A; * @ngdoc directive&#A; * @name script&#A; * @restrict E&#A; *&#A; * @description&#A; * Load the content of a `&lt;script&gt;` element into {@link ng.$templateCache `$templateCache`}, so that the&#A; * template can be used by {@link ng.directive:ngInclude `ngInclude`},&#A; * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive directives}. The type of the&#A; * `&lt;script&gt;` element must be specified as `text/ng-template`, and a cache name for the template must be&#A; * assigned through the element&#39;s `id`, which can then be used as a directive&#39;s `templateUrl`.&#A; *&#A; * @param {string} type Must be set to `&#39;text/ng-template&#39;`.&#A; * @param {string} id Cache name of the template.&#A; *&#A; * @example&#A;  &lt;example&gt;&#A;    &lt;file name=&quot;index.html&quot;&gt;&#A;      &lt;script type=&quot;text/ng-template&quot; id=&quot;/tpl.html&quot;&gt;&#A;        Content of the template.&#A;      &lt;/script&gt;&#A;&#A;      &lt;a ng-click=&quot;currentTpl=&#39;/tpl.html&#39;&quot; id=&quot;tpl-link&quot;&gt;Load inlined template&lt;/a&gt;&#A;      &lt;div id=&quot;tpl-content&quot; ng-include src=&quot;currentTpl&quot;&gt;&lt;/div&gt;&#A;    &lt;/file&gt;&#A;    &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#A;      it(&#39;should load template defined inside script tag&#39;, function() {&#A;        element(by.css(&#39;#tpl-link&#39;)).click();&#A;        expect(element(by.css(&#39;#tpl-content&#39;)).getText()).toMatch(/Content of the template/);&#A;      });&#A;    &lt;/file&gt;&#A;  &lt;/example&gt;

			Alias: ?
			StartLine: 27643
			EndLine: 27654
			NodeType: Object

				Alias: compile(element,attr)
				StartLine: 27646
				EndLine: 27653
				NodeType: Function

		Alias: noopNgModelController
		StartLine: 27657
		EndLine: 27657
		NodeType: Object

		Alias: ?($element,$scope,$attrs)
		StartLine: 27668
		EndLine: 27755
		NodeType: AnonymousFunction

			Alias: renderUnknownOption(val)
			StartLine: 27683
			EndLine: 27688
			NodeType: Function

			Alias: $on&gt;?()
			StartLine: 27690
			EndLine: 27693
			NodeType: AnonymousFunction
			Comment: disable unknown option so that we don&#39;t do work when the whole select is being destroyed

			Alias: removeUnknownOption()
			StartLine: 27695
			EndLine: 27697
			NodeType: Function

			Alias: readSingleValue()
			StartLine: 27702
			EndLine: 27705
			NodeType: Function
			Comment: Read the value of the select control, the implementation of this changes depending&#D;&#A; upon whether the select can have multiple values and whether ngOptions is at work.

			Alias: writeSingleValue(value)
			StartLine: 27710
			EndLine: 27723
			NodeType: Function
			Comment: Write the value to the select control, the implementation of this changes depending&#D;&#A; upon whether the select can have multiple values and whether ngOptions is at work.

			Alias: addOption(value,element)
			StartLine: 27727
			EndLine: 27734
			NodeType: Function
			Comment: Tell the select control that an option, with the given value, has been added

			Alias: removeOption(value)
			StartLine: 27737
			EndLine: 27749
			NodeType: Function
			Comment: Tell the select control that an option, with the given value, has been removed

			Alias: hasOption(value)
			StartLine: 27752
			EndLine: 27754
			NodeType: Function
			Comment: Check whether the select control has an option matching the given value

		Alias: selectDirective()
		StartLine: 27785
		EndLine: 27862
		NodeType: Function
		Comment: *&#A; * @ngdoc directive&#A; * @name select&#A; * @restrict E&#A; *&#A; * @description&#A; * HTML `SELECT` element with angular data-binding.&#A; *&#A; * In many cases, `ngRepeat` can be used on `&lt;option&gt;` elements instead of {@link ng.directive:ngOptions&#A; * ngOptions} to achieve a similar result. However, `ngOptions` provides some benefits such as reducing&#A; * memory and increasing speed by not creating a new scope for each repeated instance, as well as providing&#A; * more flexibility in how the `&lt;select&gt;`&#39;s model is assigned via the `select` **`as`** part of the&#A; * comprehension expression. `ngOptions` should be used when the `&lt;select&gt;` model needs to be bound&#A; * to a non-string value. This is because an option element can only be bound to string values at&#A; * present.&#A; *&#A; * When an item in the `&lt;select&gt;` menu is selected, the array element or object property&#A; * represented by the selected option will be bound to the model identified by the `ngModel`&#A; * directive.&#A; *&#A; * If the viewValue contains a value that doesn&#39;t match any of the options then the control&#A; * will automatically add an &quot;unknown&quot; option, which it then removes when this is resolved.&#A; *&#A; * Optionally, a single hard-coded `&lt;option&gt;` element, with the value set to an empty string, can&#A; * be nested into the `&lt;select&gt;` element. This element will then represent the `null` or &quot;not selected&quot;&#A; * option. See example below for demonstration.&#A; *

			Alias: ?
			StartLine: 27787
			EndLine: 27861
			NodeType: Object

				Alias: link(scope,element,attr,ctrls)
				StartLine: 27791
				EndLine: 27860
				NodeType: Function

					Alias: $render()
					StartLine: 27804
					EndLine: 27806
					NodeType: Function
					Comment: We delegate rendering to the `writeValue` method, which can be changed&#D;&#A; if the select can have multiple selected values or if the options are being&#D;&#A; generated by `ngOptions`

					Alias: on&gt;?()
					StartLine: 27811
					EndLine: 27815
					NodeType: AnonymousFunction
					Comment: When the selected item(s) changes we delegate getting the value of the select control&#D;&#A; to the `readValue` method, which can be changed if the select can have multiple&#D;&#A; selected values or if the options are being generated by `ngOptions`

						Alias: $apply&gt;?()
						StartLine: 27812
						EndLine: 27814
						NodeType: AnonymousFunction

					Alias: readMultipleValue()
					StartLine: 27824
					EndLine: 27832
					NodeType: Function
					Comment: Read value now needs to check each option to see if it is selected

						Alias: forEach&gt;?(option)
						StartLine: 27826
						EndLine: 27830
						NodeType: AnonymousFunction

					Alias: writeMultipleValue(value)
					StartLine: 27835
					EndLine: 27840
					NodeType: Function
					Comment: Write value now needs to set the selected property of each matching option

						Alias: forEach&gt;?(option)
						StartLine: 27837
						EndLine: 27839
						NodeType: AnonymousFunction

					Alias: selectMultipleWatch()
					StartLine: 27845
					EndLine: 27851
					NodeType: Function

					Alias: $isEmpty(value)
					StartLine: 27855
					EndLine: 27857
					NodeType: Function
					Comment: If we are a multiple select then value is now a collection&#D;&#A; so the meaning of $isEmpty changes

		Alias: ?($interpolate)
		StartLine: 27868
		EndLine: 27930
		NodeType: AnonymousFunction
		Comment: The option directive is purely designed to communicate the existence (or lack of)&#D;&#A; of dynamically created (and destroyed) option elements to their containing select&#D;&#A; directive via its controller.

			Alias: chromeHack(optionElement)
			StartLine: 27870
			EndLine: 27877
			NodeType: Function
			Comment: Workaround for https://code.google.com/p/chromium/issues/detail?id=381459&#D;&#A; Adding an &lt;option selected=&quot;selected&quot;&gt; element to a &lt;select required=&quot;required&quot;&gt; should&#D;&#A; automatically select the new element

			Alias: ?
			StartLine: 27879
			EndLine: 27929
			NodeType: Object

				Alias: compile(element,attr)
				StartLine: 27882
				EndLine: 27928
				NodeType: Function

					Alias: ?(scope,element,attr)
					StartLine: 27893
					EndLine: 27927
					NodeType: AnonymousFunction

						Alias: interpolateWatchAction(newVal,oldVal)
						StartLine: 27907
						EndLine: 27915
						NodeType: Function

						Alias: on&gt;?()
						StartLine: 27922
						EndLine: 27925
						NodeType: AnonymousFunction

		Alias: valueFn.styleDirective&gt;?
		StartLine: 27932
		EndLine: 27935
		NodeType: Object

		Alias: requiredDirective()
		StartLine: 27937
		EndLine: 27954
		NodeType: Function

			Alias: ?
			StartLine: 27938
			EndLine: 27953
			NodeType: Object

				Alias: link(scope,elm,attr,ctrl)
				StartLine: 27941
				EndLine: 27952
				NodeType: Function

					Alias: required(modelValue,viewValue)
					StartLine: 27945
					EndLine: 27947
					NodeType: Function

					Alias: $observe&gt;?()
					StartLine: 27949
					EndLine: 27951
					NodeType: AnonymousFunction

		Alias: patternDirective()
		StartLine: 27957
		EndLine: 27985
		NodeType: Function

			Alias: ?
			StartLine: 27958
			EndLine: 27984
			NodeType: Object

				Alias: link(scope,elm,attr,ctrl)
				StartLine: 27961
				EndLine: 27983
				NodeType: Function

					Alias: $observe&gt;?(regex)
					StartLine: 27965
					EndLine: 27978
					NodeType: AnonymousFunction

					Alias: pattern(value)
					StartLine: 27980
					EndLine: 27982
					NodeType: Function

		Alias: maxlengthDirective()
		StartLine: 27988
		EndLine: 28006
		NodeType: Function

			Alias: ?
			StartLine: 27989
			EndLine: 28005
			NodeType: Object

				Alias: link(scope,elm,attr,ctrl)
				StartLine: 27992
				EndLine: 28004
				NodeType: Function

					Alias: $observe&gt;?(value)
					StartLine: 27996
					EndLine: 28000
					NodeType: AnonymousFunction

					Alias: maxlength(modelValue,viewValue)
					StartLine: 28001
					EndLine: 28003
					NodeType: Function

		Alias: minlengthDirective()
		StartLine: 28008
		EndLine: 28025
		NodeType: Function

			Alias: ?
			StartLine: 28009
			EndLine: 28024
			NodeType: Object

				Alias: link(scope,elm,attr,ctrl)
				StartLine: 28012
				EndLine: 28023
				NodeType: Function

					Alias: $observe&gt;?(value)
					StartLine: 28016
					EndLine: 28019
					NodeType: AnonymousFunction

					Alias: minlength(modelValue,viewValue)
					StartLine: 28020
					EndLine: 28022
					NodeType: Function

		Alias: ready&gt;?()
		StartLine: 28039
		EndLine: 28041
		NodeType: AnonymousFunction

